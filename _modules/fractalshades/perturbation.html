<!== Adding "Fork me on Github" ribbon ==>
<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>fractalshades.perturbation &mdash; Fractalshades 1.1.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../../_static/rtd_dark.css?v=e3debd14" />
      <link rel="stylesheet" type="text/css" href="../../_static/math.css?v=7fc59cab" />
      <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery.css?v=61a4c737" />
      <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-binder.css?v=f4aeca0c" />
      <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-dataframe.css?v=2082cf3c" />
      <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-rendered-html.css?v=1277b6f3" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=58fbf978"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link href="../../_static/ribbon.css" rel="stylesheet" type="text/css">

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            Fractalshades
              <img src="../../_static/logo3.jpg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                1.1.1
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started.html">Getting started</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../getting_started.html#installing">Installing</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../getting_started.html#installing-gmp-mpfr-mpc-windows-users">Installing GMP / MPFR / MPC: Windows users</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../getting_started.html#installing-gmp-mpfr-mpc-unix-linux-users">Installing GMP / MPFR / MPC: Unix / Linux users</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../getting_started.html#installing-gmp-mpfr-mpc-mac-users">Installing GMP / MPFR / MPC: Mac users</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../getting_started.html#a-5-minutes-guide-to-fractalshades">A 5-minutes guide to fractalshades</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../getting_started.html#graphical-user-interface">Graphical user interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../getting_started.html#finding-areas-of-interest">Finding areas of interest</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../getting_started.html#unskewing-streched-areas">Unskewing streched areas</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../math.html">Mathematical background</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../math.html#zoom-level-and-native-floating-point-precision">Zoom level and native floating-point precision</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../math.html#perturbation-theory">Perturbation Theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../math.html#avoiding-loss-of-precision">Avoiding loss of precision</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../math.html#billinear-approximations">Billinear approximations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../math.html#extended-range-floating-points">Extended range floating points</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../math.html#finding-minibrots">Finding minibrots</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../math.html#going-further-a-few-references">Going further: a few references</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/index.html">Gallery</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../examples/index.html#batch-mode-gallery">Batch mode gallery</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../examples/index.html#colormaps-template-gallery">Colormaps template gallery</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../examples/index.html#gui-mode-arbitrary-precision-implementations">GUI-mode: arbitrary precision implementations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../examples/index.html#gui-mode-standard-implementation-examples">GUI-mode: standard implementation examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../examples/index.html#lighting-examples-gallery">Lighting examples gallery</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../examples/index.html#projections">Projections</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../examples/batch_mode/index.html">Batch mode gallery</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../examples/batch_mode/01-full_basic.html">01 - Full Mandelbrot basic example</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/batch_mode/02-bulb_fieldlines1.html">02 - Bulb fieldlines example “tint_or_shade”</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/batch_mode/03-bulb_fieldlines2.html">03 - Bulb fieldlines example “twinfield”</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/batch_mode/04-seahorse_shaded.html">04 - Seahorse shaded example</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/batch_mode/05-seahorse_shaded_colored.html">05 - Seahorse shaded and colored example</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/batch_mode/06-seahorse_interior.html">06 - Seahorse interior example</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/batch_mode/07-seahorse_DEM.html">07 - Seahorse DEM example</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/batch_mode/08-run_perturb_DEM.html">08 - DEM example with perturbation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/batch_mode/09-run_flake_DEM.html">09 - A deeper DEM example</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/batch_mode/10-double_embedded_julia.html">10 - Double embedded Julia set</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/batch_mode/11-run_perturbdeep.html">11- Ultra-deep embedded Julia set</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/batch_mode/12-burning_ship_deep.html">12 - Burning Ship deep zoom</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/batch_mode/13-burning_ship.html">13 - Burning ship DEM</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/batch_mode/14-burning_ship-deeper_DEM.html">14 - Burning ship deeper DEM</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/batch_mode/15-burning_ship-deepJulia_DEM.html">15 - Burning Ship ultra-deep embedded Julia set</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/batch_mode/16-tetration_spring.html">16 - Tetration (power tower) zoom: “Spring”</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/batch_mode/17-perpendicular_burning_ship_DEM.html">17 - “Perpendicular” Burning Ship</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/batch_mode/18-perpendicular_burning_ship_glynn.html">18 - “Perpendicular” Burning Ship: hidden Glynn spiral</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/batch_mode/19-perpendicular_burning_ship_Koch.html">19 - “Perpendicular” Burning Ship: hidden Koch snowflakes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/batch_mode/20-perpendicular_burning_ship_Sierpinski.html">20 - “Perpendicular” Burning Ship: hidden Sierpinski carpets</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/batch_mode/21-perpendicular_burning_ship_trees.html">21 - “Perpendicular” Burning Ship: tree structures</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/batch_mode/22-shark_fin_deep.html">22 - “Shark Fin” escape-time fractal</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/batch_mode/23-deep_min.html">23 - A deep mini</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../examples/colormaps/index.html">Colormaps template gallery</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../examples/colormaps/plot_cmaps.html">Colormaps: available templates</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../examples/interactive_deepzoom/index.html">GUI-mode: arbitrary precision implementations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../examples/interactive_deepzoom/D01_run_interactive.html">D01 - Mandelbrot arbitrary-precision explorer</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/interactive_deepzoom/D02_run_BS_interactive.html">D02 - Burning Ship arbitrary-precision explorer</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/interactive_deepzoom/D03_run_interactive_Mn.html">D03 - Mandelbrot arbitrary-precision explorer</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../examples/interactive_standard/index.html">GUI-mode: standard implementation examples</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../examples/interactive_standard/S01_run_interactive_shallow.html">S01 - Mandelbrot explorer - Standard precision</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/interactive_standard/S02_run_BS_shallow.html">S02 - Burning ship explorer - Standard precision</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/interactive_standard/S03_run_interactive_Mn_shallow.html">S03 - Mandelbrot power n explorer - Standard precision</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/interactive_standard/S04_run_collatz.html">S04 - Collatz explorer - Standard precision</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/interactive_standard/S05_run_power_tower_shallow.html">S05 - Tetration fractal explorer - Standard precision</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../examples/lighting/index.html">Lighting examples gallery</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../examples/lighting/plot_lighting.html">Ligthings: available effects</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../examples/projections/index.html">Projections</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../examples/projections/P01-feigenbaum_expmap.html">P01 - Exponential mapping: Feigenbaum point</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/projections/P02-inversion.html">P02 - Inversion of the Mandelbrot set</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/projections/P03-Elephant_valley_moebius.html">P03 - Moebius mapping: Elephant and Seahorse valleys</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/projections/P04-deep_expmap.html">P04 - Exponential mapping for deep zoom</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../API.html">Application Programming Interface</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../API/settings.html">Application-level settings</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../API/settings.html#fractalshades.settings.enable_multithreading"><code class="docutils literal notranslate"><span class="pre">enable_multithreading</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../API/settings.html#fractalshades.settings.skip_calc"><code class="docutils literal notranslate"><span class="pre">skip_calc</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../API/settings.html#fractalshades.settings.newton_zoom_level"><code class="docutils literal notranslate"><span class="pre">newton_zoom_level</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../API/settings.html#fractalshades.settings.no_newton"><code class="docutils literal notranslate"><span class="pre">no_newton</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../API/settings.html#fractalshades.settings.inspect_calc"><code class="docutils literal notranslate"><span class="pre">inspect_calc</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../API/settings.html#fractalshades.settings.chunk_size"><code class="docutils literal notranslate"><span class="pre">chunk_size</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../API/settings.html#fractalshades.settings.verbosity"><code class="docutils literal notranslate"><span class="pre">verbosity</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../API/settings.html#fractalshades.settings.postproc_dtype"><code class="docutils literal notranslate"><span class="pre">postproc_dtype</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../API/settings.html#fractalshades.settings.log_directory"><code class="docutils literal notranslate"><span class="pre">log_directory</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../API/settings.html#fractalshades.settings.disable_decompression_size_check"><code class="docutils literal notranslate"><span class="pre">disable_decompression_size_check()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../API/settings.html#fractalshades.settings.BLA_compression"><code class="docutils literal notranslate"><span class="pre">BLA_compression</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../API/settings.html#fractalshades.settings.GUI_image_Mblimit"><code class="docutils literal notranslate"><span class="pre">GUI_image_Mblimit</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../API/core.html">Core components</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../API/core.html#fractalshades.Fractal"><code class="docutils literal notranslate"><span class="pre">Fractal</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/core.html#fractalshades.Fractal.__init__"><code class="docutils literal notranslate"><span class="pre">Fractal.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/core.html#fractalshades.Fractal.clean_up"><code class="docutils literal notranslate"><span class="pre">Fractal.clean_up()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/core.html#fractalshades.Fractal.zoom"><code class="docutils literal notranslate"><span class="pre">Fractal.zoom()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/core.html#fractalshades.PerturbationFractal"><code class="docutils literal notranslate"><span class="pre">PerturbationFractal</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/core.html#fractalshades.PerturbationFractal.__init__"><code class="docutils literal notranslate"><span class="pre">PerturbationFractal.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/core.html#fractalshades.PerturbationFractal.zoom"><code class="docutils literal notranslate"><span class="pre">PerturbationFractal.zoom()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/core.html#fractalshades.Fractal_plotter"><code class="docutils literal notranslate"><span class="pre">Fractal_plotter</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/core.html#fractalshades.Fractal_plotter.__init__"><code class="docutils literal notranslate"><span class="pre">Fractal_plotter.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/core.html#fractalshades.Fractal_plotter.add_layer"><code class="docutils literal notranslate"><span class="pre">Fractal_plotter.add_layer()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/core.html#fractalshades.Fractal_plotter.plot"><code class="docutils literal notranslate"><span class="pre">Fractal_plotter.plot()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/core.html#fractalshades.Fractal_plotter.save_db"><code class="docutils literal notranslate"><span class="pre">Fractal_plotter.save_db()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/core.html#fractalshades.zoom_options"><code class="docutils literal notranslate"><span class="pre">zoom_options()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../API/core.html#fractalshades.calc_options"><code class="docutils literal notranslate"><span class="pre">calc_options()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../API/core.html#fractalshades.interactive_options"><code class="docutils literal notranslate"><span class="pre">interactive_options()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../API/projection.html">Projections</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../API/projection.html#fractalshades.projection.Projection"><code class="docutils literal notranslate"><span class="pre">Projection</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/projection.html#fractalshades.projection.Projection.__init__"><code class="docutils literal notranslate"><span class="pre">Projection.__init__()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/projection.html#fractalshades.projection.Cartesian"><code class="docutils literal notranslate"><span class="pre">Cartesian</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/projection.html#fractalshades.projection.Cartesian.__init__"><code class="docutils literal notranslate"><span class="pre">Cartesian.__init__()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/projection.html#fractalshades.projection.Expmap"><code class="docutils literal notranslate"><span class="pre">Expmap</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/projection.html#fractalshades.projection.Expmap.__init__"><code class="docutils literal notranslate"><span class="pre">Expmap.__init__()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/projection.html#fractalshades.projection.Generic_mapping"><code class="docutils literal notranslate"><span class="pre">Generic_mapping</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/projection.html#fractalshades.projection.Generic_mapping.__init__"><code class="docutils literal notranslate"><span class="pre">Generic_mapping.__init__()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../API/arbitrary_models.html">Fractal models: Arbitrary-precision implementations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../API/arbitrary_models.html#fractalshades.models.Perturbation_mandelbrot"><code class="docutils literal notranslate"><span class="pre">Perturbation_mandelbrot</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/arbitrary_models.html#fractalshades.models.Perturbation_mandelbrot.__init__"><code class="docutils literal notranslate"><span class="pre">Perturbation_mandelbrot.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/arbitrary_models.html#fractalshades.models.Perturbation_mandelbrot.calc_std_div"><code class="docutils literal notranslate"><span class="pre">Perturbation_mandelbrot.calc_std_div()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/arbitrary_models.html#fractalshades.models.Perturbation_mandelbrot_N"><code class="docutils literal notranslate"><span class="pre">Perturbation_mandelbrot_N</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/arbitrary_models.html#fractalshades.models.Perturbation_mandelbrot_N.__init__"><code class="docutils literal notranslate"><span class="pre">Perturbation_mandelbrot_N.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/arbitrary_models.html#fractalshades.models.Perturbation_mandelbrot_N.calc_std_div"><code class="docutils literal notranslate"><span class="pre">Perturbation_mandelbrot_N.calc_std_div()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/arbitrary_models.html#fractalshades.models.Perturbation_burning_ship"><code class="docutils literal notranslate"><span class="pre">Perturbation_burning_ship</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/arbitrary_models.html#fractalshades.models.Perturbation_burning_ship.__init__"><code class="docutils literal notranslate"><span class="pre">Perturbation_burning_ship.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/arbitrary_models.html#fractalshades.models.Perturbation_burning_ship.calc_std_div"><code class="docutils literal notranslate"><span class="pre">Perturbation_burning_ship.calc_std_div()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../API/standard_models.html">Fractal models: Standard-precision implementations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../API/standard_models.html#fractalshades.models.Mandelbrot"><code class="docutils literal notranslate"><span class="pre">Mandelbrot</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/standard_models.html#fractalshades.models.Mandelbrot.__init__"><code class="docutils literal notranslate"><span class="pre">Mandelbrot.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/standard_models.html#fractalshades.models.Mandelbrot.calc_std_div"><code class="docutils literal notranslate"><span class="pre">Mandelbrot.calc_std_div()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/standard_models.html#fractalshades.models.Mandelbrot.newton_calc"><code class="docutils literal notranslate"><span class="pre">Mandelbrot.newton_calc()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/standard_models.html#fractalshades.models.Mandelbrot_N"><code class="docutils literal notranslate"><span class="pre">Mandelbrot_N</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/standard_models.html#fractalshades.models.Mandelbrot_N.__init__"><code class="docutils literal notranslate"><span class="pre">Mandelbrot_N.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/standard_models.html#fractalshades.models.Mandelbrot_N.calc_std_div"><code class="docutils literal notranslate"><span class="pre">Mandelbrot_N.calc_std_div()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/standard_models.html#fractalshades.models.Mandelbrot_N.newton_calc"><code class="docutils literal notranslate"><span class="pre">Mandelbrot_N.newton_calc()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/standard_models.html#fractalshades.models.Burning_ship"><code class="docutils literal notranslate"><span class="pre">Burning_ship</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/standard_models.html#fractalshades.models.Burning_ship.__init__"><code class="docutils literal notranslate"><span class="pre">Burning_ship.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/standard_models.html#fractalshades.models.Burning_ship.calc_std_div"><code class="docutils literal notranslate"><span class="pre">Burning_ship.calc_std_div()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/standard_models.html#fractalshades.models.Power_tower"><code class="docutils literal notranslate"><span class="pre">Power_tower</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/standard_models.html#fractalshades.models.Power_tower.__init__"><code class="docutils literal notranslate"><span class="pre">Power_tower.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/standard_models.html#fractalshades.models.Power_tower.newton_calc"><code class="docutils literal notranslate"><span class="pre">Power_tower.newton_calc()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/standard_models.html#fractalshades.models.Collatz"><code class="docutils literal notranslate"><span class="pre">Collatz</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/standard_models.html#fractalshades.models.Collatz.__init__"><code class="docutils literal notranslate"><span class="pre">Collatz.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/standard_models.html#fractalshades.models.Collatz.base_calc"><code class="docutils literal notranslate"><span class="pre">Collatz.base_calc()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../API/postproc.html">Postprocessing fields</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../API/postproc.html#fractalshades.postproc.Postproc_batch"><code class="docutils literal notranslate"><span class="pre">Postproc_batch</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/postproc.html#fractalshades.postproc.Postproc_batch.__init__"><code class="docutils literal notranslate"><span class="pre">Postproc_batch.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/postproc.html#fractalshades.postproc.Postproc_batch.add_postproc"><code class="docutils literal notranslate"><span class="pre">Postproc_batch.add_postproc()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/postproc.html#fractalshades.postproc.Postproc"><code class="docutils literal notranslate"><span class="pre">Postproc</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../API/postproc.html#fractalshades.postproc.Raw_pp"><code class="docutils literal notranslate"><span class="pre">Raw_pp</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/postproc.html#fractalshades.postproc.Raw_pp.__init__"><code class="docutils literal notranslate"><span class="pre">Raw_pp.__init__()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/postproc.html#fractalshades.postproc.Continuous_iter_pp"><code class="docutils literal notranslate"><span class="pre">Continuous_iter_pp</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/postproc.html#fractalshades.postproc.Continuous_iter_pp.__init__"><code class="docutils literal notranslate"><span class="pre">Continuous_iter_pp.__init__()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/postproc.html#fractalshades.postproc.Fieldlines_pp"><code class="docutils literal notranslate"><span class="pre">Fieldlines_pp</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/postproc.html#fractalshades.postproc.Fieldlines_pp.__init__"><code class="docutils literal notranslate"><span class="pre">Fieldlines_pp.__init__()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/postproc.html#fractalshades.postproc.DEM_pp"><code class="docutils literal notranslate"><span class="pre">DEM_pp</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/postproc.html#fractalshades.postproc.DEM_pp.__init__"><code class="docutils literal notranslate"><span class="pre">DEM_pp.__init__()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/postproc.html#fractalshades.postproc.DEM_normal_pp"><code class="docutils literal notranslate"><span class="pre">DEM_normal_pp</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/postproc.html#fractalshades.postproc.DEM_normal_pp.__init__"><code class="docutils literal notranslate"><span class="pre">DEM_normal_pp.__init__()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/postproc.html#fractalshades.postproc.Attr_pp"><code class="docutils literal notranslate"><span class="pre">Attr_pp</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/postproc.html#fractalshades.postproc.Attr_pp.__init__"><code class="docutils literal notranslate"><span class="pre">Attr_pp.__init__()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/postproc.html#fractalshades.postproc.Attr_normal_pp"><code class="docutils literal notranslate"><span class="pre">Attr_normal_pp</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/postproc.html#fractalshades.postproc.Attr_normal_pp.__init__"><code class="docutils literal notranslate"><span class="pre">Attr_normal_pp.__init__()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/postproc.html#fractalshades.postproc.Fractal_array"><code class="docutils literal notranslate"><span class="pre">Fractal_array</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/postproc.html#fractalshades.postproc.Fractal_array.__init__"><code class="docutils literal notranslate"><span class="pre">Fractal_array.__init__()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../API/layers.html">Image layers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../API/layers.html#fractalshades.colors.layers.Virtual_layer"><code class="docutils literal notranslate"><span class="pre">Virtual_layer</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/layers.html#fractalshades.colors.layers.Virtual_layer.__init__"><code class="docutils literal notranslate"><span class="pre">Virtual_layer.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/layers.html#fractalshades.colors.layers.Virtual_layer.set_mask"><code class="docutils literal notranslate"><span class="pre">Virtual_layer.set_mask()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/layers.html#fractalshades.colors.layers.Bool_layer"><code class="docutils literal notranslate"><span class="pre">Bool_layer</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/layers.html#fractalshades.colors.layers.Bool_layer.__init__"><code class="docutils literal notranslate"><span class="pre">Bool_layer.__init__()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/layers.html#fractalshades.colors.layers.Color_layer"><code class="docutils literal notranslate"><span class="pre">Color_layer</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/layers.html#fractalshades.colors.layers.Color_layer.__init__"><code class="docutils literal notranslate"><span class="pre">Color_layer.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/layers.html#fractalshades.colors.layers.Color_layer.overlay"><code class="docutils literal notranslate"><span class="pre">Color_layer.overlay()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/layers.html#fractalshades.colors.layers.Color_layer.set_mask"><code class="docutils literal notranslate"><span class="pre">Color_layer.set_mask()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/layers.html#fractalshades.colors.layers.Color_layer.set_twin_field"><code class="docutils literal notranslate"><span class="pre">Color_layer.set_twin_field()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/layers.html#fractalshades.colors.layers.Color_layer.shade"><code class="docutils literal notranslate"><span class="pre">Color_layer.shade()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/layers.html#fractalshades.colors.layers.Normal_map_layer"><code class="docutils literal notranslate"><span class="pre">Normal_map_layer</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/layers.html#fractalshades.colors.layers.Normal_map_layer.__init__"><code class="docutils literal notranslate"><span class="pre">Normal_map_layer.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/layers.html#fractalshades.colors.layers.Normal_map_layer.set_mask"><code class="docutils literal notranslate"><span class="pre">Normal_map_layer.set_mask()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/layers.html#fractalshades.colors.layers.Grey_layer"><code class="docutils literal notranslate"><span class="pre">Grey_layer</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/layers.html#fractalshades.colors.layers.Grey_layer.__init__"><code class="docutils literal notranslate"><span class="pre">Grey_layer.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/layers.html#fractalshades.colors.layers.Grey_layer.set_mask"><code class="docutils literal notranslate"><span class="pre">Grey_layer.set_mask()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/layers.html#fractalshades.colors.layers.Disp_layer"><code class="docutils literal notranslate"><span class="pre">Disp_layer</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/layers.html#fractalshades.colors.layers.Disp_layer.__init__"><code class="docutils literal notranslate"><span class="pre">Disp_layer.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/layers.html#fractalshades.colors.layers.Disp_layer.set_mask"><code class="docutils literal notranslate"><span class="pre">Disp_layer.set_mask()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/layers.html#fractalshades.colors.layers.Blinn_lighting"><code class="docutils literal notranslate"><span class="pre">Blinn_lighting</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/layers.html#fractalshades.colors.layers.Blinn_lighting.__init__"><code class="docutils literal notranslate"><span class="pre">Blinn_lighting.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/layers.html#fractalshades.colors.layers.Blinn_lighting.add_light_source"><code class="docutils literal notranslate"><span class="pre">Blinn_lighting.add_light_source()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/layers.html#fractalshades.colors.layers.Overlay_mode"><code class="docutils literal notranslate"><span class="pre">Overlay_mode</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/layers.html#fractalshades.colors.layers.Overlay_mode.__init__"><code class="docutils literal notranslate"><span class="pre">Overlay_mode.__init__()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../API/colors.html">Color mapping</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../API/colors.html#fractalshades.colors.Fractal_colormap"><code class="docutils literal notranslate"><span class="pre">Fractal_colormap</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/colors.html#fractalshades.colors.Fractal_colormap.__init__"><code class="docutils literal notranslate"><span class="pre">Fractal_colormap.__init__()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../API/GUI.html">GUI</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../API/GUI.html#fractalshades.gui.guimodel.Fractal_GUI"><code class="docutils literal notranslate"><span class="pre">Fractal_GUI</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/GUI.html#fractalshades.gui.guimodel.Fractal_GUI.__init__"><code class="docutils literal notranslate"><span class="pre">Fractal_GUI.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/GUI.html#fractalshades.gui.guimodel.Fractal_GUI.connect_image"><code class="docutils literal notranslate"><span class="pre">Fractal_GUI.connect_image()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/GUI.html#fractalshades.gui.guimodel.Fractal_GUI.connect_mouse"><code class="docutils literal notranslate"><span class="pre">Fractal_GUI.connect_mouse()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/GUI.html#fractalshades.gui.guimodel.Fractal_GUI.show"><code class="docutils literal notranslate"><span class="pre">Fractal_GUI.show()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/GUI.html#fractalshades.gui.guitemplates.std_zooming"><code class="docutils literal notranslate"><span class="pre">std_zooming</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/GUI.html#fractalshades.gui.guitemplates.std_zooming.__init__"><code class="docutils literal notranslate"><span class="pre">std_zooming.__init__()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../API/logging.html">Logging</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../API/logging.html#fractalshades.log.set_log_handlers"><code class="docutils literal notranslate"><span class="pre">set_log_handlers()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../API/db.html">Databases</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../API/db.html#fractalshades.db.Db"><code class="docutils literal notranslate"><span class="pre">Db</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/db.html#fractalshades.db.Db.__init__"><code class="docutils literal notranslate"><span class="pre">Db.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/db.html#fractalshades.db.Db.plot"><code class="docutils literal notranslate"><span class="pre">Db.plot()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/db.html#fractalshades.db.Db.set_plotter"><code class="docutils literal notranslate"><span class="pre">Db.set_plotter()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/db.html#fractalshades.db.Frame"><code class="docutils literal notranslate"><span class="pre">Frame</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/db.html#fractalshades.db.Frame.__init__"><code class="docutils literal notranslate"><span class="pre">Frame.__init__()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/db.html#fractalshades.db.Exp_db"><code class="docutils literal notranslate"><span class="pre">Exp_db</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/db.html#fractalshades.db.Exp_db.__init__"><code class="docutils literal notranslate"><span class="pre">Exp_db.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/db.html#fractalshades.db.Exp_db.plot"><code class="docutils literal notranslate"><span class="pre">Exp_db.plot()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/db.html#fractalshades.db.Exp_frame"><code class="docutils literal notranslate"><span class="pre">Exp_frame</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/db.html#fractalshades.db.Exp_frame.__init__"><code class="docutils literal notranslate"><span class="pre">Exp_frame.__init__()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../API/movie.html">Movie module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../API/movie.html#fractalshades.movie.Movie"><code class="docutils literal notranslate"><span class="pre">Movie</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/movie.html#fractalshades.movie.Movie.__init__"><code class="docutils literal notranslate"><span class="pre">Movie.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/movie.html#fractalshades.movie.Movie.add_sequence"><code class="docutils literal notranslate"><span class="pre">Movie.add_sequence()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/movie.html#fractalshades.movie.Movie.export_frame"><code class="docutils literal notranslate"><span class="pre">Movie.export_frame()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/movie.html#fractalshades.movie.Movie.make"><code class="docutils literal notranslate"><span class="pre">Movie.make()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/movie.html#fractalshades.movie.Camera_pan"><code class="docutils literal notranslate"><span class="pre">Camera_pan</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/movie.html#fractalshades.movie.Camera_pan.__init__"><code class="docutils literal notranslate"><span class="pre">Camera_pan.__init__()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/movie.html#fractalshades.movie.Camera_zoom"><code class="docutils literal notranslate"><span class="pre">Camera_zoom</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/movie.html#fractalshades.movie.Camera_zoom.__init__"><code class="docutils literal notranslate"><span class="pre">Camera_zoom.__init__()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/movie.html#fractalshades.movie.Custom_sequence"><code class="docutils literal notranslate"><span class="pre">Custom_sequence</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/movie.html#fractalshades.movie.Custom_sequence.__init__"><code class="docutils literal notranslate"><span class="pre">Custom_sequence.__init__()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../making_movies.html">Making movies</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../making_movies.html#example-pan-sequence">Example: pan sequence</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../making_movies.html#example-zoom-sequence">Example: zoom sequence</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../making_movies.html#example-custom-zoom-sequence">Example: “Custom” zoom sequence</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../making_movies.html#example-using-distance-estimation-plots">Example: Using Distance Estimation plots</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../changelog.html">Changelog</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#rev-1-1">Rev 1.1</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../changelog.html#rev-1-1-0">Rev 1.1.0</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../changelog.html#rev-1-1-1">Rev 1.1.1</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#rev-1-0">Rev 1.0</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../changelog.html#rev-1-0-3">Rev 1.0.3</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../changelog.html#rev-1-0-2">Rev 1.0.2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../changelog.html#rev-1-0-1">Rev 1.0.1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../changelog.html#rev-1-0-0">Rev 1.0.0</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#rev-0-5">Rev 0.5</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../changelog.html#rev-0-5-6">Rev 0.5.6</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../changelog.html#rev-0-5-5">Rev 0.5.5</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../changelog.html#rev-0-5-4">Rev 0.5.4</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../changelog.html#rev-0-5-3">Rev 0.5.3</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../changelog.html#rev-0-5-2">Rev 0.5.2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../changelog.html#rev-0-5-0">Rev 0.5.0</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#rev-0-4">Rev 0.4</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../changelog.html#rev-0-4-3">Rev 0.4.3</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../changelog.html#rev-0-4-2">Rev 0.4.2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../changelog.html#rev-0-4-1">Rev 0.4.1</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../acknowledgment.html">Acknowledgment</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Fractalshades</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">fractalshades.perturbation</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">

           <div itemprop="articleBody">
             
  <h1>Source code for fractalshades.perturbation</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="c1">#import typing</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="c1">#import warnings</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">textwrap</span>
<span class="kn">import</span> <span class="nn">copy</span>

<span class="kn">import</span> <span class="nn">mpmath</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numba</span>

<span class="kn">import</span> <span class="nn">fractalshades</span> <span class="k">as</span> <span class="nn">fs</span>
<span class="kn">import</span> <span class="nn">fractalshades.numpy_utils.xrange</span> <span class="k">as</span> <span class="nn">fsx</span>
<span class="kn">import</span> <span class="nn">fractalshades.numpy_utils.numba_xr</span> <span class="k">as</span> <span class="nn">fsxn</span>


<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="PerturbationFractal">
<a class="viewcode-back" href="../../API/core.html#fractalshades.PerturbationFractal">[docs]</a>
<span class="k">class</span> <span class="nc">PerturbationFractal</span><span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">Fractal</span><span class="p">):</span>

<div class="viewcode-block" id="PerturbationFractal.__init__">
<a class="viewcode-back" href="../../API/core.html#fractalshades.PerturbationFractal.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directory</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Base class for escape-time fractals implementing the </span>
<span class="sd">perturbation technique, with an iteration matching:</span>

<span class="sd">.. math::</span>

<span class="sd">    z_0 &amp;= 0 \\\\</span>
<span class="sd">    z_{n+1} &amp;= f ( z_{n} ) + c</span>

<span class="sd">Where :math:`f` has a critical point at 0.</span>
<span class="sd">Derived classes should provide the implementation for the actual function</span>
<span class="sd">:math:`f`.</span>

<span class="sd">Parameters</span>
<span class="sd">----------</span>
<span class="sd">directory : str</span>
<span class="sd">    Path for the working base directory&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">directory</span><span class="p">)</span></div>


<div class="viewcode-block" id="PerturbationFractal.zoom">
<a class="viewcode-back" href="../../API/core.html#fractalshades.PerturbationFractal.zoom">[docs]</a>
    <span class="nd">@fs</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">zoom_options</span>
    <span class="k">def</span> <span class="nf">zoom</span><span class="p">(</span>
             <span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
             <span class="n">precision</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
             <span class="n">x</span><span class="p">:</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">mpf</span><span class="p">,</span>
             <span class="n">y</span><span class="p">:</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">mpf</span><span class="p">,</span>
             <span class="n">dx</span><span class="p">:</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">mpf</span><span class="p">,</span>
             <span class="n">nx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
             <span class="n">xy_ratio</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
             <span class="n">theta_deg</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
             <span class="n">projection</span><span class="p">:</span> <span class="n">fs</span><span class="o">.</span><span class="n">projection</span><span class="o">.</span><span class="n">Projection</span><span class="o">=</span><span class="n">fs</span><span class="o">.</span><span class="n">projection</span><span class="o">.</span><span class="n">Cartesian</span><span class="p">(),</span>
             <span class="n">has_skew</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
             <span class="n">skew_00</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span>
             <span class="n">skew_01</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span>
             <span class="n">skew_10</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span>
             <span class="n">skew_11</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">1.</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define the zoom parameters for the next calculation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        precision : int</span>
<span class="sd">            number of significant base-10 digits to use for full precision</span>
<span class="sd">            calculations.</span>
<span class="sd">        x : str or mpmath.mpf</span>
<span class="sd">            x-coordinate of the central point</span>
<span class="sd">        y : str or mpmath.mpf</span>
<span class="sd">            y-coordinate of the central point</span>
<span class="sd">        dx : str or mpmath.mpf</span>
<span class="sd">            span of the view rectangle along the x-axis</span>
<span class="sd">        nx : int</span>
<span class="sd">            number of pixels of the image along the x-axis</span>
<span class="sd">        xy_ratio: float</span>
<span class="sd">            ratio of dx / dy and nx / ny</span>
<span class="sd">        theta_deg : float</span>
<span class="sd">            Pre-rotation of the calculation domain, in degree</span>
<span class="sd">        projection : `fractalshades.projection.Projection`</span>
<span class="sd">            Kind of projection used (default to</span>
<span class="sd">            `fractalshades.projection.Cartesian`)</span>
<span class="sd">        has_skew : bool</span>
<span class="sd">            If True, unskew the view base on skew coefficients skew_ij</span>
<span class="sd">        skew_ij : float</span>
<span class="sd">            Components of the local skew matrix, with ij = 00, 01, 10, 11</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mpmath</span><span class="o">.</span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="n">precision</span> <span class="c1"># in base 10 digit </span>

        <span class="c1"># In case the user inputs were strings, we override with mpmath scalars</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">mpf</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">mpf</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dx</span> <span class="o">=</span> <span class="n">dx</span> <span class="o">=</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">mpf</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span>

        <span class="c1"># Backward compatibility: also accept projection = &quot;cartesian&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">projection</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">textwrap</span><span class="o">.</span><span class="n">dedent</span><span class="p">(</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;\</span>
<span class="sd">                Use of str for projection is deprecated, and might be</span>
<span class="sd">                removed. Please use `fractalshades.projection.Projection`</span>
<span class="sd">                subclasses instead. Defaulting to</span>
<span class="sd">                `fractalshades.projection.Cartesian()`&quot;&quot;&quot;</span>
            <span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">projection</span> <span class="o">=</span> <span class="n">projection</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">projection</span><span class="o">.</span><span class="n">Cartesian</span><span class="p">()</span>

        <span class="c1"># Stores the skew matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_skew</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">has_skew</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_skew</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">((</span><span class="n">skew_00</span><span class="p">,</span> <span class="n">skew_01</span><span class="p">),</span> <span class="p">(</span><span class="n">skew_10</span><span class="p">,</span> <span class="n">skew_11</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dx_std</span> <span class="o">=</span> <span class="n">dx_std</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dx_xr</span> <span class="o">=</span> <span class="n">dx_xr</span> <span class="o">=</span> <span class="n">fsx</span><span class="o">.</span><span class="n">mpf_to_Xrange</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="c1"># Here we store the linscale as a 1d 1 element array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lin_scale_xr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">dx_xr</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lin_scale_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">dx_std</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lin_mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lin_mat</span><span class="p">()</span>

        <span class="n">projection</span><span class="o">.</span><span class="n">adjust_to_zoom</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proj_impl</span> <span class="o">=</span> <span class="n">projection</span><span class="o">.</span><span class="n">f</span>

        <span class="c1"># check the dps...</span>
        <span class="n">pix</span> <span class="o">=</span> <span class="n">projection</span><span class="o">.</span><span class="n">min_local_scale</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nx</span>
        <span class="c1"># pix = projection.min_local_scale * projection.scale * self.dx / self.nx</span>
        <span class="k">with</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">workdps</span><span class="p">(</span><span class="mi">6</span><span class="p">):</span>
            <span class="c1"># Sets the working dps to 10e-1 x pixel size</span>
            <span class="n">required_dps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="n">mpmath</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">pix</span> <span class="o">/</span> <span class="n">nx</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">required_dps</span> <span class="o">&gt;</span> <span class="n">precision</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Precision is too low for min. pixel size and shall be &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;increased to </span><span class="si">{</span><span class="n">required_dps</span><span class="si">}</span><span class="s2"> (current setting: </span><span class="si">{</span><span class="n">precision</span><span class="si">}</span><span class="s2">).&quot;</span>
                <span class="s2">&quot;This might be a consequence of Exponential mapping or &quot;</span>
                <span class="s2">&quot;other non-cartesian projections.&quot;</span>
            <span class="p">)</span></div>



    <span class="k">def</span> <span class="nf">new_status</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wget</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Return a dictionnary that can hold the current progress status &quot;&quot;&quot;</span>
        <span class="n">base_status</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">new_status</span><span class="p">(</span><span class="n">wget</span><span class="p">)</span>
        <span class="n">status</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;Reference&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;str_val&quot;</span><span class="p">:</span> <span class="s2">&quot;--&quot;</span>
            <span class="p">},</span>
            <span class="s2">&quot;Bilin. approx&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;str_val&quot;</span><span class="p">:</span> <span class="s2">&quot;--&quot;</span>
            <span class="p">},</span>
        <span class="p">}</span>
        <span class="n">status</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">base_status</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">status</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">xr_detect_activated</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Triggers use of special dataype to avoid underflow in double &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span> <span class="o">&lt;</span> <span class="n">fs</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">xrange_zoom_level</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">ref_point_file</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the file path to store or retrieve data arrays associated to a </span>
<span class="sd">        reference orbit</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">directory</span><span class="p">,</span> <span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="s2">&quot;ref_pt.dat&quot;</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">ref_point_kc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a bound for dc in image pixels, used as a criteria for BLA</span>
<span class="sd">        validity</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        kc: full precision, scaling coefficient</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span>

        <span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xy_ratio</span><span class="p">)</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span> <span class="c1"># * self.projection.scale</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lin_mat</span>

        <span class="n">corner_a</span> <span class="o">=</span> <span class="n">mpc_lin_proj_impl_noscale</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">w</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">h</span><span class="p">)</span> <span class="o">*</span> <span class="n">dx</span>
        <span class="n">corner_b</span> <span class="o">=</span> <span class="n">mpc_lin_proj_impl_noscale</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">w</span> <span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">h</span><span class="p">)</span> <span class="o">*</span> <span class="n">dx</span>
        <span class="n">corner_c</span> <span class="o">=</span> <span class="n">mpc_lin_proj_impl_noscale</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">w</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">h</span><span class="p">)</span> <span class="o">*</span> <span class="n">dx</span>
        <span class="n">corner_d</span> <span class="o">=</span> <span class="n">mpc_lin_proj_impl_noscale</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">w</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">h</span><span class="p">)</span> <span class="o">*</span> <span class="n">dx</span>

        <span class="n">c0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span>
        <span class="n">ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FP_params</span><span class="p">[</span><span class="s2">&quot;ref_point&quot;</span><span class="p">]</span>
        <span class="n">shift</span> <span class="o">=</span> <span class="n">ref</span> <span class="o">-</span> <span class="n">c0</span>

        <span class="c1"># Let take the largest distance + some margin</span>
        <span class="n">kc</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">shift</span> <span class="o">-</span> <span class="n">corner_a</span><span class="p">),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">shift</span> <span class="o">-</span> <span class="n">corner_b</span><span class="p">),</span>
                 <span class="nb">abs</span><span class="p">(</span><span class="n">shift</span> <span class="o">-</span> <span class="n">corner_c</span><span class="p">),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">shift</span> <span class="o">-</span> <span class="n">corner_d</span><span class="p">))</span> <span class="o">*</span> <span class="mf">1.1</span>

        <span class="k">return</span> <span class="n">fsx</span><span class="o">.</span><span class="n">mpf_to_Xrange</span><span class="p">(</span><span class="n">kc</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="c1"># 1d for numba</span>


    <span class="k">def</span> <span class="nf">get_std_cpt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c_pix</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Return the c complex value from c_pix - standard precision &quot;&quot;&quot;</span>
        <span class="n">n_pts</span><span class="p">,</span> <span class="o">=</span> <span class="n">c_pix</span><span class="o">.</span><span class="n">shape</span>  <span class="c1"># Z of shape [n_Z, n_pts]</span>
        <span class="c1"># Explicit casting to complex / float</span>
        <span class="n">center</span> <span class="o">=</span> <span class="nb">complex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
        <span class="n">cpt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_pts</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">c_pix</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">fill1d_std_C_from_pix</span><span class="p">(</span>
            <span class="n">c_pix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">proj_impl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lin_mat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lin_scale_std</span><span class="p">,</span>
            <span class="n">center</span><span class="p">,</span> <span class="n">cpt</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">cpt</span>


    <span class="k">def</span> <span class="nf">ref_point_matching</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test if the ref point can be used for this calculation ie </span>
<span class="sd">           - same or more max_iter</span>
<span class="sd">           - not too far</span>
<span class="sd">           - and with a suitable dps</span>
<span class="sd">           - Same fractal __init__ params </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">init_kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_kwargs</span>
        <span class="k">del</span> <span class="n">init_kwargs</span><span class="p">[</span><span class="s2">&quot;directory&quot;</span><span class="p">]</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">ref_point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FP_params</span><span class="p">[</span><span class="s2">&quot;ref_point&quot;</span><span class="p">]</span>
            <span class="n">max_iter_ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FP_params</span><span class="p">[</span><span class="s2">&quot;max_iter&quot;</span><span class="p">]</span>
            <span class="n">init_kwargs_ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FP_params</span><span class="p">[</span><span class="s2">&quot;init_kwargs&quot;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">FileNotFoundError</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;No data file found for ref point&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Parameters &#39;max_iter&#39; borrowed from last &quot;@fsutils.calc_options&quot; call</span>
        <span class="c1"># calc_options = self.calc_options</span>
        <span class="n">max_iter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span> <span class="c1">#calc_options[&quot;max_iter&quot;]</span>

        <span class="n">drift_xr</span> <span class="o">=</span> <span class="n">fsx</span><span class="o">.</span><span class="n">mpc_to_Xrange</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="n">ref_point</span><span class="p">)</span>
        <span class="n">dx_xr</span> <span class="o">=</span> <span class="n">fsx</span><span class="o">.</span><span class="n">mpf_to_Xrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">)</span>
        
        <span class="n">matching_init_kwargs</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">init_kwargs_ref</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">init_kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">!=</span> <span class="n">v</span><span class="p">:</span>
                <span class="n">matching_init_kwargs</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">dic_match</span> <span class="o">=</span> <span class="p">{</span>
           <span class="s2">&quot;dps&quot;</span><span class="p">:</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FP_params</span><span class="p">[</span><span class="s2">&quot;dps&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span>
           <span class="s2">&quot;location&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">drift_xr</span> <span class="o">/</span> <span class="n">dx_xr</span><span class="p">)</span><span class="o">.</span><span class="n">abs2</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">1.e6</span><span class="p">,</span>
           <span class="s2">&quot;max_iter&quot;</span><span class="p">:</span> <span class="n">max_iter_ref</span> <span class="o">&gt;=</span> <span class="n">max_iter</span><span class="p">,</span>
           <span class="s2">&quot;init_kwargs&quot;</span><span class="p">:</span> <span class="n">matching_init_kwargs</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="n">item</span><span class="p">,</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">dic_match</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Updating ref point: </span><span class="si">{</span><span class="n">item</span><span class="si">}</span><span class="s2"> not matching&quot;</span><span class="p">)</span>
                <span class="k">break</span>

        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">match</span> <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">dic_match</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>


    <span class="k">def</span> <span class="nf">save_ref_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">FP_params</span><span class="p">,</span> <span class="n">Zn_path</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write to a data file the following data:</span>
<span class="sd">           - params = main parameters used for the calculation</span>
<span class="sd">           - codes = complex_codes, int_codes, termination_codes</span>
<span class="sd">           - arrays : [Z, U, stop_reason, stop_iter]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_FP_params</span> <span class="o">=</span> <span class="n">FP_params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Zn_path</span> <span class="o">=</span> <span class="n">Zn_path</span>
        <span class="n">save_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_point_file</span><span class="p">()</span>
        <span class="n">fs</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">mkdir_p</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">save_path</span><span class="p">))</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">save_path</span><span class="p">,</span> <span class="s1">&#39;wb+&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">tmpfile</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">textwrap</span><span class="o">.</span><span class="n">dedent</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">                    Full precision path computed, saving to:</span>
<span class="s2">                      </span><span class="si">{</span><span class="n">save_path</span><span class="si">}</span><span class="s2">&quot;&quot;&quot;</span>
            <span class="p">))</span>

            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">FP_params</span><span class="p">,</span> <span class="n">tmpfile</span><span class="p">,</span> <span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">)</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">Zn_path</span><span class="p">,</span> <span class="n">tmpfile</span><span class="p">,</span> <span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">reload_ref_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scan_only</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reload arrays from a data file</span>
<span class="sd">           - params = main parameters used for the calculation</span>
<span class="sd">           - codes = complex_codes, int_codes, termination_codes</span>
<span class="sd">           - arrays : [Z, U, stop_reason, stop_iter]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">save_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_point_file</span><span class="p">()</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">save_path</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">tmpfile</span><span class="p">:</span>
            <span class="n">FP_params</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">tmpfile</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">scan_only</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">FP_params</span>
            <span class="n">Zn_path</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">tmpfile</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">FP_params</span><span class="p">,</span> <span class="n">Zn_path</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">FP_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the FP_params attribute, if not available try to reload it</span>
<span class="sd">        from file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_FP_params&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FP_params</span>
        <span class="n">FP_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reload_ref_point</span><span class="p">(</span><span class="n">scan_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_FP_params</span> <span class="o">=</span> <span class="n">FP_params</span>
        <span class="k">return</span> <span class="n">FP_params</span>
        
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">Zn_path</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the Zn_path attribute, if not available try to reload it</span>
<span class="sd">        from file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_Zn_path&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Zn_path</span>
        <span class="n">FP_params</span><span class="p">,</span> <span class="n">Zn_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reload_ref_point</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Zn_path</span> <span class="o">=</span> <span class="n">Zn_path</span>
        <span class="k">return</span> <span class="n">Zn_path</span>


    <span class="k">def</span> <span class="nf">get_path_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Builds a Zn_path data tuple from FP_params and Zn_path</span>
<span class="sd">        This object will be used in numba jitted functions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">FP_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FP_params</span>
        <span class="n">Zn_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Zn_path</span>

        <span class="n">ref_xr_python</span> <span class="o">=</span> <span class="n">FP_params</span><span class="p">[</span><span class="s2">&quot;xr&quot;</span><span class="p">]</span>
        <span class="n">has_xr</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ref_xr_python</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">ref_order</span> <span class="o">=</span> <span class="n">FP_params</span><span class="p">[</span><span class="s2">&quot;order&quot;</span><span class="p">]</span>
        <span class="n">ref_div_iter</span> <span class="o">=</span> <span class="n">FP_params</span><span class="p">[</span><span class="s2">&quot;div_iter&quot;</span><span class="p">]</span> <span class="c1"># The first invalid iter</span>
        <span class="c1"># ref_div_iter should be ref div iter of the FP, only if it is div.</span>
        <span class="c1"># Otherwise, the max_iter from calc param</span>
        <span class="k">if</span> <span class="n">ref_order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># The reference orbit is a cycle</span>
            <span class="n">ref_div_iter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="n">dx_xr</span> <span class="o">=</span> <span class="n">fsx</span><span class="o">.</span><span class="n">mpf_to_Xrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">float_type</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="c1"># Note: uses ravel to change the shape from (,) - numpy scalar - to</span>
        <span class="c1"># (1,) - numpy array - for numba compatibility</span>
        <span class="n">ref_index_xr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">ref_xr_python</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">holomorphic</span><span class="p">:</span>
            <span class="c1"># Complex distance between image center and ref point </span>
            <span class="n">drift_xr</span> <span class="o">=</span> <span class="n">fsx</span><span class="o">.</span><span class="n">mpc_to_Xrange</span><span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="n">FP_params</span><span class="p">[</span><span class="s2">&quot;ref_point&quot;</span><span class="p">],</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span>
            <span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    
            <span class="c1"># Build 2 arrays to avoid using a dict in numba</span>
            <span class="c1"># /!\ ref_xr at least len 1 to ensure typing as complex</span>
            <span class="n">ref_xr</span> <span class="o">=</span> <span class="n">fsx</span><span class="o">.</span><span class="n">Xrange_array</span><span class="p">([</span><span class="mi">0</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ref_xr_python</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">xr_index</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ref_xr_python</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="n">ref_index_xr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">xr_index</span>
                <span class="n">ref_xr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ref_xr_python</span><span class="p">[</span><span class="n">xr_index</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">Zn_path</span><span class="p">,</span> <span class="n">has_xr</span><span class="p">,</span> <span class="n">ref_index_xr</span><span class="p">,</span> <span class="n">ref_xr</span><span class="p">,</span>
                    <span class="n">ref_div_iter</span><span class="p">,</span> <span class="n">ref_order</span><span class="p">,</span> <span class="n">drift_xr</span><span class="p">,</span> <span class="n">dx_xr</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Complex distance between image center and ref point </span>
            <span class="n">refp_ptx</span> <span class="o">=</span> <span class="p">(</span><span class="n">FP_params</span><span class="p">[</span><span class="s2">&quot;ref_point&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">real</span>
            <span class="n">refp_pty</span> <span class="o">=</span> <span class="p">(</span><span class="n">FP_params</span><span class="p">[</span><span class="s2">&quot;ref_point&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">imag</span>
            <span class="n">driftx_xr</span> <span class="o">=</span> <span class="n">fsx</span><span class="o">.</span><span class="n">mpf_to_Xrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">refp_ptx</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span>
                <span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">drifty_xr</span> <span class="o">=</span> <span class="n">fsx</span><span class="o">.</span><span class="n">mpf_to_Xrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">refp_pty</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span>
                <span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

            <span class="c1"># Build 2 arrays to avoid using a dict in numba</span>
            <span class="c1"># /!\ ref_xr at least len 1 to ensure typing as complex</span>
            <span class="n">refx_xr</span> <span class="o">=</span> <span class="n">fsx</span><span class="o">.</span><span class="n">Xrange_array</span><span class="p">([</span><span class="mf">0.</span><span class="p">]</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ref_xr_python</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">refy_xr</span> <span class="o">=</span> <span class="n">fsx</span><span class="o">.</span><span class="n">Xrange_array</span><span class="p">([</span><span class="mf">0.</span><span class="p">]</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ref_xr_python</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">xr_index</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ref_xr_python</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="n">ref_index_xr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">xr_index</span>
                <span class="n">tmpx</span><span class="p">,</span> <span class="n">tmpy</span> <span class="o">=</span> <span class="n">ref_xr_python</span><span class="p">[</span><span class="n">xr_index</span><span class="p">]</span>
                <span class="n">refx_xr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmpx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">refy_xr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmpy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">Zn_path</span><span class="p">,</span> <span class="n">has_xr</span><span class="p">,</span> <span class="n">ref_index_xr</span><span class="p">,</span> <span class="n">refx_xr</span><span class="p">,</span> <span class="n">refy_xr</span><span class="p">,</span>
                    <span class="n">ref_div_iter</span><span class="p">,</span> <span class="n">ref_order</span><span class="p">,</span> <span class="n">driftx_xr</span><span class="p">,</span> <span class="n">drifty_xr</span><span class="p">,</span>
                    <span class="n">dx_xr</span><span class="p">)</span>


<span class="c1">#==============================================================================</span>
<span class="c1"># Printing - export functions</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">print_FP</span><span class="p">(</span><span class="n">FP_params</span><span class="p">,</span> <span class="n">Zn_path</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Just a pretty-print of the reference path, for debugging purposes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">pp</span> <span class="o">=</span> <span class="s2">&quot;-------------------------------------------------------------&quot;</span>
 
        <span class="n">pp</span> <span class="o">+=</span> <span class="s2">&quot;  Full precision orbit loaded, FP_params:&quot;</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">FP_params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">kv</span><span class="p">,</span> <span class="n">vv</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">pp</span> <span class="o">+=</span>  <span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">, (</span><span class="si">{</span><span class="n">kv</span><span class="si">}</span><span class="s2">) --&gt; </span><span class="si">{</span><span class="n">vv</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">pp</span> <span class="o">+=</span>  <span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> --&gt; </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">pp</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;ref_path, shape: </span><span class="si">{</span><span class="n">Zn_path</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">Zn_path</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">pp</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">Zn_path</span><span class="p">)</span>
        <span class="n">pp</span> <span class="o">+=</span> <span class="s2">&quot;  -------------------------------------------------------------&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">pp</span><span class="p">)</span>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">write_FP</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">out_file</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Export to csv format a complex path, for debugging purposes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">path_real</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">path</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">path_real</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">real</span>
        <span class="n">path_real</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">imag</span>
        <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">out_file</span><span class="p">,</span> <span class="n">path_real</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s2">&quot;,&quot;</span><span class="p">)</span> 

<span class="c1">#==============================================================================</span>
<span class="c1"># Calculation functions</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">numba_cycle_call</span><span class="p">(</span><span class="n">cycle_dep_args</span><span class="p">,</span> <span class="n">cycle_indep_args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Here we customize for perturbation iterations &quot;&quot;&quot;</span>
        <span class="c1"># We still have a case switch on indep parameter &quot;holomorphic&quot;</span>
        <span class="n">holomorphic</span> <span class="o">=</span> <span class="n">cycle_indep_args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">cycle_indep_args</span> <span class="o">=</span> <span class="n">cycle_indep_args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        
        <span class="k">if</span> <span class="n">holomorphic</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">numba_cycles_perturb</span><span class="p">(</span>
                <span class="o">*</span><span class="n">cycle_dep_args</span><span class="p">,</span> <span class="o">*</span><span class="n">cycle_indep_args</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">numba_cycles_perturb_BS</span><span class="p">(</span>
                <span class="o">*</span><span class="n">cycle_dep_args</span><span class="p">,</span> <span class="o">*</span><span class="n">cycle_indep_args</span>
            <span class="p">)</span>


    <span class="k">def</span> <span class="nf">get_cycle_indep_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initialize</span><span class="p">,</span> <span class="n">iterate</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters independant of the cycle</span>
<span class="sd">        This is where the hard work is done</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># ====================================================================</span>
        <span class="c1"># CUSTOM class impl</span>
        <span class="c1"># Initialise the reference path</span>
        <span class="n">holomorphic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">holomorphic</span>
        <span class="n">calc_deriv_c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_dZndc</span> <span class="k">if</span> <span class="n">holomorphic</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_hessian</span>
        <span class="n">calc_dZndz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_dZndz</span> <span class="k">if</span> <span class="n">holomorphic</span> <span class="k">else</span> <span class="kc">False</span>

        <span class="c1"># 1) compute or retrieve the reference orbit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="s2">&quot;Reference&quot;</span><span class="p">,</span> <span class="s2">&quot;running&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_FP_orbit</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">holomorphic</span><span class="p">:</span>
            <span class="p">(</span><span class="n">Zn_path</span><span class="p">,</span> <span class="n">has_xr</span><span class="p">,</span> <span class="n">ref_index_xr</span><span class="p">,</span> <span class="n">ref_xr</span><span class="p">,</span> <span class="n">ref_div_iter</span><span class="p">,</span> <span class="n">ref_order</span><span class="p">,</span>
             <span class="n">drift_xr</span><span class="p">,</span> <span class="n">dx_xr</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_path_data</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="p">(</span><span class="n">Zn_path</span><span class="p">,</span> <span class="n">has_xr</span><span class="p">,</span> <span class="n">ref_index_xr</span><span class="p">,</span> <span class="n">refx_xr</span><span class="p">,</span> <span class="n">refy_xr</span><span class="p">,</span>
             <span class="n">ref_div_iter</span><span class="p">,</span> <span class="n">ref_order</span><span class="p">,</span> <span class="n">driftx_xr</span><span class="p">,</span> <span class="n">drifty_xr</span><span class="p">,</span>
             <span class="n">dx_xr</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_path_data</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">ref_order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ref_order</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">62</span><span class="p">)</span> <span class="c1"># a quite large int64</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="s2">&quot;Reference&quot;</span><span class="p">,</span> <span class="s2">&quot;completed&quot;</span><span class="p">)</span>

        <span class="c1"># 2) compute the orbit derivatives if needed</span>
        <span class="c1"># Note: this is where the &quot;scale&quot; of the derivative is chosen</span>
        <span class="n">scale_deriv_xr</span> <span class="o">=</span> <span class="n">dx_xr</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection</span><span class="o">.</span><span class="n">scale</span> <span class="o">!=</span> <span class="mf">1.</span><span class="p">:</span>
            <span class="c1"># If there is a projection-induced scale, we need to use it here.</span>
            <span class="n">scale_xr</span> <span class="o">=</span> <span class="n">fsx</span><span class="o">.</span><span class="n">mpf_to_Xrange</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">projection</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">float_type</span>
            <span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">scale_deriv_xr</span> <span class="o">=</span> <span class="n">dx_xr</span> <span class="o">*</span> <span class="n">scale_xr</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Derivative ref scale set at: </span><span class="si">{</span><span class="n">dx_xr</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            

        <span class="n">dZndc_path</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="p">(</span><span class="n">dXnda_path</span><span class="p">,</span> <span class="n">dXndb_path</span><span class="p">,</span> <span class="n">dYnda_path</span><span class="p">,</span> <span class="n">dYndb_path</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span> <span class="o">*</span> <span class="mi">4</span>

        <span class="k">if</span> <span class="n">calc_deriv_c</span><span class="p">:</span>
            <span class="n">xr_detect_activated</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xr_detect_activated</span>

            <span class="k">if</span> <span class="n">holomorphic</span><span class="p">:</span>
                <span class="n">dZndc_path</span><span class="p">,</span> <span class="n">dZndc_xr_path</span> <span class="o">=</span> <span class="n">numba_dZndc_path</span><span class="p">(</span>
                    <span class="n">Zn_path</span><span class="p">,</span> <span class="n">has_xr</span><span class="p">,</span> <span class="n">ref_index_xr</span><span class="p">,</span> <span class="n">ref_xr</span><span class="p">,</span>
                    <span class="n">ref_div_iter</span><span class="p">,</span> <span class="n">ref_order</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dfdz</span><span class="p">,</span> <span class="n">scale_deriv_xr</span><span class="p">,</span> <span class="n">xr_detect_activated</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">xr_detect_activated</span><span class="p">:</span>
                    <span class="n">dZndc_path</span> <span class="o">=</span> <span class="n">dZndc_xr_path</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="p">(</span><span class="n">dXnda_path</span><span class="p">,</span> <span class="n">dXndb_path</span><span class="p">,</span> <span class="n">dYnda_path</span><span class="p">,</span> <span class="n">dYndb_path</span><span class="p">,</span>
                 <span class="n">dXnda_xr_path</span><span class="p">,</span> <span class="n">dXndb_xr_path</span><span class="p">,</span> <span class="n">dYnda_xr_path</span><span class="p">,</span> <span class="n">dYndb_xr_path</span>
                <span class="p">)</span> <span class="o">=</span> <span class="n">numba_dZndc_path_BS</span><span class="p">(</span>
                    <span class="n">Zn_path</span><span class="p">,</span> <span class="n">has_xr</span><span class="p">,</span> <span class="n">ref_index_xr</span><span class="p">,</span> <span class="n">refx_xr</span><span class="p">,</span> <span class="n">refy_xr</span><span class="p">,</span>
                    <span class="n">ref_div_iter</span><span class="p">,</span> <span class="n">ref_order</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dfxdx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dfxdy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dfydx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dfydy</span><span class="p">,</span>
                    <span class="n">scale_deriv_xr</span><span class="p">,</span> <span class="n">xr_detect_activated</span> <span class="c1">#, self.reverse_y</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">xr_detect_activated</span><span class="p">:</span>
                    <span class="n">dXnda_path</span> <span class="o">=</span> <span class="n">dXnda_xr_path</span>
                    <span class="n">dXndb_path</span> <span class="o">=</span> <span class="n">dXndb_xr_path</span>
                    <span class="n">dYnda_path</span> <span class="o">=</span> <span class="n">dYnda_xr_path</span>
                    <span class="n">dYndb_path</span> <span class="o">=</span> <span class="n">dYndb_xr_path</span>

        <span class="c1"># 2&#39;) compute the orbit derivatives wrt z if needed</span>
        <span class="c1"># (interior detection - only for holomorphic case)</span>
        <span class="n">dZndz_path</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">calc_dZndz</span><span class="p">:</span>
            <span class="n">xr_detect_activated</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xr_detect_activated</span>

            <span class="n">dZndz_path</span><span class="p">,</span> <span class="n">dZndz_xr_path</span> <span class="o">=</span> <span class="n">numba_dZndz_path</span><span class="p">(</span>
                <span class="n">Zn_path</span><span class="p">,</span> <span class="n">has_xr</span><span class="p">,</span> <span class="n">ref_index_xr</span><span class="p">,</span> <span class="n">ref_xr</span><span class="p">,</span>
                <span class="n">ref_div_iter</span><span class="p">,</span> <span class="n">ref_order</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dfdz</span><span class="p">,</span> <span class="n">xr_detect_activated</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">xr_detect_activated</span><span class="p">:</span>
                <span class="n">dZndz_path</span> <span class="o">=</span> <span class="n">dZndz_xr_path</span>


        <span class="bp">self</span><span class="o">.</span><span class="n">kc</span> <span class="o">=</span> <span class="n">kc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_point_kc</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">kc</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Resolution is too low for this zoom depth. Try to increase&quot;</span>
                <span class="s2">&quot;the reference calculation precicion.&quot;</span>
        <span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Bounding box defined, with kc: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">kc</span><span class="w"> </span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Initialize BLA interpolation</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">BLA_eps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">M_bla</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">r_bla</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">bla_len</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">stages_bla</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="s2">&quot;Bilin. approx&quot;</span><span class="p">,</span> <span class="s2">&quot;N.A.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="s2">&quot;Bilin. approx&quot;</span><span class="p">,</span> <span class="s2">&quot;running&quot;</span><span class="p">)</span>
            <span class="n">eps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">BLA_eps</span>
            <span class="n">M_bla</span><span class="p">,</span> <span class="n">r_bla</span><span class="p">,</span> <span class="n">bla_len</span><span class="p">,</span> <span class="n">stages_bla</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_BLA_tree</span><span class="p">(</span><span class="n">Zn_path</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="s2">&quot;Bilin. approx&quot;</span><span class="p">,</span> <span class="s2">&quot;completed&quot;</span><span class="p">)</span>   

        <span class="n">proj_dzndc_modifier</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">projection</span><span class="p">,</span> <span class="s2">&quot;dzndc_modifier&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">holomorphic</span><span class="p">:</span>
            <span class="n">cycle_indep_args</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">holomorphic</span><span class="p">,</span>
                <span class="n">initialize</span><span class="p">,</span> <span class="n">iterate</span><span class="p">,</span>
                <span class="n">Zn_path</span><span class="p">,</span> <span class="n">dZndc_path</span><span class="p">,</span> <span class="n">dZndz_path</span><span class="p">,</span>
                <span class="n">has_xr</span><span class="p">,</span> <span class="n">ref_index_xr</span><span class="p">,</span> <span class="n">ref_xr</span><span class="p">,</span> <span class="n">ref_div_iter</span><span class="p">,</span> <span class="n">ref_order</span><span class="p">,</span>
                <span class="n">drift_xr</span><span class="p">,</span> <span class="n">dx_xr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">proj_impl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lin_mat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lin_scale_xr</span><span class="p">,</span>
                <span class="n">kc</span><span class="p">,</span> <span class="n">M_bla</span><span class="p">,</span> <span class="n">r_bla</span><span class="p">,</span> <span class="n">bla_len</span><span class="p">,</span> <span class="n">stages_bla</span><span class="p">,</span>
                <span class="n">proj_dzndc_modifier</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_interrupted</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cycle_indep_args</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">holomorphic</span><span class="p">,</span>
                <span class="n">initialize</span><span class="p">,</span> <span class="n">iterate</span><span class="p">,</span>
                <span class="n">Zn_path</span><span class="p">,</span> <span class="n">dXnda_path</span><span class="p">,</span> <span class="n">dXndb_path</span><span class="p">,</span> <span class="n">dYnda_path</span><span class="p">,</span> <span class="n">dYndb_path</span><span class="p">,</span>
                <span class="n">has_xr</span><span class="p">,</span> <span class="n">ref_index_xr</span><span class="p">,</span> <span class="n">refx_xr</span><span class="p">,</span> <span class="n">refy_xr</span><span class="p">,</span> <span class="n">ref_div_iter</span><span class="p">,</span> <span class="n">ref_order</span><span class="p">,</span>
                <span class="n">driftx_xr</span><span class="p">,</span> <span class="n">drifty_xr</span><span class="p">,</span> <span class="n">dx_xr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">proj_impl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lin_mat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lin_scale_xr</span><span class="p">,</span>
                <span class="n">kc</span><span class="p">,</span> <span class="n">M_bla</span><span class="p">,</span> <span class="n">r_bla</span><span class="p">,</span> <span class="n">bla_len</span><span class="p">,</span> <span class="n">stages_bla</span><span class="p">,</span>
                <span class="n">proj_dzndc_modifier</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_interrupted</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">cycle_indep_args</span>


    <span class="k">def</span> <span class="nf">reset_bla_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cycle_indep_args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">        Returns a new cycle_indep_args with modification of:</span>
<span class="sd">            - BLA validaty radius</span>
<span class="sd">            - derivative scaling (dZndc_path)</span>
<span class="sd">        for deep expmap zooms</span>

<span class="sd">        cycle_indep_args : the data to modify in place</span>
<span class="sd">        Note: the fractal projection shall have been modified through</span>
<span class="sd">        its ``set_exp_zoom_step`` method</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># self.kc = self.ref_point_kc()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Bounding box reset with kc: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">kc</span><span class="w"> </span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">initialize</span> <span class="o">=</span> <span class="n">cycle_indep_args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">iterate</span> <span class="o">=</span> <span class="n">cycle_indep_args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cycle_indep_args</span><span class="p">(</span><span class="n">initialize</span><span class="p">,</span> <span class="n">iterate</span><span class="p">)</span>



    <span class="k">def</span> <span class="nf">fingerprint_matching</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calc_name</span><span class="p">,</span> <span class="n">test_fingerprint</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test if the stored parameters match those of new calculation</span>
<span class="sd">        /!\ modified in subclass</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flatten_fp</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">dic_flatten</span><span class="p">(</span><span class="n">test_fingerprint</span><span class="p">)</span>

        <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_data</span><span class="p">[</span><span class="n">calc_name</span><span class="p">][</span><span class="s2">&quot;state&quot;</span><span class="p">]</span>
        <span class="n">expected_fp</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">dic_flatten</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">fingerprint</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;flatten_fp:</span><span class="se">\n</span><span class="s2"> </span><span class="si">{</span><span class="n">flatten_fp</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;expected_fp:</span><span class="se">\n</span><span class="s2"> </span><span class="si">{</span><span class="n">expected_fp</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">precision_key</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;zoom_kwargs@precision&quot;</span>
        <span class="n">SPECIAL</span> <span class="o">=</span> <span class="p">[</span><span class="n">precision_key</span><span class="p">,]</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">expected_fp</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="ow">in</span> <span class="n">SPECIAL</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="n">precision_key</span><span class="p">:</span>
                    <span class="c1"># We allow precision to *decrease* without rerunning</span>
                    <span class="c1"># the whole calc</span>
                    <span class="k">if</span> <span class="n">flatten_fp</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">val</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
                            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">textwrap</span><span class="o">.</span><span class="n">dedent</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">                        Higher precision needed: will trigger a recalculation</span>
<span class="s2">                          </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">flatten_fp</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="si">}</span><span class="s2"> --&gt; </span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s2">&quot;&quot;&quot;</span>
                            <span class="p">))</span>
                        <span class="k">return</span> <span class="kc">False</span>
                    <span class="k">elif</span> <span class="n">flatten_fp</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">val</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
                            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">textwrap</span><span class="o">.</span><span class="n">dedent</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">                        Lower precision requested: no need for recalculation</span>
<span class="s2">                          </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">flatten_fp</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="si">}</span><span class="s2"> --&gt; </span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s2">&quot;&quot;&quot;</span>
                            <span class="p">))</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">flatten_fp</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">!=</span> <span class="n">val</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">textwrap</span><span class="o">.</span><span class="n">dedent</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">                            Parameter mismatch ; will trigger a recalculation</span>
<span class="s2">                              </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">flatten_fp</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="si">}</span><span class="s2"> --&gt; </span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s2">&quot;&quot;&quot;</span>
                        <span class="p">))</span>
                    <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>


    <span class="k">def</span> <span class="nf">get_BLA_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Zn_path</span><span class="p">,</span> <span class="n">eps</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return</span>
<span class="sd">        ------</span>
<span class="sd">        M_bla, r_bla, stages_bla</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kc</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">holomorphic</span><span class="p">:</span>
            <span class="n">dfdz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dfdz</span>
            <span class="k">return</span> <span class="n">numba_make_BLA</span><span class="p">(</span><span class="n">Zn_path</span><span class="p">,</span> <span class="n">dfdz</span><span class="p">,</span> <span class="n">kc</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dfxdx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dfxdx</span>
            <span class="n">dfxdy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dfxdy</span>
            <span class="n">dfydx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dfydx</span>
            <span class="n">dfydy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dfydy</span>
            <span class="k">return</span> <span class="n">numba_make_BLA_BS</span><span class="p">(</span>
                <span class="n">Zn_path</span><span class="p">,</span> <span class="n">dfxdx</span><span class="p">,</span> <span class="n">dfxdy</span><span class="p">,</span> <span class="n">dfydx</span><span class="p">,</span> <span class="n">dfydy</span><span class="p">,</span> <span class="n">kc</span><span class="p">,</span> <span class="n">eps</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_FP_orbit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">newton</span><span class="o">=</span><span class="s2">&quot;cv&quot;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">max_newton</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        # Check if we have a reference point stored, </span>
<span class="sd">          - otherwise computes and stores it in a file</span>

<span class="sd">        newton: [&quot;cv&quot;, &quot;step&quot;, None]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="n">newton</span> <span class="o">==</span> <span class="s2">&quot;step&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;step option not Implemented (yet)&quot;</span><span class="p">)</span>

        <span class="c1"># Early escape if file exists</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_point_matching</span><span class="p">():</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Reference point already stored, skipping calc&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># no newton if zoom level is low. TODO: early escape possible</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span> <span class="o">&gt;</span> <span class="n">fs</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">newton_zoom_level</span><span class="p">:</span>
            <span class="n">c0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">critical_pt</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_critical_orbit</span><span class="p">(</span><span class="n">c0</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">c0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">c0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span>

        <span class="c1"># skip Newton if settings impose it</span>
        <span class="k">if</span> <span class="n">fs</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">no_newton</span> <span class="ow">or</span> <span class="p">(</span><span class="n">newton</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">newton</span> <span class="o">==</span> <span class="s2">&quot;None&quot;</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">textwrap</span><span class="o">.</span><span class="n">dedent</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">                Skipping all Newton calculation according to calc options</span>
<span class="s2">                    fs.settings.no_newton: </span><span class="si">{</span><span class="n">fs</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">no_newton</span><span class="si">}</span>
<span class="s2">                    newton arg: </span><span class="si">{</span><span class="n">newton</span><span class="si">}</span><span class="s2">&quot;&quot;&quot;</span>
            <span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_FP_orbit</span><span class="p">(</span><span class="n">c0</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">return</span>
        
        <span class="c1"># Here we will compute a Newton iteration.</span>
        <span class="c1"># First, try Ball method to guess the order</span>
        <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">k_ball</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="n">order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ball_method</span><span class="p">(</span><span class="n">c0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span> <span class="o">*</span> <span class="n">k_ball</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;Ball method failed - Default to image center&quot;</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">compute_FP_orbit</span><span class="p">(</span><span class="n">c0</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">return</span>

        <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Order must be specified for Newton iteration&quot;</span><span class="p">)</span>

        <span class="c1"># Now launch Newton descent</span>
        <span class="n">max_attempt</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">textwrap</span><span class="o">.</span><span class="n">dedent</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">            &quot;Launch Newton descent with parameters:</span>
<span class="s2">                order: </span><span class="si">{</span><span class="n">order</span><span class="si">}</span><span class="s2">, max newton attempts: </span><span class="si">{</span><span class="n">max_attempt</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;&quot;&quot;</span>
        <span class="p">))</span>

        <span class="n">eps_pixel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">newton_cv</span><span class="p">,</span> <span class="n">nucleus</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_nucleus</span><span class="p">(</span>
                <span class="n">c0</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">eps_pixel</span><span class="p">,</span> <span class="n">max_newton</span><span class="o">=</span><span class="n">max_newton</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
            <span class="n">newton_cv</span><span class="p">,</span> <span class="n">nucleus</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_any_nucleus</span><span class="p">(</span>
                <span class="n">c0</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">eps_pixel</span><span class="p">,</span> <span class="n">max_newton</span><span class="o">=</span><span class="n">max_newton</span>
            <span class="p">)</span>

        <span class="c1"># If Newton did not CV, we try to boost the dps / precision</span>
        <span class="n">attempt</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">newton_cv</span><span class="p">):</span>
            <span class="n">old_dps</span> <span class="o">=</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span>

            <span class="k">while</span> <span class="ow">not</span><span class="p">(</span><span class="n">newton_cv</span><span class="p">)</span> <span class="ow">and</span> <span class="n">attempt</span> <span class="o">&lt;=</span> <span class="n">max_attempt</span><span class="p">:</span>
                <span class="n">attempt</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">mpmath</span><span class="o">.</span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">1.25</span> <span class="o">*</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">textwrap</span><span class="o">.</span><span class="n">dedent</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">                    Newton attempt </span><span class="si">{</span><span class="n">attempt</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2"> failed</span>
<span class="s2">                      Increasing dps for next : </span><span class="si">{</span><span class="n">old_dps</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">mpmath</span><span class="o">.</span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span><span class="si">}</span><span class="s2">&quot;&quot;&quot;</span>
                <span class="p">))</span>
                <span class="n">eps_pixel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">)</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="n">no_div</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">newton_cv</span><span class="p">,</span> <span class="n">nucleus</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_nucleus</span><span class="p">(</span>
                        <span class="n">c0</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">eps_pixel</span><span class="p">,</span> <span class="n">max_newton</span><span class="o">=</span><span class="n">max_newton</span>
                    <span class="p">)</span>
                <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                    <span class="n">no_div</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">newton_cv</span><span class="p">,</span> <span class="n">nucleus</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_any_nucleus</span><span class="p">(</span>
                        <span class="n">c0</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">eps_pixel</span><span class="p">,</span> <span class="n">max_newton</span><span class="o">=</span><span class="n">max_newton</span>
                    <span class="p">)</span>

                <span class="k">if</span> <span class="n">no_div</span> <span class="ow">and</span> <span class="ow">not</span><span class="p">(</span><span class="n">newton_cv</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">attempt</span> <span class="o">==</span> <span class="n">max_attempt</span><span class="p">):</span>
                    <span class="c1"># Last try, we just release constraint on the cycle order</span>
                    <span class="c1"># and consider also divisors.</span>
                    <span class="n">newton_cv</span><span class="p">,</span> <span class="n">nucleus</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_any_nucleus</span><span class="p">(</span>
                        <span class="n">c0</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">eps_pixel</span><span class="p">,</span> <span class="n">max_newton</span><span class="o">=</span><span class="n">max_newton</span>
                    <span class="p">)</span>

        <span class="c1"># Still not CV ? we default to the center of the image</span>
        <span class="k">if</span> <span class="n">newton_cv</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Newton descent converged at attempt </span><span class="si">{</span><span class="n">attempt</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">order</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># We cannot wrap the ref point here...</span>
            <span class="n">nucleus</span> <span class="o">=</span> <span class="n">c0</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Newton descent failed - Default to image center&quot;</span><span class="p">)</span>


        <span class="n">shift</span> <span class="o">=</span> <span class="n">nucleus</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span><span class="p">)</span>
        <span class="n">shift_x</span> <span class="o">=</span> <span class="n">shift</span><span class="o">.</span><span class="n">real</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
        <span class="n">shift_y</span> <span class="o">=</span> <span class="n">shift</span><span class="o">.</span><span class="n">imag</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">textwrap</span><span class="o">.</span><span class="n">dedent</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">            Reference nucleus found at shift from center:</span>
<span class="s2">              (</span><span class="si">{</span><span class="n">shift_x</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">shift_y</span><span class="si">}</span><span class="s2">) in dx units</span>
<span class="s2">              with order </span><span class="si">{</span><span class="n">order</span><span class="si">}</span><span class="s2">&quot;&quot;&quot;</span>
            <span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_FP_orbit</span><span class="p">(</span><span class="n">nucleus</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">compute_critical_orbit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">crit</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Basically nothing to &#39;compute&#39; here, just short-cutting</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Skipping ref pt orbit calc for low res&quot;</span><span class="p">)</span>
        <span class="n">FP_code</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FP_code</span>
        <span class="c1"># Parameters &#39;max_iter&#39; borrowed from last &quot;@fsutils.calc_options&quot; call</span>
        <span class="c1"># max_iter = self.max_iter</span>

        <span class="n">FP_params</span> <span class="o">=</span> <span class="p">{</span>
             <span class="s2">&quot;ref_point&quot;</span><span class="p">:</span> <span class="n">crit</span><span class="p">,</span>
             <span class="s2">&quot;dps&quot;</span><span class="p">:</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span><span class="p">,</span>
             <span class="s2">&quot;order&quot;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
             <span class="s2">&quot;max_iter&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span><span class="p">,</span>
             <span class="s2">&quot;FP_code&quot;</span><span class="p">:</span> <span class="n">FP_code</span>
        <span class="p">}</span>
        <span class="c1"># Given the &quot;single reference&quot; implementation the loop will wrap when</span>
        <span class="c1"># we reach div_iter - this is probably better not to do it too often</span>
        <span class="c1"># Let&#39;s just pick a reasonnable figure</span>
        <span class="n">div_iter</span> <span class="o">=</span> <span class="mi">100</span> <span class="c1"># min(100, self.max_iter)</span>
        <span class="n">FP_params</span><span class="p">[</span><span class="s2">&quot;partials&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">FP_params</span><span class="p">[</span><span class="s2">&quot;xr&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">FP_params</span><span class="p">[</span><span class="s2">&quot;div_iter&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">div_iter</span>

        <span class="c1"># Also, store the *init_kwargs* because if the Fractal is regenerated</span>
        <span class="c1"># from new initial inputs, we shall obvs invalidate the orbit</span>
        <span class="n">init_kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_kwargs</span>
        <span class="k">del</span> <span class="n">init_kwargs</span><span class="p">[</span><span class="s2">&quot;directory&quot;</span><span class="p">]</span>
        <span class="n">FP_params</span><span class="p">[</span><span class="s2">&quot;init_kwargs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">init_kwargs</span>

        <span class="n">Zn_path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">div_iter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
        <span class="n">Zn_path</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">crit</span>
        
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Storing critical orbit </span><span class="si">{</span><span class="n">crit</span><span class="si">}</span><span class="s2">:</span><span class="se">\n</span><span class="s2">  </span><span class="si">{</span><span class="n">Zn_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">save_ref_point</span><span class="p">(</span><span class="n">FP_params</span><span class="p">,</span> <span class="n">Zn_path</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">compute_FP_orbit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref_point</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes full precision orbit, and stores path in normal precision</span>
<span class="sd">        FP_params keys:</span>
<span class="sd">            ref_point : starting point for the FP orbit</span>
<span class="sd">            order : ref cycle order or None</span>
<span class="sd">            max_iter : max iteration possible</span>
<span class="sd">            FP_codes : orbit sored fields</span>
<span class="sd">            div_iter : First invalid iteration (either diverging or not stored)</span>
<span class="sd">            partials : dictionary iteration -&gt; partial value</span>
<span class="sd">            xr : dictionary iteration -&gt; xr_value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Parameter &#39;max_iter&#39; from last &quot;@fsutils.calc_options&quot; call</span>
        <span class="n">max_iter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Computing full precision path with max_iter </span><span class="si">{</span><span class="n">max_iter</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">FP_code</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FP_code</span>
        <span class="n">FP_params</span> <span class="o">=</span> <span class="p">{</span>
             <span class="s2">&quot;ref_point&quot;</span><span class="p">:</span> <span class="n">ref_point</span><span class="p">,</span>
             <span class="s2">&quot;dps&quot;</span><span class="p">:</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span><span class="p">,</span>
             <span class="s2">&quot;order&quot;</span><span class="p">:</span> <span class="n">order</span><span class="p">,</span>
             <span class="s2">&quot;max_iter&quot;</span><span class="p">:</span> <span class="n">max_iter</span><span class="p">,</span>
             <span class="s2">&quot;FP_code&quot;</span><span class="p">:</span> <span class="n">FP_code</span>
        <span class="p">}</span>

        <span class="c1"># If order is defined, we wrap</span>
        <span class="n">ref_orbit_len</span> <span class="o">=</span> <span class="n">max_iter</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ref_orbit_len</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">ref_orbit_len</span><span class="p">)</span> <span class="c1"># at order + 1, we wrap </span>
        <span class="n">FP_params</span><span class="p">[</span><span class="s2">&quot;ref_orbit_len&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ref_orbit_len</span>
        <span class="n">Zn_path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">ref_orbit_len</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Order is known, wraping at </span><span class="si">{</span><span class="n">ref_orbit_len</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">i</span><span class="p">,</span> <span class="n">partial_dict</span><span class="p">,</span> <span class="n">xr_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FP_loop</span><span class="p">(</span><span class="n">Zn_path</span><span class="p">,</span> <span class="n">ref_point</span><span class="p">)</span>
        <span class="n">FP_params</span><span class="p">[</span><span class="s2">&quot;partials&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">partial_dict</span>
        <span class="n">FP_params</span><span class="p">[</span><span class="s2">&quot;xr&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xr_dict</span>
        <span class="n">FP_params</span><span class="p">[</span><span class="s2">&quot;div_iter&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>

        <span class="c1"># Also, store the *init_kwargs* because if the Fractal is regenerated</span>
        <span class="c1"># from new initial inputs, we shall obvs invalidate the orbit</span>
        <span class="n">init_kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_kwargs</span>
        <span class="k">del</span> <span class="n">init_kwargs</span><span class="p">[</span><span class="s2">&quot;directory&quot;</span><span class="p">]</span>
        <span class="n">FP_params</span><span class="p">[</span><span class="s2">&quot;init_kwargs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">init_kwargs</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Storing  orbit for pt: </span><span class="se">\n</span><span class="s2">  </span><span class="si">{</span><span class="n">ref_point</span><span class="si">}</span><span class="se">\n</span><span class="s2">  </span><span class="si">{</span><span class="n">Zn_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_ref_point</span><span class="p">(</span><span class="n">FP_params</span><span class="p">,</span> <span class="n">Zn_path</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">ball_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">px</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">M_divergence</span><span class="o">=</span><span class="mf">1.e5</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use a ball centered on c = x + i y to find the first period (up to </span>
<span class="sd">        maxiter) of nucleus</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">max_iter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span>

        <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ball_method</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">px</span><span class="p">,</span> <span class="n">max_iter</span><span class="p">,</span> <span class="n">M_divergence</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ball_method2</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">px</span><span class="p">,</span> <span class="n">max_iter</span><span class="p">,</span> <span class="n">M_divergence</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">ball_method_order</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">pix</span><span class="p">,</span> <span class="n">dps</span><span class="p">,</span>
                          <span class="n">maxiter</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">100000</span><span class="p">,</span>
                          <span class="n">radius_pixels</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">25</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; x, y : coordinates of the event &quot;&quot;&quot;</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">y</span>
        <span class="n">radius</span> <span class="o">=</span> <span class="n">pix</span> <span class="o">*</span> <span class="n">radius_pixels</span>
        <span class="n">M_divergence</span> <span class="o">=</span> <span class="mf">1.e3</span>
        <span class="n">order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ball_method</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">maxiter</span><span class="p">,</span> <span class="n">M_divergence</span><span class="p">)</span>

        <span class="n">x_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">y_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">radius_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span>
        <span class="n">res_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">ball_order = </span><span class="se">{{</span>
<span class="s2">    &quot;x&quot;: &quot;</span><span class="si">{</span><span class="n">x_str</span><span class="si">}</span><span class="s2">&quot;,</span>
<span class="s2">    &quot;y&quot;: &quot;</span><span class="si">{</span><span class="n">y_str</span><span class="si">}</span><span class="s2">&quot;,</span>
<span class="s2">    &quot;maxiter&quot;: </span><span class="si">{</span><span class="n">maxiter</span><span class="si">}</span><span class="s2">,</span>
<span class="s2">    &quot;radius_pixels&quot;: </span><span class="si">{</span><span class="n">radius_pixels</span><span class="si">}</span><span class="s2">,</span>
<span class="s2">    &quot;radius&quot;: &quot;</span><span class="si">{</span><span class="n">radius_str</span><span class="si">}</span><span class="s2">&quot;,</span>
<span class="s2">    &quot;M_divergence&quot;: </span><span class="si">{</span><span class="n">M_divergence</span><span class="si">}</span><span class="s2">,</span>
<span class="s2">    &quot;order&quot;: </span><span class="si">{</span><span class="n">order</span><span class="si">}</span>
<span class="se">}}</span>
<span class="s2">&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">res_str</span>


    <span class="k">def</span> <span class="nf">_newton_search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">pix</span><span class="p">,</span> <span class="n">dps</span><span class="p">,</span>
                          <span class="n">maxiter</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">100000</span><span class="p">,</span>
                          <span class="n">radius_pixels</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; x, y : coordinates of the event &quot;&quot;&quot;</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">y</span>

        <span class="n">radius</span> <span class="o">=</span> <span class="n">pix</span> <span class="o">*</span> <span class="n">radius_pixels</span>
        <span class="n">radius_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span>
        <span class="n">M_divergence</span> <span class="o">=</span> <span class="mf">1.e3</span>
        <span class="n">order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ball_method</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">maxiter</span><span class="p">,</span> <span class="n">M_divergence</span><span class="p">)</span>

        <span class="n">newton_cv</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">max_attempt</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">attempt</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="ow">not</span><span class="p">(</span><span class="n">newton_cv</span><span class="p">)</span> <span class="ow">and</span> <span class="n">attempt</span> <span class="o">&lt;</span> <span class="n">max_attempt</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">attempt</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">dps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">dps</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Newton, decimal precision (dps) boost to: </span><span class="si">{</span><span class="n">dps</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">workdps</span><span class="p">(</span><span class="n">dps</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">newton_cv</span><span class="p">,</span> <span class="n">c_newton</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_nucleus</span><span class="p">(</span>
                        <span class="n">c</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">pix</span><span class="p">,</span> <span class="n">max_newton</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">eps_cv</span><span class="o">=</span><span class="kc">None</span>
                    <span class="p">)</span>
                <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                    <span class="n">newton_cv</span><span class="p">,</span> <span class="n">c_newton</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_any_nucleus</span><span class="p">(</span>
                        <span class="n">c</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">pix</span><span class="p">,</span> <span class="n">max_newton</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">eps_cv</span><span class="o">=</span><span class="kc">None</span>
                    <span class="p">)</span>
                <span class="k">if</span> <span class="n">newton_cv</span><span class="p">:</span>
                    <span class="n">xn_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">c_newton</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>
                    <span class="n">yn_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">c_newton</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">newton_cv</span><span class="p">:</span>
            <span class="n">size_estimates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nucleus_size_estimate</span><span class="p">(</span>
                <span class="n">c_newton</span><span class="p">,</span> <span class="n">order</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">size_estimates</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">xn_str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="n">yn_str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="n">x_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">y_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">x_str</span><span class="p">,</span> <span class="n">y_str</span><span class="p">,</span> <span class="n">maxiter</span><span class="p">,</span> <span class="n">radius_pixels</span><span class="p">,</span> <span class="n">radius_str</span><span class="p">,</span> <span class="n">dps</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span>
            <span class="n">xn_str</span><span class="p">,</span> <span class="n">yn_str</span><span class="p">,</span> <span class="n">size_estimates</span>
        <span class="p">)</span>


    <span class="k">def</span> <span class="nf">newton_search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">pix</span><span class="p">,</span> <span class="n">dps</span><span class="p">,</span> <span class="n">maxiter</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">100000</span><span class="p">,</span>
                      <span class="n">radius_pixels</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; x, y : coordinates of the event &quot;&quot;&quot;</span>
        <span class="p">(</span>
            <span class="n">x_str</span><span class="p">,</span> <span class="n">y_str</span><span class="p">,</span> <span class="n">maxiter</span><span class="p">,</span> <span class="n">radius_pixels</span><span class="p">,</span> <span class="n">radius_str</span><span class="p">,</span> <span class="n">dps</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span>
            <span class="n">xn_str</span><span class="p">,</span> <span class="n">yn_str</span><span class="p">,</span> <span class="n">size_estimates</span>
        <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_newton_search</span><span class="p">(</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">pix</span><span class="p">,</span> <span class="n">dps</span><span class="p">,</span> <span class="n">maxiter</span><span class="p">,</span> <span class="n">radius_pixels</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">size_estimates</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="p">(</span><span class="n">nucleus_size</span><span class="p">,</span> <span class="n">julia_size</span><span class="p">)</span> <span class="o">=</span> <span class="n">size_estimates</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nucleus_size</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">julia_size</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">res_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">newton_search = </span><span class="se">{{</span>
<span class="s2">    &quot;x_start&quot;: &quot;</span><span class="si">{</span><span class="n">x_str</span><span class="si">}</span><span class="s2">&quot;,</span>
<span class="s2">    &quot;y_start&quot;: &quot;</span><span class="si">{</span><span class="n">y_str</span><span class="si">}</span><span class="s2">&quot;,</span>
<span class="s2">    &quot;maxiter&quot;: </span><span class="si">{</span><span class="n">maxiter</span><span class="si">}</span><span class="s2">,</span>
<span class="s2">    &quot;radius_pixels&quot;: </span><span class="si">{</span><span class="n">radius_pixels</span><span class="si">}</span><span class="s2">,</span>
<span class="s2">    &quot;radius&quot;: &quot;</span><span class="si">{</span><span class="n">radius_str</span><span class="si">}</span><span class="s2">&quot;,</span>
<span class="s2">    &quot;calculation dps&quot;: </span><span class="si">{</span><span class="n">dps</span><span class="si">}</span>
<span class="s2">    &quot;order&quot;: </span><span class="si">{</span><span class="n">order</span><span class="si">}</span>
<span class="s2">    &quot;x_nucleus&quot;: &quot;</span><span class="si">{</span><span class="n">xn_str</span><span class="si">}</span><span class="s2">&quot;,</span>
<span class="s2">    &quot;y_nucleus&quot;: &quot;</span><span class="si">{</span><span class="n">yn_str</span><span class="si">}</span><span class="s2">&quot;,</span>
<span class="s2">    &quot;nucleus_size&quot;: &quot;</span><span class="si">{</span><span class="n">nucleus_size</span><span class="si">}</span><span class="s2">&quot;,</span>
<span class="s2">    &quot;julia_size&quot;: &quot;</span><span class="si">{</span><span class="n">julia_size</span><span class="si">}</span><span class="s2">&quot;,</span>
<span class="se">}}</span>
<span class="s2">&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">res_str</span></div>


<span class="c1">#==============================================================================</span>
<span class="c1"># Numba JIT functions</span>
<span class="c1">#==============================================================================</span>
<span class="n">Xr_template</span> <span class="o">=</span> <span class="n">fsx</span><span class="o">.</span><span class="n">Xrange_array</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
<span class="n">Xr_float_template</span> <span class="o">=</span> <span class="n">fsx</span><span class="o">.</span><span class="n">Xrange_array</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="n">USER_INTERRUPTED</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">STG_COMPRESSED</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">BLA_compression</span>
<span class="n">STG_SKIP_MASK</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">STG_COMPRESSED</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

<span class="nd">@numba</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">error_model</span><span class="o">=</span><span class="s2">&quot;numpy&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">numba_cycles_perturb</span><span class="p">(</span>
    <span class="n">c_pix</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">stop_reason</span><span class="p">,</span> <span class="n">stop_iter</span><span class="p">,</span>
    <span class="n">initialize</span><span class="p">,</span> <span class="n">iterate</span><span class="p">,</span>
    <span class="n">Zn_path</span><span class="p">,</span> <span class="n">dZndc_path</span><span class="p">,</span> <span class="n">dZndz_path</span><span class="p">,</span>
    <span class="n">has_xr</span><span class="p">,</span> <span class="n">ref_index_xr</span><span class="p">,</span> <span class="n">ref_xr</span><span class="p">,</span> <span class="n">ref_div_iter</span><span class="p">,</span> <span class="n">ref_order</span><span class="p">,</span>
    <span class="n">drift_xr</span><span class="p">,</span> <span class="n">dx_xr</span><span class="p">,</span> <span class="n">proj_impl</span><span class="p">,</span> <span class="n">lin_mat</span><span class="p">,</span> <span class="n">lin_scale_xr</span><span class="p">,</span>
    <span class="n">kc</span><span class="p">,</span> <span class="n">M_bla</span><span class="p">,</span> <span class="n">r_bla</span><span class="p">,</span> <span class="n">bla_len</span><span class="p">,</span> <span class="n">stages_bla</span><span class="p">,</span>
    <span class="n">proj_dzndc_modifier</span><span class="p">,</span>
    <span class="n">_interrupted</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Run the perturbation cycles</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">    Z, U, c, stop_reason, stop_iter</span>
<span class="sd">        result arrays</span>
<span class="sd">    iterate :</span>
<span class="sd">        numba jitted function</span>
<span class="sd">    Ref_path:</span>
<span class="sd">        Ref_path numba object</span>
<span class="sd">    n_iter:</span>
<span class="sd">        current iteration</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">nz</span><span class="p">,</span> <span class="n">npts</span> <span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">Z_xr</span> <span class="o">=</span> <span class="n">Xr_template</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">nz</span><span class="p">)</span>
    <span class="n">Z_xr_trigger</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">nz</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">ipt</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npts</span><span class="p">):</span>

        <span class="n">refpath_ptr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">out_is_xr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numba</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
        <span class="n">out_xr</span> <span class="o">=</span> <span class="n">Xr_template</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">Zpt</span> <span class="o">=</span> <span class="n">Z</span><span class="p">[:,</span> <span class="n">ipt</span><span class="p">]</span>
        <span class="n">Upt</span> <span class="o">=</span> <span class="n">U</span><span class="p">[:,</span> <span class="n">ipt</span><span class="p">]</span>
        <span class="n">cpt</span><span class="p">,</span> <span class="n">c_xr</span> <span class="o">=</span> <span class="n">ref_path_c_from_pix</span><span class="p">(</span>
            <span class="n">c_pix</span><span class="p">[</span><span class="n">ipt</span><span class="p">],</span> <span class="n">proj_impl</span><span class="p">,</span> <span class="n">lin_mat</span><span class="p">,</span> <span class="n">lin_scale_xr</span><span class="p">,</span> <span class="n">drift_xr</span>
        <span class="p">)</span>
        <span class="n">stop_pt</span> <span class="o">=</span> <span class="n">stop_reason</span><span class="p">[:,</span> <span class="n">ipt</span><span class="p">]</span>

        <span class="n">initialize</span><span class="p">(</span><span class="n">c_xr</span><span class="p">,</span> <span class="n">Zpt</span><span class="p">,</span> <span class="n">Z_xr</span><span class="p">,</span> <span class="n">Z_xr_trigger</span><span class="p">,</span> <span class="n">Upt</span><span class="p">,</span> <span class="n">kc</span><span class="p">,</span> <span class="n">dx_xr</span><span class="p">)</span>

        <span class="n">n_iter</span> <span class="o">=</span> <span class="n">iterate</span><span class="p">(</span>
            <span class="n">cpt</span><span class="p">,</span> <span class="n">c_xr</span><span class="p">,</span> <span class="n">Zpt</span><span class="p">,</span> <span class="n">Z_xr</span><span class="p">,</span> <span class="n">Z_xr_trigger</span><span class="p">,</span> <span class="n">Upt</span><span class="p">,</span> <span class="n">stop_pt</span><span class="p">,</span> <span class="c1"># n_iter_init,</span>
            <span class="n">Zn_path</span><span class="p">,</span> <span class="n">dZndc_path</span><span class="p">,</span> <span class="n">dZndz_path</span><span class="p">,</span> <span class="n">has_xr</span><span class="p">,</span> <span class="n">ref_index_xr</span><span class="p">,</span> <span class="n">ref_xr</span><span class="p">,</span> <span class="n">ref_div_iter</span><span class="p">,</span> <span class="n">ref_order</span><span class="p">,</span>
            <span class="n">refpath_ptr</span><span class="p">,</span> <span class="n">out_is_xr</span><span class="p">,</span> <span class="n">out_xr</span><span class="p">,</span> <span class="n">M_bla</span><span class="p">,</span> <span class="n">r_bla</span><span class="p">,</span> <span class="n">bla_len</span><span class="p">,</span> <span class="n">stages_bla</span><span class="p">,</span>
            <span class="n">proj_dzndc_modifier</span><span class="p">,</span> <span class="n">c_pix</span><span class="p">[</span><span class="n">ipt</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">stop_iter</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">ipt</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_iter</span>
        <span class="n">stop_reason</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">ipt</span><span class="p">]</span> <span class="o">=</span> <span class="n">stop_pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">_interrupted</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">USER_INTERRUPTED</span>

    <span class="k">return</span> <span class="mi">0</span>


<span class="k">def</span> <span class="nf">numba_initialize</span><span class="p">(</span><span class="n">zn</span><span class="p">,</span> <span class="n">dzndc</span><span class="p">,</span> <span class="n">dzndz</span><span class="p">):</span>
    <span class="nd">@numba</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">error_model</span><span class="o">=</span><span class="s2">&quot;numpy&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">numba_init_impl</span><span class="p">(</span><span class="n">c_xr</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">Z_xr</span><span class="p">,</span> <span class="n">Z_xr_trigger</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">kc</span><span class="p">,</span> <span class="n">dx_xr</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize &#39;in place&#39;  :</span>
<span class="sd">            Z[zn], Z[dzndz], Z[dzndc]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Z_xr</span><span class="p">[</span><span class="n">zn</span><span class="p">]</span> <span class="o">=</span> <span class="n">fsxn</span><span class="o">.</span><span class="n">to_Xrange_scalar</span><span class="p">(</span><span class="n">Z</span><span class="p">[</span><span class="n">zn</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">dzndc</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">Z_xr</span><span class="p">[</span><span class="n">dzndc</span><span class="p">]</span> <span class="o">=</span> <span class="n">fsxn</span><span class="o">.</span><span class="n">to_Xrange_scalar</span><span class="p">(</span><span class="n">Z</span><span class="p">[</span><span class="n">dzndc</span><span class="p">])</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">dzndz</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">Z</span><span class="p">[</span><span class="n">dzndz</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="k">return</span> <span class="n">numba_init_impl</span>


<span class="c1"># Defines iterate via a function factory - jitted implementation</span>
<span class="k">def</span> <span class="nf">numba_iterate</span><span class="p">(</span>
        <span class="n">max_iter</span><span class="p">,</span> <span class="n">M_divergence_sq</span><span class="p">,</span> <span class="n">epsilon_stationnary_sq</span><span class="p">,</span>
        <span class="n">reason_max_iter</span><span class="p">,</span> <span class="n">reason_M_divergence</span><span class="p">,</span> <span class="n">reason_stationnary</span><span class="p">,</span>
        <span class="n">xr_detect_activated</span><span class="p">,</span> <span class="n">BLA_activated</span><span class="p">,</span>
        <span class="n">zn</span><span class="p">,</span> <span class="n">dzndc</span><span class="p">,</span> <span class="n">dzndz</span><span class="p">,</span>
        <span class="n">p_iter_zn</span><span class="p">,</span> <span class="n">p_iter_dzndz</span><span class="p">,</span> <span class="n">p_iter_dzndc</span><span class="p">,</span>
        <span class="n">calc_dzndc</span><span class="p">,</span> <span class="n">calc_dzndz</span><span class="p">,</span>
        <span class="n">calc_orbit</span><span class="p">,</span> <span class="n">i_znorbit</span><span class="p">,</span> <span class="n">backshift</span><span class="p">,</span> <span class="n">zn_iterate</span> <span class="c1"># Added args</span>
<span class="p">):</span>

    <span class="nd">@numba</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">error_model</span><span class="o">=</span><span class="s2">&quot;numpy&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">numba_impl</span><span class="p">(</span>
        <span class="n">c</span><span class="p">,</span> <span class="n">c_xr</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">Z_xr</span><span class="p">,</span> <span class="n">Z_xr_trigger</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span>
        <span class="n">Zn_path</span><span class="p">,</span> <span class="n">dZndc_path</span><span class="p">,</span> <span class="n">dZndz_path</span><span class="p">,</span> <span class="n">has_xr</span><span class="p">,</span> <span class="n">ref_index_xr</span><span class="p">,</span> <span class="n">ref_xr</span><span class="p">,</span> <span class="n">ref_div_iter</span><span class="p">,</span> <span class="n">ref_order</span><span class="p">,</span>
        <span class="n">refpath_ptr</span><span class="p">,</span> <span class="n">out_is_xr</span><span class="p">,</span> <span class="n">out_xr</span><span class="p">,</span> <span class="n">M_bla</span><span class="p">,</span> <span class="n">r_bla</span><span class="p">,</span> <span class="n">bla_len</span><span class="p">,</span> <span class="n">stages_bla</span><span class="p">,</span>
        <span class="n">proj_dzndc_modifier</span><span class="p">,</span> <span class="n">c_pix</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        c, c_xr: c and it &quot;Xrange&quot; counterparts</span>
<span class="sd">        Z, Z_xr: idem for result vector Z</span>
<span class="sd">        Z_xr_trigger : bolean, activated when Z_xr need to be used</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">record_zero</span> <span class="o">=</span> <span class="n">Xr_template</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="n">w_iter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">n_iter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">w_iter</span> <span class="o">&gt;=</span> <span class="n">ref_order</span><span class="p">:</span>
            <span class="n">w_iter</span> <span class="o">=</span> <span class="n">w_iter</span> <span class="o">%</span> <span class="n">ref_order</span>

        <span class="k">if</span> <span class="n">calc_orbit</span><span class="p">:</span>
            <span class="n">div_shift</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">orbit_zn1</span> <span class="o">=</span> <span class="n">Z</span><span class="p">[</span><span class="n">zn</span><span class="p">]</span>
            <span class="n">orbit_zn2</span> <span class="o">=</span> <span class="n">Z</span><span class="p">[</span><span class="n">zn</span><span class="p">]</span>
            <span class="n">orbit_i1</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">orbit_i2</span> <span class="o">=</span> <span class="mi">0</span>
            
        <span class="k">if</span> <span class="n">calc_dzndz</span><span class="p">:</span>
            <span class="n">nullify_dZndz</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">w_wraped</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dZndz_path</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="c1"># We know that :</span>
        <span class="c1"># ref_orbit_len = max_iter + 1 &gt;= ref_div_iter</span>
        <span class="c1"># if order is not None:</span>
        <span class="c1">#    ref_orbit_len = min(order, ref_orbit_len)</span>
        <span class="n">ref_orbit_len</span> <span class="o">=</span> <span class="n">Zn_path</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">first_invalid_index</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">ref_orbit_len</span><span class="p">,</span> <span class="n">ref_div_iter</span><span class="p">,</span> <span class="n">ref_order</span><span class="p">)</span>
        <span class="n">M_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>

        <span class="c1"># Index to keep track if we use the wraped index of dzndc</span>
        <span class="n">bool_dyn_rebase</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1">#==========================================================</span>
            <span class="c1"># Try a BLA_step</span>
            <span class="k">if</span> <span class="n">BLA_activated</span> <span class="ow">and</span> <span class="p">(</span><span class="n">w_iter</span> <span class="o">&amp;</span> <span class="n">STG_SKIP_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1">#       [    A    0     0]</span>
                <span class="c1">#  M =  [    0    A     B] </span>
                <span class="c1">#       [    0    0     1]</span>
                <span class="c1">#</span>
                <span class="c1">#       [dzndc]</span>
                <span class="c1">#  Zn = [   zn]</span>
                <span class="c1">#       [    c]</span>
                <span class="c1">#</span>
                <span class="c1">#  Z_(n+1) = M * Zn</span>
                <span class="c1">#</span>
                <span class="n">step</span> <span class="o">=</span> <span class="n">ref_BLA_get</span><span class="p">(</span>
                    <span class="n">M_bla</span><span class="p">,</span> <span class="n">r_bla</span><span class="p">,</span> <span class="n">bla_len</span><span class="p">,</span> <span class="n">stages_bla</span><span class="p">,</span> <span class="n">Z</span><span class="p">[</span><span class="n">zn</span><span class="p">],</span> <span class="n">w_iter</span><span class="p">,</span>
                    <span class="n">first_invalid_index</span><span class="p">,</span> <span class="n">M_out</span><span class="p">,</span> <span class="kc">True</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">step</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">n_iter</span> <span class="o">+=</span> <span class="n">step</span>
                    <span class="n">w_iter</span> <span class="o">=</span> <span class="p">(</span><span class="n">w_iter</span> <span class="o">+</span> <span class="n">step</span><span class="p">)</span> <span class="o">%</span> <span class="n">ref_order</span>
                    <span class="k">if</span> <span class="n">xr_detect_activated</span><span class="p">:</span>
                        <span class="n">Z_xr</span><span class="p">[</span><span class="n">zn</span><span class="p">]</span> <span class="o">=</span> <span class="n">M_out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">Z_xr</span><span class="p">[</span><span class="n">zn</span><span class="p">]</span> <span class="o">+</span> <span class="n">M_out</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">c_xr</span>
                        <span class="c1"># /!\ keep this, needed for next BLA step</span>
                        <span class="n">Z</span><span class="p">[</span><span class="n">zn</span><span class="p">]</span> <span class="o">=</span> <span class="n">fsxn</span><span class="o">.</span><span class="n">to_standard</span><span class="p">(</span><span class="n">Z_xr</span><span class="p">[</span><span class="n">zn</span><span class="p">])</span>
                        <span class="k">if</span> <span class="n">calc_dzndc</span><span class="p">:</span>
                            <span class="n">Z_xr</span><span class="p">[</span><span class="n">dzndc</span><span class="p">]</span> <span class="o">=</span> <span class="n">M_out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">Z_xr</span><span class="p">[</span><span class="n">dzndc</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">calc_dzndz</span><span class="p">:</span>
                            <span class="n">Z_xr</span><span class="p">[</span><span class="n">dzndz</span><span class="p">]</span> <span class="o">=</span> <span class="n">M_out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">Z_xr</span><span class="p">[</span><span class="n">dzndz</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># just the usual BLA step</span>
                        <span class="n">Z</span><span class="p">[</span><span class="n">zn</span><span class="p">]</span> <span class="o">=</span> <span class="n">M_out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">Z</span><span class="p">[</span><span class="n">zn</span><span class="p">]</span> <span class="o">+</span> <span class="n">M_out</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">c</span>
                        <span class="k">if</span> <span class="n">calc_dzndc</span><span class="p">:</span>
                            <span class="n">Z</span><span class="p">[</span><span class="n">dzndc</span><span class="p">]</span> <span class="o">=</span> <span class="n">M_out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">Z</span><span class="p">[</span><span class="n">dzndc</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">calc_dzndz</span><span class="p">:</span>
                            <span class="n">Z</span><span class="p">[</span><span class="n">dzndz</span><span class="p">]</span> <span class="o">=</span> <span class="n">M_out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">Z</span><span class="p">[</span><span class="n">dzndz</span><span class="p">]</span>
                    <span class="k">continue</span>

            <span class="c1">#==================================================================</span>
            <span class="c1"># BLA failed, launching a full perturbation iteration</span>
            <span class="n">n_iter</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># the indice we are going to compute now</span>
            <span class="c1"># Load reference point value @ w_iter</span>
            <span class="c1"># refpath_ptr = [prev_idx, curr_xr]</span>
            <span class="k">if</span> <span class="n">xr_detect_activated</span><span class="p">:</span>
                <span class="n">ref_zn</span> <span class="o">=</span> <span class="n">ref_path_get</span><span class="p">(</span>
                    <span class="n">Zn_path</span><span class="p">,</span> <span class="n">w_iter</span><span class="p">,</span>
                    <span class="n">has_xr</span><span class="p">,</span> <span class="n">ref_index_xr</span><span class="p">,</span> <span class="n">ref_xr</span><span class="p">,</span> <span class="n">refpath_ptr</span><span class="p">,</span>
                    <span class="n">out_is_xr</span><span class="p">,</span> <span class="n">out_xr</span><span class="p">,</span> <span class="mi">0</span>
                <span class="p">)</span>
                <span class="n">ref_zn_xr</span> <span class="o">=</span> <span class="n">ensure_xr</span><span class="p">(</span><span class="n">ref_zn</span><span class="p">,</span> <span class="n">out_xr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">out_is_xr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ref_zn</span> <span class="o">=</span> <span class="n">Zn_path</span><span class="p">[</span><span class="n">w_iter</span><span class="p">]</span>

            <span class="c1">#==================================================================</span>
            <span class="c1"># Pertubation iter block</span>
            <span class="c1">#------------------------------------------------------------------</span>
            <span class="c1"># dzndc subblock</span>
            <span class="k">if</span> <span class="n">calc_dzndc</span><span class="p">:</span>
                <span class="n">ref_dzndc</span> <span class="o">=</span> <span class="n">dZndc_path</span><span class="p">[</span><span class="n">w_iter</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">bool_dyn_rebase</span><span class="p">:</span> <span class="c1"># Avoid wraped value at 0</span>
                    <span class="k">if</span> <span class="n">xr_detect_activated</span><span class="p">:</span>
                        <span class="n">ref_dzndc</span> <span class="o">=</span> <span class="n">record_zero</span> <span class="c1"># Record type</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">ref_dzndc</span> <span class="o">=</span> <span class="mf">0.</span>
                <span class="k">if</span> <span class="n">xr_detect_activated</span><span class="p">:</span>
                    <span class="n">p_iter_dzndc</span><span class="p">(</span><span class="n">Z_xr</span><span class="p">,</span> <span class="n">ref_zn_xr</span><span class="p">,</span> <span class="n">ref_dzndc</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">p_iter_dzndc</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">ref_zn</span><span class="p">,</span> <span class="n">ref_dzndc</span><span class="p">)</span>

            <span class="c1">#------------------------------------------------------------------</span>
            <span class="c1"># Interior detection</span>
            <span class="k">if</span> <span class="n">calc_dzndz</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nullify_dZndz</span><span class="p">:</span>
                    <span class="n">ref_dzndz</span> <span class="o">=</span> <span class="n">dZndz_path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># This may be Xrange</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Note: no need of special case for n_iter == order here</span>
                    <span class="c1"># It is managed before during glitch correction step</span>
                    <span class="n">ref_dzndz</span> <span class="o">=</span> <span class="n">dZndz_path</span><span class="p">[</span><span class="n">w_iter</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">xr_detect_activated</span><span class="p">:</span>
                    <span class="n">p_iter_dzndz</span><span class="p">(</span><span class="n">Z_xr</span><span class="p">,</span> <span class="n">ref_zn_xr</span><span class="p">,</span> <span class="n">ref_dzndz</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">p_iter_dzndz</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">ref_zn</span><span class="p">,</span> <span class="n">ref_dzndz</span><span class="p">)</span>

            <span class="c1">#------------------------------------------------------------------</span>
            <span class="c1"># zn subblok</span>
            <span class="k">if</span> <span class="n">xr_detect_activated</span><span class="p">:</span>
                <span class="n">p_iter_zn</span><span class="p">(</span><span class="n">Z_xr</span><span class="p">,</span> <span class="n">ref_zn_xr</span><span class="p">,</span> <span class="n">c_xr</span><span class="p">)</span><span class="c1"># in place mod</span>
                <span class="c1"># std is used for div condition </span>
                <span class="n">Z</span><span class="p">[</span><span class="n">zn</span><span class="p">]</span> <span class="o">=</span> <span class="n">fsxn</span><span class="o">.</span><span class="n">to_standard</span><span class="p">(</span><span class="n">Z_xr</span><span class="p">[</span><span class="n">zn</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">p_iter_zn</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">ref_zn</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>

            <span class="c1"># Increment w_iter just before the stopping conditions</span>
            <span class="n">w_iter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">w_iter</span> <span class="o">&gt;=</span> <span class="n">ref_order</span><span class="p">:</span>
                <span class="n">w_iter</span> <span class="o">=</span> <span class="n">w_iter</span> <span class="o">%</span> <span class="n">ref_order</span>

            <span class="c1">#==================================================================</span>
            <span class="c1"># Stopping condition: maximum iter reached</span>
            <span class="k">if</span> <span class="n">n_iter</span> <span class="o">&gt;=</span> <span class="n">max_iter</span><span class="p">:</span>
                <span class="n">stop</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">reason_max_iter</span>
                <span class="k">break</span>

            <span class="c1">#==================================================================</span>
            <span class="c1"># Stopping condition: Interior points detection (dzndz)</span>
            <span class="k">if</span> <span class="n">calc_dzndz</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nullify_dZndz</span><span class="p">:</span>
                    <span class="n">ref_dzndz_next</span> <span class="o">=</span> <span class="n">dZndz_path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ref_dzndz_next</span> <span class="o">=</span> <span class="n">dZndz_path</span><span class="p">[</span><span class="n">w_iter</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">n_iter</span> <span class="o">==</span> <span class="n">ref_order</span><span class="p">:</span>
                        <span class="n">ref_dzndz_next</span> <span class="o">=</span> <span class="n">dZndz_path</span><span class="p">[</span><span class="n">w_wraped</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">xr_detect_activated</span><span class="p">:</span>
                    <span class="n">ZdZ</span> <span class="o">=</span> <span class="n">Z_xr</span><span class="p">[</span><span class="n">dzndz</span><span class="p">]</span> <span class="o">+</span> <span class="n">ref_dzndz_next</span>
                    <span class="n">bool_stationnary</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">fsxn</span><span class="o">.</span><span class="n">extended_abs2</span><span class="p">(</span><span class="n">ZdZ</span><span class="p">)</span>
                        <span class="o">&lt;</span> <span class="n">epsilon_stationnary_sq</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ZdZ</span> <span class="o">=</span> <span class="n">Z</span><span class="p">[</span><span class="n">dzndz</span><span class="p">]</span> <span class="o">+</span> <span class="n">ref_dzndz_next</span>
                    <span class="n">bool_stationnary</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">ZdZ</span><span class="o">.</span><span class="n">real</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">ZdZ</span><span class="o">.</span><span class="n">imag</span> <span class="o">**</span> <span class="mi">2</span>
                        <span class="o">&lt;</span> <span class="n">epsilon_stationnary_sq</span>
                    <span class="p">)</span>
                <span class="k">if</span> <span class="n">bool_stationnary</span><span class="p">:</span>
                    <span class="n">stop</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">reason_stationnary</span>
                    <span class="k">break</span>

            <span class="c1">#==================================================================</span>
            <span class="c1"># Stopping condition: divergence</span>
            <span class="c1"># ZZ = &quot;Total&quot; z + dz</span>

            <span class="k">if</span> <span class="n">xr_detect_activated</span><span class="p">:</span>
                <span class="n">ref_zn_next</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">perturbation</span><span class="o">.</span><span class="n">ref_path_get</span><span class="p">(</span>
                    <span class="n">Zn_path</span><span class="p">,</span> <span class="n">w_iter</span><span class="p">,</span>
                    <span class="n">has_xr</span><span class="p">,</span> <span class="n">ref_index_xr</span><span class="p">,</span> <span class="n">ref_xr</span><span class="p">,</span> <span class="n">refpath_ptr</span><span class="p">,</span>
                    <span class="n">out_is_xr</span><span class="p">,</span> <span class="n">out_xr</span><span class="p">,</span> <span class="mi">0</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ref_zn_next</span> <span class="o">=</span> <span class="n">Zn_path</span><span class="p">[</span><span class="n">w_iter</span><span class="p">]</span>

            <span class="c1"># div condition computation with std only</span>
            <span class="n">ZZ</span> <span class="o">=</span> <span class="n">Z</span><span class="p">[</span><span class="n">zn</span><span class="p">]</span> <span class="o">+</span> <span class="n">ref_zn_next</span>
            <span class="n">full_sq_norm</span> <span class="o">=</span> <span class="n">ZZ</span><span class="o">.</span><span class="n">real</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">ZZ</span><span class="o">.</span><span class="n">imag</span> <span class="o">**</span> <span class="mi">2</span>
            
            <span class="c1"># Storing the orbit for future use</span>
            <span class="k">if</span> <span class="n">calc_orbit</span><span class="p">:</span>
                <span class="n">div</span> <span class="o">=</span> <span class="n">n_iter</span> <span class="o">//</span> <span class="n">backshift</span>
                <span class="k">if</span> <span class="n">div</span> <span class="o">&gt;</span> <span class="n">div_shift</span><span class="p">:</span>
                    <span class="n">div_shift</span> <span class="o">=</span> <span class="n">div</span>
                    <span class="n">orbit_i2</span> <span class="o">=</span> <span class="n">orbit_i1</span>
                    <span class="n">orbit_zn2</span> <span class="o">=</span> <span class="n">orbit_zn1</span>
                    <span class="n">orbit_i1</span> <span class="o">=</span> <span class="n">n_iter</span>
                    <span class="n">orbit_zn1</span> <span class="o">=</span> <span class="n">ZZ</span>

            <span class="c1"># Flagged as &#39;diverging&#39;</span>
            <span class="n">bool_infty</span> <span class="o">=</span> <span class="p">(</span><span class="n">full_sq_norm</span> <span class="o">&gt;</span> <span class="n">M_divergence_sq</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">bool_infty</span><span class="p">:</span>
                <span class="n">stop</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">reason_M_divergence</span>
                <span class="k">break</span>

            <span class="c1">#==================================================================</span>
            <span class="c1"># Glitch correction - reference point diverging</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">w_iter</span> <span class="o">&gt;=</span> <span class="n">ref_div_iter</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="c1"># Rebasing - we are already big no underflow risk</span>
                <span class="n">Z</span><span class="p">[</span><span class="n">zn</span><span class="p">]</span> <span class="o">=</span> <span class="n">ZZ</span>
                <span class="k">if</span> <span class="n">xr_detect_activated</span><span class="p">:</span>
                    <span class="n">Z_xr</span><span class="p">[</span><span class="n">zn</span><span class="p">]</span> <span class="o">=</span> <span class="n">fsxn</span><span class="o">.</span><span class="n">to_Xrange_scalar</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">calc_dzndc</span><span class="p">:</span>
                        <span class="n">Z_xr</span><span class="p">[</span><span class="n">dzndc</span><span class="p">]</span> <span class="o">=</span> <span class="n">Z_xr</span><span class="p">[</span><span class="n">dzndc</span><span class="p">]</span> <span class="o">+</span> <span class="n">dZndc_path</span><span class="p">[</span><span class="n">w_iter</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">calc_dzndz</span><span class="p">:</span>
                        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">nullify_dZndz</span><span class="p">):</span>
                            <span class="n">added_index</span> <span class="o">=</span> <span class="n">w_iter</span>
                            <span class="k">if</span> <span class="n">n_iter</span> <span class="o">==</span> <span class="n">ref_order</span><span class="p">:</span>
                                <span class="n">added_index</span> <span class="o">=</span> <span class="n">w_wraped</span>
                            <span class="n">Z_xr</span><span class="p">[</span><span class="n">dzndz</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">Z_xr</span><span class="p">[</span><span class="n">dzndz</span><span class="p">]</span> <span class="o">+</span> <span class="n">dZndz_path</span><span class="p">[</span><span class="n">added_index</span><span class="p">]</span>
                            <span class="p">)</span>
                        <span class="n">nullify_dZndz</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">calc_dzndc</span><span class="p">:</span>
                        <span class="c1"># not a cycle, dZndc_path[0] == 0</span>
                        <span class="n">Z</span><span class="p">[</span><span class="n">dzndc</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dZndc_path</span><span class="p">[</span><span class="n">w_iter</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">calc_dzndz</span><span class="p">:</span>
                        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">nullify_dZndz</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">n_iter</span> <span class="o">==</span> <span class="n">ref_order</span><span class="p">:</span>
                                <span class="n">Z</span><span class="p">[</span><span class="n">dzndz</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dZndz_path</span><span class="p">[</span><span class="n">w_wraped</span><span class="p">]</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">Z</span><span class="p">[</span><span class="n">dzndz</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dZndz_path</span><span class="p">[</span><span class="n">w_iter</span><span class="p">]</span>
                        <span class="n">nullify_dZndz</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="n">w_iter</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">continue</span>

            <span class="c1">#==================================================================</span>
            <span class="c1"># Glitch correction - &quot;Dynamic glitch&quot;</span>
            <span class="n">bool_dyn_rebase</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">ZZ</span><span class="o">.</span><span class="n">real</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">Z</span><span class="p">[</span><span class="n">zn</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="p">))</span>
                <span class="ow">and</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">ZZ</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">Z</span><span class="p">[</span><span class="n">zn</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">bool_dyn_rebase</span><span class="p">:</span><span class="c1"># and False:</span>
                <span class="k">if</span> <span class="n">xr_detect_activated</span><span class="p">:</span>
                    <span class="c1"># Can we *really* rebase ??</span>
                    <span class="c1"># Note: if Z[zn] underflows we might miss a rebase</span>
                    <span class="c1"># So we cast everything to xr</span>
                    <span class="n">Z_xrn</span> <span class="o">=</span> <span class="n">Z_xr</span><span class="p">[</span><span class="n">zn</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">out_is_xr</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="c1"># Reference underflows, use available xr ref</span>
                        <span class="n">ZZ_xr</span> <span class="o">=</span> <span class="n">Z_xrn</span> <span class="o">+</span> <span class="n">out_xr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">ZZ_xr</span> <span class="o">=</span> <span class="n">Z_xrn</span> <span class="o">+</span> <span class="n">ref_zn_next</span>

                    <span class="n">bool_dyn_rebase_xr</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">fsxn</span><span class="o">.</span><span class="n">extended_abs2</span><span class="p">(</span><span class="n">ZZ_xr</span><span class="p">)</span>
                        <span class="o">&lt;=</span> <span class="n">fsxn</span><span class="o">.</span><span class="n">extended_abs2</span><span class="p">(</span><span class="n">Z_xrn</span><span class="p">)</span>   
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">bool_dyn_rebase_xr</span><span class="p">:</span>
                        
                        <span class="n">Z_xr</span><span class="p">[</span><span class="n">zn</span><span class="p">]</span> <span class="o">=</span> <span class="n">ZZ_xr</span>
                        <span class="c1"># /!\ keep this, needed for next BLA step</span>
                        <span class="n">Z</span><span class="p">[</span><span class="n">zn</span><span class="p">]</span> <span class="o">=</span> <span class="n">fsxn</span><span class="o">.</span><span class="n">to_standard</span><span class="p">(</span><span class="n">ZZ_xr</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">calc_dzndc</span><span class="p">:</span>
                            <span class="n">Z_xr</span><span class="p">[</span><span class="n">dzndc</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">Z_xr</span><span class="p">[</span><span class="n">dzndc</span><span class="p">]</span> <span class="o">+</span> <span class="n">dZndc_path</span><span class="p">[</span><span class="n">w_iter</span><span class="p">]</span>
                            <span class="p">)</span>
                        <span class="k">if</span> <span class="n">calc_dzndz</span><span class="p">:</span>
                            <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">nullify_dZndz</span><span class="p">):</span>
                                <span class="n">added_index</span> <span class="o">=</span> <span class="n">w_iter</span>
                                <span class="k">if</span> <span class="n">n_iter</span> <span class="o">==</span> <span class="n">ref_order</span><span class="p">:</span>
                                    <span class="n">added_index</span> <span class="o">=</span> <span class="n">w_wraped</span>
                                <span class="n">Z_xr</span><span class="p">[</span><span class="n">dzndz</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                                    <span class="n">Z_xr</span><span class="p">[</span><span class="n">dzndz</span><span class="p">]</span> <span class="o">+</span> <span class="n">dZndz_path</span><span class="p">[</span><span class="n">added_index</span><span class="p">]</span>
                                <span class="p">)</span>
                            <span class="n">nullify_dZndz</span> <span class="o">=</span> <span class="kc">True</span>

                        <span class="n">w_iter</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># No risk of underflow - safe to rebase</span>
                    <span class="n">Z</span><span class="p">[</span><span class="n">zn</span><span class="p">]</span> <span class="o">=</span> <span class="n">ZZ</span>
                    <span class="k">if</span> <span class="n">calc_dzndc</span><span class="p">:</span>
                        <span class="n">Z</span><span class="p">[</span><span class="n">dzndc</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dZndc_path</span><span class="p">[</span><span class="n">w_iter</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">calc_dzndz</span><span class="p">:</span>
                        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">nullify_dZndz</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">n_iter</span> <span class="o">==</span> <span class="n">ref_order</span><span class="p">:</span>
                                <span class="n">Z</span><span class="p">[</span><span class="n">dzndz</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dZndz_path</span><span class="p">[</span><span class="n">w_wraped</span><span class="p">]</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">Z</span><span class="p">[</span><span class="n">dzndz</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dZndz_path</span><span class="p">[</span><span class="n">w_iter</span><span class="p">]</span>
                        <span class="n">nullify_dZndz</span> <span class="o">=</span> <span class="kc">True</span>

                    <span class="n">w_iter</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">continue</span>

        <span class="c1"># End of iterations for this point</span>
        <span class="n">U</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">w_iter</span>

        <span class="k">if</span> <span class="n">xr_detect_activated</span><span class="p">:</span>
            <span class="n">Z</span><span class="p">[</span><span class="n">zn</span><span class="p">]</span> <span class="o">=</span> <span class="n">fsxn</span><span class="o">.</span><span class="n">to_standard</span><span class="p">(</span><span class="n">Z_xr</span><span class="p">[</span><span class="n">zn</span><span class="p">])</span> <span class="o">+</span> <span class="n">Zn_path</span><span class="p">[</span><span class="n">w_iter</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">calc_dzndc</span><span class="p">:</span> <span class="c1"># and n_iter &gt; 1:</span>
                <span class="n">Z</span><span class="p">[</span><span class="n">dzndc</span><span class="p">]</span> <span class="o">=</span> <span class="n">fsxn</span><span class="o">.</span><span class="n">to_standard</span><span class="p">(</span><span class="n">Z_xr</span><span class="p">[</span><span class="n">dzndc</span><span class="p">]</span> <span class="o">+</span> <span class="n">dZndc_path</span><span class="p">[</span><span class="n">w_iter</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Z</span><span class="p">[</span><span class="n">zn</span><span class="p">]</span> <span class="o">+=</span> <span class="n">Zn_path</span><span class="p">[</span><span class="n">w_iter</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">calc_dzndc</span><span class="p">:</span>  <span class="c1"># and n_iter &gt; 1:</span>
                <span class="c1"># if n_iter != 1:</span>
                <span class="n">Z</span><span class="p">[</span><span class="n">dzndc</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dZndc_path</span><span class="p">[</span><span class="n">w_iter</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">proj_dzndc_modifier</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Z</span><span class="p">[</span><span class="n">dzndc</span><span class="p">]</span> <span class="o">*=</span> <span class="n">proj_dzndc_modifier</span><span class="p">(</span><span class="n">c_pix</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">calc_orbit</span><span class="p">:</span> <span class="c1"># Finalizing the orbit</span>
            <span class="n">zn_orbit</span> <span class="o">=</span> <span class="n">orbit_zn2</span>
            <span class="n">CC</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">Zn_path</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">while</span> <span class="n">orbit_i2</span> <span class="o">&lt;</span> <span class="n">n_iter</span> <span class="o">-</span> <span class="n">backshift</span><span class="p">:</span>
                <span class="n">zn_orbit</span> <span class="o">=</span> <span class="n">zn_iterate</span><span class="p">(</span><span class="n">zn_orbit</span><span class="p">,</span> <span class="n">CC</span><span class="p">)</span>
                <span class="n">orbit_i2</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">Z</span><span class="p">[</span><span class="n">i_znorbit</span><span class="p">]</span> <span class="o">=</span> <span class="n">zn_orbit</span>

        <span class="k">return</span> <span class="n">n_iter</span>

    <span class="k">return</span> <span class="n">numba_impl</span>

<span class="c1">#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="c1"># Non-holomorphic perturbation iterations</span>
<span class="c1">#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>

<span class="nd">@numba</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">error_model</span><span class="o">=</span><span class="s2">&quot;numpy&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">numba_cycles_perturb_BS</span><span class="p">(</span>
    <span class="n">c_pix</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">stop_reason</span><span class="p">,</span> <span class="n">stop_iter</span><span class="p">,</span>
    <span class="n">initialize</span><span class="p">,</span> <span class="n">iterate</span><span class="p">,</span>
    <span class="n">Zn_path</span><span class="p">,</span> <span class="n">dXnda_path</span><span class="p">,</span> <span class="n">dXndb_path</span><span class="p">,</span> <span class="n">dYnda_path</span><span class="p">,</span> <span class="n">dYndb_path</span><span class="p">,</span>
    <span class="n">has_xr</span><span class="p">,</span> <span class="n">ref_index_xr</span><span class="p">,</span> <span class="n">refx_xr</span><span class="p">,</span> <span class="n">refy_xr</span><span class="p">,</span> <span class="n">ref_div_iter</span><span class="p">,</span> <span class="n">ref_order</span><span class="p">,</span>
    <span class="n">driftx_xr</span><span class="p">,</span> <span class="n">drifty_xr</span><span class="p">,</span> <span class="n">dx_xr</span><span class="p">,</span> <span class="n">proj_impl</span><span class="p">,</span> <span class="n">lin_mat</span><span class="p">,</span> <span class="n">lin_scale_xr</span><span class="p">,</span>
    <span class="n">kc</span><span class="p">,</span> <span class="n">M_bla</span><span class="p">,</span> <span class="n">r_bla</span><span class="p">,</span> <span class="n">bla_len</span><span class="p">,</span> <span class="n">stages_bla</span><span class="p">,</span> <span class="c1"># suppressed P, n_iter_init</span>
    <span class="n">proj_dzndc_modifier</span><span class="p">,</span>
    <span class="n">_interrupted</span>
<span class="p">):</span>

    <span class="n">nz</span><span class="p">,</span> <span class="n">npts</span> <span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">Z_xr</span> <span class="o">=</span> <span class="n">Xr_float_template</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">nz</span><span class="p">)</span>
    <span class="n">Z_xr_trigger</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">nz</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">ipt</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npts</span><span class="p">):</span>

        <span class="n">refpath_ptr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">out_is_xr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numba</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
        <span class="n">out_xr</span> <span class="o">=</span> <span class="n">Xr_float_template</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

        <span class="n">Zpt</span> <span class="o">=</span> <span class="n">Z</span><span class="p">[:,</span> <span class="n">ipt</span><span class="p">]</span>
        <span class="n">Upt</span> <span class="o">=</span> <span class="n">U</span><span class="p">[:,</span> <span class="n">ipt</span><span class="p">]</span>

        <span class="n">apt</span><span class="p">,</span> <span class="n">bpt</span><span class="p">,</span> <span class="n">a_xr</span><span class="p">,</span> <span class="n">b_xr</span> <span class="o">=</span> <span class="n">ref_path_c_from_pix_BS</span><span class="p">(</span>
            <span class="n">c_pix</span><span class="p">[</span><span class="n">ipt</span><span class="p">],</span> <span class="n">proj_impl</span><span class="p">,</span> <span class="n">lin_mat</span><span class="p">,</span> <span class="n">lin_scale_xr</span><span class="p">,</span> <span class="n">driftx_xr</span><span class="p">,</span> <span class="n">drifty_xr</span>
        <span class="p">)</span>
        <span class="n">stop_pt</span> <span class="o">=</span> <span class="n">stop_reason</span><span class="p">[:,</span> <span class="n">ipt</span><span class="p">]</span>

        <span class="n">initialize</span><span class="p">(</span><span class="n">Zpt</span><span class="p">,</span> <span class="n">Z_xr</span><span class="p">)</span>

        <span class="n">n_iter</span> <span class="o">=</span> <span class="n">iterate</span><span class="p">(</span>
            <span class="n">apt</span><span class="p">,</span> <span class="n">bpt</span><span class="p">,</span> <span class="n">a_xr</span><span class="p">,</span> <span class="n">b_xr</span><span class="p">,</span> <span class="n">Zpt</span><span class="p">,</span> <span class="n">Z_xr</span><span class="p">,</span> <span class="n">Z_xr_trigger</span><span class="p">,</span>
            <span class="n">Upt</span><span class="p">,</span> <span class="n">stop_pt</span><span class="p">,</span>
            <span class="n">Zn_path</span><span class="p">,</span> <span class="n">dXnda_path</span><span class="p">,</span> <span class="n">dXndb_path</span><span class="p">,</span> <span class="n">dYnda_path</span><span class="p">,</span> <span class="n">dYndb_path</span><span class="p">,</span>
            <span class="n">has_xr</span><span class="p">,</span> <span class="n">ref_index_xr</span><span class="p">,</span> <span class="n">refx_xr</span><span class="p">,</span> <span class="n">refy_xr</span><span class="p">,</span> <span class="n">ref_div_iter</span><span class="p">,</span> <span class="n">ref_order</span><span class="p">,</span>
            <span class="n">refpath_ptr</span><span class="p">,</span> <span class="n">out_is_xr</span><span class="p">,</span> <span class="n">out_xr</span><span class="p">,</span> <span class="n">M_bla</span><span class="p">,</span> <span class="n">r_bla</span><span class="p">,</span> <span class="n">bla_len</span><span class="p">,</span> <span class="n">stages_bla</span><span class="p">,</span>
            <span class="n">proj_dzndc_modifier</span><span class="p">,</span> <span class="n">c_pix</span><span class="p">[</span><span class="n">ipt</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">stop_iter</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">ipt</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_iter</span>
        <span class="n">stop_reason</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">ipt</span><span class="p">]</span> <span class="o">=</span> <span class="n">stop_pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">_interrupted</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">USER_INTERRUPTED</span>
    <span class="k">return</span> <span class="mi">0</span>


<span class="k">def</span> <span class="nf">numba_initialize_BS</span><span class="p">(</span><span class="n">xn</span><span class="p">,</span> <span class="n">yn</span><span class="p">,</span> <span class="n">dxnda</span><span class="p">,</span> <span class="n">dxndb</span><span class="p">,</span> <span class="n">dynda</span><span class="p">,</span> <span class="n">dyndb</span><span class="p">):</span>
    <span class="nd">@numba</span><span class="o">.</span><span class="n">njit</span>
    <span class="k">def</span> <span class="nf">numba_init_impl</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">Z_xr</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Only : initialize the Xrange</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">(</span><span class="n">xn</span><span class="p">,</span> <span class="n">yn</span><span class="p">,</span> <span class="n">dxnda</span><span class="p">,</span> <span class="n">dxndb</span><span class="p">,</span> <span class="n">dynda</span><span class="p">,</span> <span class="n">dyndb</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span><span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">Z_xr</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">fsxn</span><span class="o">.</span><span class="n">to_Xrange_scalar</span><span class="p">(</span><span class="n">Z</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">numba_init_impl</span>


<span class="c1"># Defines iterate for non-holomorphic function via a function factory</span>
<span class="c1"># jitted implementation</span>
<span class="k">def</span> <span class="nf">numba_iterate_BS</span><span class="p">(</span>
    <span class="n">M_divergence_sq</span><span class="p">,</span> <span class="n">max_iter</span><span class="p">,</span> <span class="n">reason_max_iter</span><span class="p">,</span> <span class="n">reason_M_divergence</span><span class="p">,</span>
    <span class="n">xr_detect_activated</span><span class="p">,</span> <span class="n">BLA_activated</span><span class="p">,</span>
    <span class="n">calc_hessian</span><span class="p">,</span>
    <span class="n">xn</span><span class="p">,</span> <span class="n">yn</span><span class="p">,</span> <span class="n">dxnda</span><span class="p">,</span> <span class="n">dxndb</span><span class="p">,</span> <span class="n">dynda</span><span class="p">,</span> <span class="n">dyndb</span><span class="p">,</span>
    <span class="n">p_iter_zn</span><span class="p">,</span> <span class="n">p_iter_hessian</span><span class="p">,</span>
    <span class="n">calc_orbit</span><span class="p">,</span> <span class="n">i_xnorbit</span><span class="p">,</span> <span class="n">i_ynorbit</span><span class="p">,</span> <span class="n">backshift</span><span class="p">,</span> <span class="n">xnyn_iterate</span> <span class="c1"># new args</span>
<span class="p">):</span>

    <span class="nd">@numba</span><span class="o">.</span><span class="n">njit</span>
    <span class="k">def</span> <span class="nf">numba_impl</span><span class="p">(</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">a_xr</span><span class="p">,</span> <span class="n">b_xr</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">Z_xr</span><span class="p">,</span> <span class="n">Z_xr_trigger</span><span class="p">,</span>
        <span class="n">U</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span>
        <span class="n">Zn_path</span><span class="p">,</span> <span class="n">dXnda_path</span><span class="p">,</span> <span class="n">dXndb_path</span><span class="p">,</span> <span class="n">dYnda_path</span><span class="p">,</span> <span class="n">dYndb_path</span><span class="p">,</span>
        <span class="n">has_xr</span><span class="p">,</span> <span class="n">ref_index_xr</span><span class="p">,</span> <span class="n">refx_xr</span><span class="p">,</span> <span class="n">refy_xr</span><span class="p">,</span> <span class="n">ref_div_iter</span><span class="p">,</span> <span class="n">ref_order</span><span class="p">,</span>
        <span class="n">refpath_ptr</span><span class="p">,</span> <span class="n">out_is_xr</span><span class="p">,</span> <span class="n">out_xr</span><span class="p">,</span> <span class="n">M_bla</span><span class="p">,</span> <span class="n">r_bla</span><span class="p">,</span> <span class="n">bla_len</span><span class="p">,</span> <span class="n">stages_bla</span><span class="p">,</span>
        <span class="n">proj_dzndc_modifier</span><span class="p">,</span> <span class="n">c_pix</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        c, c_xr: c and it &quot;Xrange&quot; counterparts</span>
<span class="sd">        Z, Z_xr: idem for result vector Z</span>
<span class="sd">        Z_xr_trigger : bolean, activated when Z_xr need to be used</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">record_zero</span> <span class="o">=</span> <span class="n">Xr_float_template</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Wrapped iteration if we reach the cycle order </span>
        <span class="n">w_iter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">n_iter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">w_iter</span> <span class="o">&gt;=</span> <span class="n">ref_order</span><span class="p">:</span>
            <span class="n">w_iter</span> <span class="o">=</span> <span class="n">w_iter</span> <span class="o">%</span> <span class="n">ref_order</span>
        
        <span class="k">if</span> <span class="n">calc_orbit</span><span class="p">:</span>
            <span class="n">div_shift</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">orbit_xn1</span> <span class="o">=</span> <span class="n">Z</span><span class="p">[</span><span class="n">xn</span><span class="p">]</span>
            <span class="n">orbit_xn2</span> <span class="o">=</span> <span class="n">Z</span><span class="p">[</span><span class="n">xn</span><span class="p">]</span>
            <span class="n">orbit_yn1</span> <span class="o">=</span> <span class="n">Z</span><span class="p">[</span><span class="n">yn</span><span class="p">]</span>
            <span class="n">orbit_yn2</span> <span class="o">=</span> <span class="n">Z</span><span class="p">[</span><span class="n">yn</span><span class="p">]</span>
            <span class="n">orbit_i1</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">orbit_i2</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="c1"># We know that :</span>
        <span class="c1"># ref_orbit_len = max_iter + 1 &gt;= ref_div_iter</span>
        <span class="c1"># if order is not None:</span>
        <span class="c1">#    ref_orbit_len = min(order, ref_orbit_len)</span>
        <span class="n">ref_orbit_len</span> <span class="o">=</span> <span class="n">Zn_path</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">first_invalid_index</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">ref_orbit_len</span><span class="p">,</span> <span class="n">ref_div_iter</span><span class="p">,</span> <span class="n">ref_order</span><span class="p">)</span>
        <span class="n">M_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">8</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        
        <span class="c1"># Index to keep track if we use the wraped index of dzndc</span>
        <span class="n">bool_dyn_rebase</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1">#==========================================================</span>
            <span class="c1"># Try a BLA_step</span>
            <span class="k">if</span> <span class="n">BLA_activated</span> <span class="ow">and</span> <span class="p">(</span><span class="n">w_iter</span> <span class="o">&amp;</span> <span class="n">STG_SKIP_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># and False:</span>
                <span class="n">Zn</span> <span class="o">=</span> <span class="n">Z</span><span class="p">[</span><span class="n">xn</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">Z</span><span class="p">[</span><span class="n">yn</span><span class="p">]</span>
                <span class="n">step</span> <span class="o">=</span> <span class="n">ref_BLA_get</span><span class="p">(</span>
                    <span class="n">M_bla</span><span class="p">,</span> <span class="n">r_bla</span><span class="p">,</span> <span class="n">bla_len</span><span class="p">,</span> <span class="n">stages_bla</span><span class="p">,</span> <span class="n">Zn</span><span class="p">,</span> <span class="n">w_iter</span><span class="p">,</span>
                    <span class="n">first_invalid_index</span><span class="p">,</span> <span class="n">M_out</span><span class="p">,</span> <span class="kc">False</span>
                <span class="p">)</span>
                
                <span class="k">if</span> <span class="n">step</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">n_iter</span> <span class="o">+=</span> <span class="n">step</span>
                    <span class="n">w_iter</span> <span class="o">=</span> <span class="p">(</span><span class="n">w_iter</span> <span class="o">+</span> <span class="n">step</span><span class="p">)</span> <span class="o">%</span> <span class="n">ref_order</span>
                    <span class="k">if</span> <span class="n">xr_detect_activated</span><span class="p">:</span>
                        <span class="n">apply_BLA_BS</span><span class="p">(</span><span class="n">M_out</span><span class="p">,</span> <span class="n">Z_xr</span><span class="p">,</span> <span class="n">a_xr</span><span class="p">,</span> <span class="n">b_xr</span><span class="p">,</span> <span class="n">xn</span><span class="p">,</span> <span class="n">yn</span><span class="p">)</span>
                        <span class="c1"># /!\ keep this, needed for next BLA step</span>
                        <span class="n">Z</span><span class="p">[</span><span class="n">xn</span><span class="p">]</span> <span class="o">=</span> <span class="n">fsxn</span><span class="o">.</span><span class="n">to_standard</span><span class="p">(</span><span class="n">Z_xr</span><span class="p">[</span><span class="n">xn</span><span class="p">])</span>
                        <span class="n">Z</span><span class="p">[</span><span class="n">yn</span><span class="p">]</span> <span class="o">=</span> <span class="n">fsxn</span><span class="o">.</span><span class="n">to_standard</span><span class="p">(</span><span class="n">Z_xr</span><span class="p">[</span><span class="n">yn</span><span class="p">])</span>
                        <span class="k">if</span> <span class="n">calc_hessian</span><span class="p">:</span>
                            <span class="n">apply_BLA_deriv_BS</span><span class="p">(</span><span class="n">M_out</span><span class="p">,</span> <span class="n">Z_xr</span><span class="p">,</span> <span class="n">a_xr</span><span class="p">,</span> <span class="n">b_xr</span><span class="p">,</span>
                                               <span class="n">dxnda</span><span class="p">,</span> <span class="n">dxndb</span><span class="p">,</span> <span class="n">dynda</span><span class="p">,</span> <span class="n">dyndb</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># just the usual BLA step</span>
                        <span class="n">apply_BLA_BS</span><span class="p">(</span><span class="n">M_out</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">xn</span><span class="p">,</span> <span class="n">yn</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">calc_hessian</span><span class="p">:</span>
                            <span class="n">apply_BLA_deriv_BS</span><span class="p">(</span><span class="n">M_out</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span>
                                               <span class="n">dxnda</span><span class="p">,</span> <span class="n">dxndb</span><span class="p">,</span> <span class="n">dynda</span><span class="p">,</span> <span class="n">dyndb</span><span class="p">)</span>
                    <span class="k">continue</span>

            <span class="c1">#==================================================================</span>
            <span class="c1"># BLA failed, launching a full perturbation iteration</span>
            <span class="n">n_iter</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># the indice we are going to compute now</span>
            <span class="c1"># Load reference point value @ w_iter</span>
            <span class="c1"># refpath_ptr = [prev_idx, curr_xr]</span>
            <span class="k">if</span> <span class="n">xr_detect_activated</span><span class="p">:</span>
                <span class="n">ref_zn</span> <span class="o">=</span> <span class="n">ref_path_get_BS</span><span class="p">(</span>
                    <span class="n">Zn_path</span><span class="p">,</span> <span class="n">w_iter</span><span class="p">,</span>
                    <span class="n">has_xr</span><span class="p">,</span> <span class="n">ref_index_xr</span><span class="p">,</span> <span class="n">refx_xr</span><span class="p">,</span> <span class="n">refy_xr</span><span class="p">,</span> <span class="n">refpath_ptr</span><span class="p">,</span>
                    <span class="n">out_is_xr</span><span class="p">,</span> <span class="n">out_xr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
                <span class="p">)</span>
                <span class="n">ref_xn_xr</span><span class="p">,</span> <span class="n">ref_yn_xr</span> <span class="o">=</span> <span class="n">ensure_xr_BS</span><span class="p">(</span>
                    <span class="n">ref_zn</span><span class="p">,</span> <span class="n">out_xr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">out_xr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">out_is_xr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ref_zn</span> <span class="o">=</span> <span class="n">Zn_path</span><span class="p">[</span><span class="n">w_iter</span><span class="p">]</span>
                <span class="n">ref_xn</span> <span class="o">=</span> <span class="n">ref_zn</span><span class="o">.</span><span class="n">real</span>
                <span class="n">ref_yn</span> <span class="o">=</span> <span class="n">ref_zn</span><span class="o">.</span><span class="n">imag</span>

            <span class="c1">#==================================================================</span>
            <span class="c1"># Pertubation iter block</span>
            <span class="c1">#------------------------------------------------------------------</span>
            <span class="c1"># dzndc subblock</span>
            <span class="k">if</span> <span class="n">calc_hessian</span><span class="p">:</span>
                <span class="n">ref_dxnda</span> <span class="o">=</span> <span class="n">dXnda_path</span><span class="p">[</span><span class="n">w_iter</span><span class="p">]</span> <span class="c1"># Note this may be Xrange</span>
                <span class="n">ref_dxndb</span> <span class="o">=</span> <span class="n">dXndb_path</span><span class="p">[</span><span class="n">w_iter</span><span class="p">]</span>
                <span class="n">ref_dynda</span> <span class="o">=</span> <span class="n">dYnda_path</span><span class="p">[</span><span class="n">w_iter</span><span class="p">]</span>
                <span class="n">ref_dyndb</span> <span class="o">=</span> <span class="n">dYndb_path</span><span class="p">[</span><span class="n">w_iter</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">bool_dyn_rebase</span><span class="p">:</span> <span class="c1"># Avoid the wraped value at 0</span>
                    <span class="k">if</span> <span class="n">xr_detect_activated</span><span class="p">:</span>
                        <span class="n">ref_dxnda</span> <span class="o">=</span> <span class="n">record_zero</span> <span class="c1"># Record type</span>
                        <span class="n">ref_dxndb</span> <span class="o">=</span> <span class="n">record_zero</span> <span class="c1"># Record type</span>
                        <span class="n">ref_dynda</span> <span class="o">=</span> <span class="n">record_zero</span> <span class="c1"># Record type</span>
                        <span class="n">ref_dyndb</span> <span class="o">=</span> <span class="n">record_zero</span> <span class="c1"># Record type</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">ref_dxnda</span> <span class="o">=</span> <span class="mf">0.</span>
                        <span class="n">ref_dxndb</span> <span class="o">=</span> <span class="mf">0.</span>
                        <span class="n">ref_dynda</span> <span class="o">=</span> <span class="mf">0.</span>
                        <span class="n">ref_dyndb</span> <span class="o">=</span> <span class="mf">0.</span>

                <span class="k">if</span> <span class="n">xr_detect_activated</span><span class="p">:</span>
                    <span class="n">p_iter_hessian</span><span class="p">(</span>
                        <span class="n">Z_xr</span><span class="p">,</span> <span class="n">ref_xn_xr</span><span class="p">,</span> <span class="n">ref_yn_xr</span><span class="p">,</span>
                        <span class="n">ref_dxnda</span><span class="p">,</span> <span class="n">ref_dxndb</span><span class="p">,</span> <span class="n">ref_dynda</span><span class="p">,</span> <span class="n">ref_dyndb</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">p_iter_hessian</span><span class="p">(</span>
                        <span class="n">Z</span><span class="p">,</span> <span class="n">ref_xn</span><span class="p">,</span> <span class="n">ref_yn</span><span class="p">,</span>
                        <span class="n">ref_dxnda</span><span class="p">,</span> <span class="n">ref_dxndb</span><span class="p">,</span> <span class="n">ref_dynda</span><span class="p">,</span> <span class="n">ref_dyndb</span>
                    <span class="p">)</span>

            <span class="c1">#------------------------------------------------------------------</span>
            <span class="c1"># zn subblok</span>
            <span class="k">if</span> <span class="n">xr_detect_activated</span><span class="p">:</span>
                <span class="c1"># Z_xr[zn] = p_iter_zn(Z_xr, ref_zn_xr, c_xr)# in place mod</span>
                <span class="n">p_iter_zn</span><span class="p">(</span><span class="n">Z_xr</span><span class="p">,</span> <span class="n">ref_xn_xr</span><span class="p">,</span> <span class="n">ref_yn_xr</span><span class="p">,</span> <span class="n">a_xr</span><span class="p">,</span> <span class="n">b_xr</span><span class="p">)</span><span class="c1"># in place mod</span>
                <span class="c1"># std is used for div condition </span>
                <span class="n">Z</span><span class="p">[</span><span class="n">xn</span><span class="p">]</span> <span class="o">=</span> <span class="n">fsxn</span><span class="o">.</span><span class="n">to_standard</span><span class="p">(</span><span class="n">Z_xr</span><span class="p">[</span><span class="n">xn</span><span class="p">])</span>
                <span class="n">Z</span><span class="p">[</span><span class="n">yn</span><span class="p">]</span> <span class="o">=</span> <span class="n">fsxn</span><span class="o">.</span><span class="n">to_standard</span><span class="p">(</span><span class="n">Z_xr</span><span class="p">[</span><span class="n">yn</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Z[zn] = p_iter_zn(Z, ref_zn, c)</span>
                <span class="n">p_iter_zn</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">ref_xn</span><span class="p">,</span> <span class="n">ref_yn</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

            <span class="c1">#==================================================================</span>
            <span class="c1"># Stopping condition: maximum iter reached</span>
            <span class="k">if</span> <span class="n">n_iter</span> <span class="o">&gt;=</span> <span class="n">max_iter</span><span class="p">:</span>
                <span class="n">stop</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">reason_max_iter</span>
                <span class="k">break</span>

            <span class="c1">#==================================================================</span>
            <span class="c1"># Stopping condition: divergence</span>
            <span class="c1"># ZZ = &quot;Total&quot; z + dz</span>
            <span class="n">w_iter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">w_iter</span> <span class="o">&gt;=</span> <span class="n">ref_order</span><span class="p">:</span>
                <span class="n">w_iter</span> <span class="o">=</span> <span class="n">w_iter</span> <span class="o">%</span> <span class="n">ref_order</span>

            <span class="k">if</span> <span class="n">xr_detect_activated</span><span class="p">:</span>
                <span class="n">ref_zn_next</span> <span class="o">=</span> <span class="n">ref_path_get_BS</span><span class="p">(</span>
                    <span class="n">Zn_path</span><span class="p">,</span> <span class="n">w_iter</span><span class="p">,</span>
                    <span class="n">has_xr</span><span class="p">,</span> <span class="n">ref_index_xr</span><span class="p">,</span> <span class="n">refx_xr</span><span class="p">,</span> <span class="n">refy_xr</span><span class="p">,</span> <span class="n">refpath_ptr</span><span class="p">,</span>
                    <span class="n">out_is_xr</span><span class="p">,</span> <span class="n">out_xr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ref_zn_next</span> <span class="o">=</span> <span class="n">Zn_path</span><span class="p">[</span><span class="n">w_iter</span><span class="p">]</span>

            <span class="c1"># div condition computation with std only</span>
            <span class="n">XX</span> <span class="o">=</span> <span class="n">Z</span><span class="p">[</span><span class="n">xn</span><span class="p">]</span> <span class="o">+</span> <span class="n">ref_zn_next</span><span class="o">.</span><span class="n">real</span>
            <span class="n">YY</span> <span class="o">=</span> <span class="n">Z</span><span class="p">[</span><span class="n">yn</span><span class="p">]</span> <span class="o">+</span> <span class="n">ref_zn_next</span><span class="o">.</span><span class="n">imag</span>
            <span class="n">full_sq_norm</span> <span class="o">=</span> <span class="n">XX</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">YY</span> <span class="o">**</span> <span class="mi">2</span>
            
            <span class="c1"># Storing the orbit for future use</span>
            <span class="k">if</span> <span class="n">calc_orbit</span><span class="p">:</span>
                <span class="n">div</span> <span class="o">=</span> <span class="n">n_iter</span> <span class="o">//</span> <span class="n">backshift</span>
                <span class="k">if</span> <span class="n">div</span> <span class="o">&gt;</span> <span class="n">div_shift</span><span class="p">:</span>
                    <span class="n">div_shift</span> <span class="o">=</span> <span class="n">div</span>
                    <span class="n">orbit_i2</span> <span class="o">=</span> <span class="n">orbit_i1</span>
                    <span class="n">orbit_xn2</span> <span class="o">=</span> <span class="n">orbit_xn1</span>
                    <span class="n">orbit_yn2</span> <span class="o">=</span> <span class="n">orbit_yn1</span>
                    <span class="n">orbit_i1</span> <span class="o">=</span> <span class="n">n_iter</span>
                    <span class="n">orbit_xn1</span> <span class="o">=</span> <span class="n">XX</span>
                    <span class="n">orbit_yn1</span> <span class="o">=</span> <span class="n">YY</span>

            <span class="c1"># Flagged as &#39;diverging&#39;</span>
            <span class="n">bool_infty</span> <span class="o">=</span> <span class="p">(</span><span class="n">full_sq_norm</span> <span class="o">&gt;</span> <span class="n">M_divergence_sq</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">bool_infty</span><span class="p">:</span>
                <span class="n">stop</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">reason_M_divergence</span>
                <span class="k">break</span>

            <span class="c1">#==================================================================</span>
            <span class="c1"># Glitch correction - reference point diverging</span>
            
            <span class="k">if</span> <span class="p">(</span><span class="n">w_iter</span> <span class="o">&gt;=</span> <span class="n">ref_div_iter</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="c1"># Rebasing - we are already big no underflow risk</span>
                <span class="n">Z</span><span class="p">[</span><span class="n">xn</span><span class="p">]</span> <span class="o">=</span> <span class="n">XX</span>
                <span class="n">Z</span><span class="p">[</span><span class="n">yn</span><span class="p">]</span> <span class="o">=</span> <span class="n">YY</span>

                <span class="k">if</span> <span class="n">xr_detect_activated</span><span class="p">:</span>
                    <span class="n">Z_xr</span><span class="p">[</span><span class="n">xn</span><span class="p">]</span> <span class="o">=</span> <span class="n">fsxn</span><span class="o">.</span><span class="n">to_Xrange_scalar</span><span class="p">(</span><span class="n">XX</span><span class="p">)</span>
                    <span class="n">Z_xr</span><span class="p">[</span><span class="n">yn</span><span class="p">]</span> <span class="o">=</span> <span class="n">fsxn</span><span class="o">.</span><span class="n">to_Xrange_scalar</span><span class="p">(</span><span class="n">YY</span><span class="p">)</span>
                    <span class="c1"># not a cycle, dZndc_path[0] == 0</span>
                    <span class="c1"># assert (dXnda_path[w_iter] == 0.)</span>
                    <span class="k">if</span> <span class="n">calc_hessian</span><span class="p">:</span>
                        <span class="n">Z_xr</span><span class="p">[</span><span class="n">dxnda</span><span class="p">]</span> <span class="o">=</span> <span class="n">Z_xr</span><span class="p">[</span><span class="n">dxnda</span><span class="p">]</span> <span class="o">+</span> <span class="n">dXnda_path</span><span class="p">[</span><span class="n">w_iter</span><span class="p">]</span>
                        <span class="n">Z_xr</span><span class="p">[</span><span class="n">dxndb</span><span class="p">]</span> <span class="o">=</span> <span class="n">Z_xr</span><span class="p">[</span><span class="n">dxndb</span><span class="p">]</span> <span class="o">+</span> <span class="n">dXndb_path</span><span class="p">[</span><span class="n">w_iter</span><span class="p">]</span>
                        <span class="n">Z_xr</span><span class="p">[</span><span class="n">dynda</span><span class="p">]</span> <span class="o">=</span> <span class="n">Z_xr</span><span class="p">[</span><span class="n">dynda</span><span class="p">]</span> <span class="o">+</span> <span class="n">dYnda_path</span><span class="p">[</span><span class="n">w_iter</span><span class="p">]</span>
                        <span class="n">Z_xr</span><span class="p">[</span><span class="n">dyndb</span><span class="p">]</span> <span class="o">=</span> <span class="n">Z_xr</span><span class="p">[</span><span class="n">dyndb</span><span class="p">]</span> <span class="o">+</span> <span class="n">dYndb_path</span><span class="p">[</span><span class="n">w_iter</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">calc_hessian</span><span class="p">:</span>
                        <span class="c1"># not a cycle, dZndc_path[0] == 0</span>
                        <span class="n">Z</span><span class="p">[</span><span class="n">dxnda</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dXnda_path</span><span class="p">[</span><span class="n">w_iter</span><span class="p">]</span>
                        <span class="n">Z</span><span class="p">[</span><span class="n">dxndb</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dXndb_path</span><span class="p">[</span><span class="n">w_iter</span><span class="p">]</span>
                        <span class="n">Z</span><span class="p">[</span><span class="n">dynda</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dYnda_path</span><span class="p">[</span><span class="n">w_iter</span><span class="p">]</span>
                        <span class="n">Z</span><span class="p">[</span><span class="n">dyndb</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dYndb_path</span><span class="p">[</span><span class="n">w_iter</span><span class="p">]</span>

                <span class="n">w_iter</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">continue</span>

            <span class="c1">#==================================================================</span>
            <span class="c1"># Glitch correction - &quot;dynamic glitch&quot;</span>
            <span class="n">bool_dyn_rebase</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">XX</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">Z</span><span class="p">[</span><span class="n">xn</span><span class="p">]))</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">YY</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">Z</span><span class="p">[</span><span class="n">yn</span><span class="p">]))</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">bool_dyn_rebase</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">xr_detect_activated</span><span class="p">:</span>
                    <span class="c1"># Can we *really* rebase ??</span>
                    <span class="c1"># Note: if Z[zn] underflows we might miss a rebase</span>
                    <span class="c1"># So we cast everything to xr</span>
                    <span class="n">X_xrn</span> <span class="o">=</span> <span class="n">Z_xr</span><span class="p">[</span><span class="n">xn</span><span class="p">]</span>
                    <span class="n">Y_xrn</span> <span class="o">=</span> <span class="n">Z_xr</span><span class="p">[</span><span class="n">yn</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">out_is_xr</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="c1"># Reference underflows, use available xr ref</span>
                        <span class="n">XX_xr</span> <span class="o">=</span> <span class="n">X_xrn</span> <span class="o">+</span> <span class="n">out_xr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">YY_xr</span> <span class="o">=</span> <span class="n">Y_xrn</span> <span class="o">+</span> <span class="n">out_xr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">XX_xr</span> <span class="o">=</span> <span class="n">X_xrn</span> <span class="o">+</span> <span class="n">ref_zn_next</span><span class="o">.</span><span class="n">real</span>
                        <span class="n">YY_xr</span> <span class="o">=</span> <span class="n">Y_xrn</span> <span class="o">+</span> <span class="n">ref_zn_next</span><span class="o">.</span><span class="n">imag</span>

                    <span class="n">bool_dyn_rebase_xr</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="p">(</span><span class="n">XX_xr</span> <span class="o">*</span> <span class="n">XX_xr</span> <span class="o">+</span> <span class="n">YY_xr</span> <span class="o">*</span> <span class="n">YY_xr</span><span class="p">)</span>
                        <span class="o">&lt;=</span> <span class="p">(</span><span class="n">X_xrn</span> <span class="o">*</span> <span class="n">X_xrn</span> <span class="o">+</span> <span class="n">Y_xrn</span> <span class="o">*</span> <span class="n">Y_xrn</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">bool_dyn_rebase_xr</span><span class="p">:</span>
                        <span class="n">Z_xr</span><span class="p">[</span><span class="n">xn</span><span class="p">]</span> <span class="o">=</span> <span class="n">XX_xr</span>
                        <span class="n">Z_xr</span><span class="p">[</span><span class="n">yn</span><span class="p">]</span> <span class="o">=</span> <span class="n">YY_xr</span>
                        <span class="c1"># /!\ keep this, needed for next BLA step</span>
                        <span class="n">Z</span><span class="p">[</span><span class="n">xn</span><span class="p">]</span> <span class="o">=</span> <span class="n">fsxn</span><span class="o">.</span><span class="n">to_standard</span><span class="p">(</span><span class="n">XX_xr</span><span class="p">)</span>
                        <span class="n">Z</span><span class="p">[</span><span class="n">yn</span><span class="p">]</span> <span class="o">=</span> <span class="n">fsxn</span><span class="o">.</span><span class="n">to_standard</span><span class="p">(</span><span class="n">YY_xr</span><span class="p">)</span>

                        <span class="k">if</span> <span class="n">calc_hessian</span><span class="p">:</span>
                            <span class="n">Z_xr</span><span class="p">[</span><span class="n">dxnda</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">Z_xr</span><span class="p">[</span><span class="n">dxnda</span><span class="p">]</span> <span class="o">+</span> <span class="n">dXnda_path</span><span class="p">[</span><span class="n">w_iter</span><span class="p">]</span>
                            <span class="p">)</span>
                            <span class="n">Z_xr</span><span class="p">[</span><span class="n">dxndb</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">Z_xr</span><span class="p">[</span><span class="n">dxndb</span><span class="p">]</span> <span class="o">+</span> <span class="n">dXndb_path</span><span class="p">[</span><span class="n">w_iter</span><span class="p">]</span>
                            <span class="p">)</span>
                            <span class="n">Z_xr</span><span class="p">[</span><span class="n">dynda</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">Z_xr</span><span class="p">[</span><span class="n">dynda</span><span class="p">]</span> <span class="o">+</span> <span class="n">dYnda_path</span><span class="p">[</span><span class="n">w_iter</span><span class="p">]</span>
                            <span class="p">)</span>
                            <span class="n">Z_xr</span><span class="p">[</span><span class="n">dyndb</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">Z_xr</span><span class="p">[</span><span class="n">dyndb</span><span class="p">]</span> <span class="o">+</span> <span class="n">dYndb_path</span><span class="p">[</span><span class="n">w_iter</span><span class="p">]</span>
                            <span class="p">)</span>
                        <span class="n">w_iter</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># No risk of underflow - safe to rebase</span>
                    <span class="n">Z</span><span class="p">[</span><span class="n">xn</span><span class="p">]</span> <span class="o">=</span> <span class="n">XX</span>
                    <span class="n">Z</span><span class="p">[</span><span class="n">yn</span><span class="p">]</span> <span class="o">=</span> <span class="n">YY</span>
                    <span class="k">if</span> <span class="n">calc_hessian</span><span class="p">:</span>
                        <span class="n">Z</span><span class="p">[</span><span class="n">dxnda</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dXnda_path</span><span class="p">[</span><span class="n">w_iter</span><span class="p">]</span>
                        <span class="n">Z</span><span class="p">[</span><span class="n">dxndb</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dXndb_path</span><span class="p">[</span><span class="n">w_iter</span><span class="p">]</span>
                        <span class="n">Z</span><span class="p">[</span><span class="n">dynda</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dYnda_path</span><span class="p">[</span><span class="n">w_iter</span><span class="p">]</span>
                        <span class="n">Z</span><span class="p">[</span><span class="n">dyndb</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dYndb_path</span><span class="p">[</span><span class="n">w_iter</span><span class="p">]</span>
                    <span class="n">w_iter</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">continue</span>

        <span class="c1"># End of iterations for this point</span>
        <span class="n">U</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">w_iter</span>
        
        <span class="c1"># Total zn = Zn + zn</span>
        <span class="n">ref_zn</span> <span class="o">=</span> <span class="n">Zn_path</span><span class="p">[</span><span class="n">w_iter</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">xr_detect_activated</span><span class="p">:</span>
            <span class="n">Z</span><span class="p">[</span><span class="n">xn</span><span class="p">]</span> <span class="o">=</span> <span class="n">fsxn</span><span class="o">.</span><span class="n">to_standard</span><span class="p">(</span><span class="n">Z_xr</span><span class="p">[</span><span class="n">xn</span><span class="p">]</span> <span class="o">+</span> <span class="n">ref_zn</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>
            <span class="n">Z</span><span class="p">[</span><span class="n">yn</span><span class="p">]</span> <span class="o">=</span> <span class="n">fsxn</span><span class="o">.</span><span class="n">to_standard</span><span class="p">(</span><span class="n">Z_xr</span><span class="p">[</span><span class="n">yn</span><span class="p">]</span> <span class="o">+</span> <span class="n">ref_zn</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">calc_hessian</span><span class="p">:</span>
                <span class="n">Z</span><span class="p">[</span><span class="n">dxnda</span><span class="p">]</span> <span class="o">=</span> <span class="n">fsxn</span><span class="o">.</span><span class="n">to_standard</span><span class="p">(</span>
                        <span class="n">Z_xr</span><span class="p">[</span><span class="n">dxnda</span><span class="p">]</span> <span class="o">+</span> <span class="n">dXnda_path</span><span class="p">[</span><span class="n">w_iter</span><span class="p">])</span>
                <span class="n">Z</span><span class="p">[</span><span class="n">dxndb</span><span class="p">]</span> <span class="o">=</span> <span class="n">fsxn</span><span class="o">.</span><span class="n">to_standard</span><span class="p">(</span>
                        <span class="n">Z_xr</span><span class="p">[</span><span class="n">dxndb</span><span class="p">]</span> <span class="o">+</span> <span class="n">dXndb_path</span><span class="p">[</span><span class="n">w_iter</span><span class="p">])</span>
                <span class="n">Z</span><span class="p">[</span><span class="n">dynda</span><span class="p">]</span> <span class="o">=</span> <span class="n">fsxn</span><span class="o">.</span><span class="n">to_standard</span><span class="p">(</span>
                        <span class="n">Z_xr</span><span class="p">[</span><span class="n">dynda</span><span class="p">]</span> <span class="o">+</span> <span class="n">dYnda_path</span><span class="p">[</span><span class="n">w_iter</span><span class="p">])</span>
                <span class="n">Z</span><span class="p">[</span><span class="n">dyndb</span><span class="p">]</span> <span class="o">=</span> <span class="n">fsxn</span><span class="o">.</span><span class="n">to_standard</span><span class="p">(</span>
                        <span class="n">Z_xr</span><span class="p">[</span><span class="n">dyndb</span><span class="p">]</span> <span class="o">+</span> <span class="n">dYndb_path</span><span class="p">[</span><span class="n">w_iter</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Z</span><span class="p">[</span><span class="n">xn</span><span class="p">]</span> <span class="o">+=</span> <span class="n">ref_zn</span><span class="o">.</span><span class="n">real</span>
            <span class="n">Z</span><span class="p">[</span><span class="n">yn</span><span class="p">]</span> <span class="o">+=</span> <span class="n">ref_zn</span><span class="o">.</span><span class="n">imag</span>
            <span class="k">if</span> <span class="n">calc_hessian</span><span class="p">:</span>
                <span class="n">Z</span><span class="p">[</span><span class="n">dxnda</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dXnda_path</span><span class="p">[</span><span class="n">w_iter</span><span class="p">]</span>
                <span class="n">Z</span><span class="p">[</span><span class="n">dxndb</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dXndb_path</span><span class="p">[</span><span class="n">w_iter</span><span class="p">]</span>
                <span class="n">Z</span><span class="p">[</span><span class="n">dynda</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dYnda_path</span><span class="p">[</span><span class="n">w_iter</span><span class="p">]</span>
                <span class="n">Z</span><span class="p">[</span><span class="n">dyndb</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dYndb_path</span><span class="p">[</span><span class="n">w_iter</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">proj_dzndc_modifier</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Z</span><span class="p">[</span><span class="n">dxnda</span><span class="p">]</span> <span class="o">*=</span> <span class="n">proj_dzndc_modifier</span><span class="p">(</span><span class="n">c_pix</span><span class="p">)</span>
            <span class="n">Z</span><span class="p">[</span><span class="n">dxndb</span><span class="p">]</span> <span class="o">*=</span> <span class="n">proj_dzndc_modifier</span><span class="p">(</span><span class="n">c_pix</span><span class="p">)</span>
            <span class="n">Z</span><span class="p">[</span><span class="n">dynda</span><span class="p">]</span> <span class="o">*=</span> <span class="n">proj_dzndc_modifier</span><span class="p">(</span><span class="n">c_pix</span><span class="p">)</span>
            <span class="n">Z</span><span class="p">[</span><span class="n">dyndb</span><span class="p">]</span> <span class="o">*=</span> <span class="n">proj_dzndc_modifier</span><span class="p">(</span><span class="n">c_pix</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">calc_orbit</span><span class="p">:</span> <span class="c1"># Finalizing the orbit</span>
            <span class="n">xn_orbit</span> <span class="o">=</span> <span class="n">orbit_xn2</span>
            <span class="n">yn_orbit</span> <span class="o">=</span> <span class="n">orbit_yn2</span>
            <span class="n">AA</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">Zn_path</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">BB</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">Zn_path</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">while</span> <span class="n">orbit_i2</span> <span class="o">&lt;</span> <span class="n">n_iter</span> <span class="o">-</span> <span class="n">backshift</span><span class="p">:</span>
                <span class="n">xn_orbit</span><span class="p">,</span> <span class="n">yn_orbit</span> <span class="o">=</span> <span class="n">xnyn_iterate</span><span class="p">(</span><span class="n">xn_orbit</span><span class="p">,</span> <span class="n">yn_orbit</span><span class="p">,</span> <span class="n">AA</span><span class="p">,</span> <span class="n">BB</span><span class="p">)</span>
                <span class="n">orbit_i2</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">Z</span><span class="p">[</span><span class="n">i_xnorbit</span><span class="p">]</span> <span class="o">=</span> <span class="n">xn_orbit</span>
            <span class="n">Z</span><span class="p">[</span><span class="n">i_ynorbit</span><span class="p">]</span> <span class="o">=</span> <span class="n">yn_orbit</span>

        <span class="k">return</span> <span class="n">n_iter</span>

    <span class="k">return</span> <span class="n">numba_impl</span>

<span class="nd">@numba</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">apply_BLA_BS</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">xn</span><span class="p">,</span> <span class="n">yn</span><span class="p">):</span>
    <span class="n">Z_xn</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">Z</span><span class="p">[</span><span class="n">xn</span><span class="p">]</span> <span class="o">+</span> <span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">Z</span><span class="p">[</span><span class="n">yn</span><span class="p">]</span> <span class="o">+</span> <span class="n">M</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">*</span> <span class="n">a</span> <span class="o">+</span> <span class="n">M</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span>
    <span class="n">Z_yn</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">Z</span><span class="p">[</span><span class="n">xn</span><span class="p">]</span> <span class="o">+</span> <span class="n">M</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="n">Z</span><span class="p">[</span><span class="n">yn</span><span class="p">]</span> <span class="o">+</span> <span class="n">M</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">*</span> <span class="n">a</span> <span class="o">+</span> <span class="n">M</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span>
    <span class="n">Z</span><span class="p">[</span><span class="n">xn</span><span class="p">]</span> <span class="o">=</span> <span class="n">Z_xn</span>
    <span class="n">Z</span><span class="p">[</span><span class="n">yn</span><span class="p">]</span> <span class="o">=</span> <span class="n">Z_yn</span>

<span class="nd">@numba</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">apply_BLA_deriv_BS</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">dxnda</span><span class="p">,</span> <span class="n">dxndb</span><span class="p">,</span> <span class="n">dynda</span><span class="p">,</span> <span class="n">dyndb</span><span class="p">):</span>
<span class="c1">#    assert dxnda &gt;= 0</span>
<span class="c1">#    assert dxndb &lt; len(Z)</span>
    <span class="n">Z_dxnda</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">Z</span><span class="p">[</span><span class="n">dxnda</span><span class="p">]</span> <span class="o">+</span> <span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">Z</span><span class="p">[</span><span class="n">dynda</span><span class="p">]</span>
    <span class="n">Z_dxndb</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">Z</span><span class="p">[</span><span class="n">dxndb</span><span class="p">]</span> <span class="o">+</span> <span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">Z</span><span class="p">[</span><span class="n">dyndb</span><span class="p">]</span>
    <span class="n">Z_dynda</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">Z</span><span class="p">[</span><span class="n">dxnda</span><span class="p">]</span> <span class="o">+</span> <span class="n">M</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="n">Z</span><span class="p">[</span><span class="n">dynda</span><span class="p">]</span>
    <span class="n">Z_dyndb</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">Z</span><span class="p">[</span><span class="n">dxndb</span><span class="p">]</span> <span class="o">+</span> <span class="n">M</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="n">Z</span><span class="p">[</span><span class="n">dyndb</span><span class="p">]</span>
    <span class="n">Z</span><span class="p">[</span><span class="n">dxnda</span><span class="p">]</span> <span class="o">=</span> <span class="n">Z_dxnda</span>
    <span class="n">Z</span><span class="p">[</span><span class="n">dxndb</span><span class="p">]</span> <span class="o">=</span> <span class="n">Z_dxndb</span>
    <span class="n">Z</span><span class="p">[</span><span class="n">dynda</span><span class="p">]</span> <span class="o">=</span> <span class="n">Z_dynda</span>
    <span class="n">Z</span><span class="p">[</span><span class="n">dyndb</span><span class="p">]</span> <span class="o">=</span> <span class="n">Z_dyndb</span>


<span class="c1">#------------------------------------------------------------------------------</span>
<span class="c1"># Bilinear approximation</span>
<span class="c1"># Note: the bilinear arrays being cheap, they  will not be stored but</span>
<span class="c1"># re-computed if needed</span>

<span class="nd">@numba</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">error_model</span><span class="o">=</span><span class="s2">&quot;numpy&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">numba_make_BLA</span><span class="p">(</span><span class="n">Zn_path</span><span class="p">,</span> <span class="n">dfdz</span><span class="p">,</span> <span class="n">kc</span><span class="p">,</span> <span class="n">eps</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a compressed BLA tree with</span>
<span class="sd">    - bilinear approximation coefficients A and B</span>
<span class="sd">    - validaty radius</span>
<span class="sd">        z_n+2**stg = f**stg(z_n, c) with |c| &lt; r_stg_n is approximated by </span>
<span class="sd">        z_n+2**stg = A_stg_n * z_n + B_stg_n * c</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># number of needed &quot;stages&quot; is (ref_orbit_len).bit_length()</span>
    <span class="c1"># number of needed &quot;stages&quot; is (ref_orbit_len).bit_length()</span>
    <span class="n">kc_std</span> <span class="o">=</span> <span class="n">fsxn</span><span class="o">.</span><span class="n">to_standard</span><span class="p">(</span><span class="n">kc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">ref_orbit_len</span> <span class="o">=</span> <span class="n">Zn_path</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Compressed quantities</span>
    <span class="n">k_comp</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">STG_COMPRESSED</span>
    <span class="n">comp_bla_len</span> <span class="o">=</span> <span class="n">ref_orbit_len</span> <span class="o">//</span> <span class="n">k_comp</span>    

    <span class="n">bla_dim</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">M_bla</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">comp_bla_len</span><span class="p">,</span> <span class="n">bla_dim</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numba</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
    <span class="n">r_bla</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">comp_bla_len</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numba</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="c1"># The temporary tree structure to get to the stored index</span>
    <span class="n">temp_M_bla</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">k_comp</span><span class="p">,</span> <span class="n">bla_dim</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numba</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
    <span class="n">temp_r_bla</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">k_comp</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numba</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">temp_M_bla_template</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">temp_M_bla</span><span class="p">)</span>
    <span class="n">temp_r_bla_template</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">temp_r_bla</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">comp_bla_len</span><span class="p">):</span>
        <span class="n">i_0</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="c1"># BLA index for (i, 0)</span>
        <span class="n">temp_M_bla</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">temp_M_bla_template</span><span class="p">)</span>
        <span class="n">temp_r_bla</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">temp_r_bla_template</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">k_comp</span><span class="p">):</span>
            <span class="n">j_0</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">j</span> <span class="c1"># BLA index for (j, 0)</span>

            <span class="c1"># Define a BLA_step by:</span>
            <span class="c1">#       [ M[0]    0     0]          [dzndc]</span>
            <span class="c1">#  M =  [    0 M[0]  M[1]]     Zn = [   zn]</span>
            <span class="c1">#       [    0    0     1]          [    c]</span>
            <span class="c1">#</span>
            <span class="c1">#  Z_(n+1) = M * Zn</span>

            <span class="n">Zn_i</span> <span class="o">=</span> <span class="n">Zn_path</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">k_comp</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span>
            <span class="n">temp_M_bla</span><span class="p">[</span><span class="n">j_0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfdz</span><span class="p">(</span><span class="n">Zn_i</span><span class="p">)</span>
            <span class="n">temp_M_bla</span><span class="p">[</span><span class="n">j_0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
            <span class="n">temp_r_bla</span><span class="p">[</span><span class="n">j_0</span><span class="p">]</span> <span class="o">=</span> <span class="n">eps</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">temp_M_bla</span><span class="p">[</span><span class="n">j_0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="c1"># Combine step for temporary tree &#39;compression&#39;</span>
        <span class="k">for</span> <span class="n">stg</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">STG_COMPRESSED</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">combine_BLA</span><span class="p">(</span><span class="n">temp_M_bla</span><span class="p">,</span> <span class="n">temp_r_bla</span><span class="p">,</span> <span class="n">kc_std</span><span class="p">,</span> <span class="n">stg</span><span class="p">,</span> <span class="n">k_comp</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
        
        <span class="n">stored_index</span> <span class="o">=</span> <span class="n">k_comp</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bla_dim</span><span class="p">):</span>
            <span class="n">M_bla</span><span class="p">[</span><span class="n">i_0</span><span class="p">,</span> <span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp_M_bla</span><span class="p">[</span><span class="n">stored_index</span><span class="p">,</span> <span class="n">d</span><span class="p">]</span>
        <span class="n">r_bla</span><span class="p">[</span><span class="n">i_0</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp_r_bla</span><span class="p">[</span><span class="n">stored_index</span><span class="p">]</span>

    <span class="c1"># Combine step for stored data</span>
    <span class="n">stages</span> <span class="o">=</span> <span class="n">_stages_bla</span><span class="p">(</span><span class="n">ref_orbit_len</span><span class="p">)</span> 
    <span class="k">for</span> <span class="n">stg</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">stages</span> <span class="o">-</span> <span class="n">STG_COMPRESSED</span><span class="p">):</span>
        <span class="n">combine_BLA</span><span class="p">(</span><span class="n">M_bla</span><span class="p">,</span> <span class="n">r_bla</span><span class="p">,</span> <span class="n">kc_std</span><span class="p">,</span> <span class="n">stg</span><span class="p">,</span> <span class="n">comp_bla_len</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">M_bla</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">r_bla</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">comp_bla_len</span><span class="p">,</span> <span class="n">stages</span>


<span class="nd">@numba</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">error_model</span><span class="o">=</span><span class="s2">&quot;numpy&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">numba_make_BLA_BS</span><span class="p">(</span><span class="n">Zn_path</span><span class="p">,</span> <span class="n">dfxdx</span><span class="p">,</span> <span class="n">dfxdy</span><span class="p">,</span> <span class="n">dfydx</span><span class="p">,</span> <span class="n">dfydy</span><span class="p">,</span> <span class="n">kc</span><span class="p">,</span> <span class="n">eps</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a compressed BLA tree with</span>
<span class="sd">    - bilinear approximation coefficients A and B</span>
<span class="sd">    - validaty radius</span>
<span class="sd">        z_n+2**stg = f**stg(z_n, c) with |c| &lt; r_stg_n is approximated by </span>
<span class="sd">        z_n+2**stg = A_stg_n * z_n + B_stg_n * c</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># number of needed &quot;stages&quot; is (ref_orbit_len).bit_length()</span>
    <span class="c1"># number of needed &quot;stages&quot; is (ref_orbit_len).bit_length()</span>
    <span class="n">kc_std</span> <span class="o">=</span> <span class="n">fsxn</span><span class="o">.</span><span class="n">to_standard</span><span class="p">(</span><span class="n">kc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">ref_orbit_len</span> <span class="o">=</span> <span class="n">Zn_path</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Compressed quantities</span>
    <span class="n">k_comp</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">STG_COMPRESSED</span>
    <span class="n">comp_bla_len</span> <span class="o">=</span> <span class="n">ref_orbit_len</span> <span class="o">//</span> <span class="n">k_comp</span>    

    <span class="n">bla_dim</span> <span class="o">=</span> <span class="mi">8</span>
    <span class="n">M_bla</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">comp_bla_len</span><span class="p">,</span> <span class="n">bla_dim</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numba</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">r_bla</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">comp_bla_len</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numba</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="c1"># The temporary tree structure to get to the stored index</span>
    <span class="n">temp_M_bla</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">k_comp</span><span class="p">,</span> <span class="n">bla_dim</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numba</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">temp_r_bla</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">k_comp</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numba</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">temp_M_bla_template</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">temp_M_bla</span><span class="p">)</span>
    <span class="n">temp_r_bla_template</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">temp_r_bla</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">comp_bla_len</span><span class="p">):</span>
        <span class="n">i_0</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="c1"># BLA index for (i, 0)</span>
        <span class="n">temp_M_bla</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">temp_M_bla_template</span><span class="p">)</span>
        <span class="n">temp_r_bla</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">temp_r_bla_template</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">k_comp</span><span class="p">):</span>
            <span class="n">j_0</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">j</span> <span class="c1"># BLA index for (j, 0)</span>
            
            <span class="c1"># Define a BLA_step by:</span>
            <span class="c1">#  Z_(n+1) = M * Zn where</span>
    
            <span class="c1">#       [dxnda]</span>
            <span class="c1">#       [dxndb]</span>
            <span class="c1">#       [dynda]            [  M_0    0     0]</span>
            <span class="c1">#  Zn = [dyndb]       M =  [    0  M_1   M_2] </span>
            <span class="c1">#       [   xn]            [    0    0     I]</span>
            <span class="c1">#       [   yn]</span>
            <span class="c1">#       [    a]</span>
            <span class="c1">#       [    b]</span>
    
            <span class="c1">#        [M[0] 0    M[1] 0   ]</span>
            <span class="c1">#  M_0 = [0    M[0] 0    M[1]]</span>
            <span class="c1">#        [M[2] 0    M[3] 0   ]</span>
            <span class="c1">#        [0    M[2] 0    M[3]]</span>
            <span class="c1">#</span>
            <span class="c1">#  M_1 = [M[0] M[1]]   M_1_init = [dfxdx dfxdy]</span>
            <span class="c1">#        [M[2] M[3]]              [dfydx dfydy]</span>
            <span class="c1">#</span>
            <span class="c1">#  M_2 = [M[4] M[5]]   M_2_init = [1  0]</span>
            <span class="c1">#        [M[6] M[7]]              [0 -1]</span>
    
            <span class="n">Zn_i</span> <span class="o">=</span> <span class="n">Zn_path</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">k_comp</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span>
            <span class="n">Xn_i</span> <span class="o">=</span> <span class="n">Zn_i</span><span class="o">.</span><span class="n">real</span>
            <span class="n">Yn_i</span> <span class="o">=</span> <span class="n">Zn_i</span><span class="o">.</span><span class="n">imag</span>
    
            <span class="n">temp_M_bla</span><span class="p">[</span><span class="n">j_0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfxdx</span><span class="p">(</span><span class="n">Xn_i</span><span class="p">,</span> <span class="n">Yn_i</span><span class="p">)</span>
            <span class="n">temp_M_bla</span><span class="p">[</span><span class="n">j_0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfxdy</span><span class="p">(</span><span class="n">Xn_i</span><span class="p">,</span> <span class="n">Yn_i</span><span class="p">)</span>
            <span class="n">temp_M_bla</span><span class="p">[</span><span class="n">j_0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfydx</span><span class="p">(</span><span class="n">Xn_i</span><span class="p">,</span> <span class="n">Yn_i</span><span class="p">)</span>
            <span class="n">temp_M_bla</span><span class="p">[</span><span class="n">j_0</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfydy</span><span class="p">(</span><span class="n">Xn_i</span><span class="p">,</span> <span class="n">Yn_i</span><span class="p">)</span>
    
            <span class="n">temp_M_bla</span><span class="p">[</span><span class="n">j_0</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
            <span class="n">temp_M_bla</span><span class="p">[</span><span class="n">j_0</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="n">temp_M_bla</span><span class="p">[</span><span class="n">j_0</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="n">temp_M_bla</span><span class="p">[</span><span class="n">j_0</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.</span>

            <span class="n">temp_r_bla</span><span class="p">[</span><span class="n">j_0</span><span class="p">]</span> <span class="o">=</span>  <span class="n">eps</span> <span class="o">*</span> <span class="nb">min</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">Xn_i</span><span class="p">),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">Yn_i</span><span class="p">))</span>  

        <span class="c1"># Combine step for temporary tree &#39;compression&#39;</span>
        <span class="k">for</span> <span class="n">stg</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">STG_COMPRESSED</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">combine_BLA_BS</span><span class="p">(</span><span class="n">temp_M_bla</span><span class="p">,</span> <span class="n">temp_r_bla</span><span class="p">,</span> <span class="n">kc_std</span><span class="p">,</span> <span class="n">stg</span><span class="p">,</span> <span class="n">k_comp</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>

        <span class="n">stored_index</span> <span class="o">=</span> <span class="n">k_comp</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bla_dim</span><span class="p">):</span>
            <span class="n">M_bla</span><span class="p">[</span><span class="n">i_0</span><span class="p">,</span> <span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp_M_bla</span><span class="p">[</span><span class="n">stored_index</span><span class="p">,</span> <span class="n">d</span><span class="p">]</span>
        <span class="n">r_bla</span><span class="p">[</span><span class="n">i_0</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp_r_bla</span><span class="p">[</span><span class="n">stored_index</span><span class="p">]</span>

    <span class="c1"># Combine step for stored data</span>
    <span class="n">stages</span> <span class="o">=</span> <span class="n">_stages_bla</span><span class="p">(</span><span class="n">ref_orbit_len</span><span class="p">)</span> 
    <span class="k">for</span> <span class="n">stg</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">stages</span> <span class="o">-</span> <span class="n">STG_COMPRESSED</span><span class="p">):</span>
        <span class="n">combine_BLA_BS</span><span class="p">(</span><span class="n">M_bla</span><span class="p">,</span> <span class="n">r_bla</span><span class="p">,</span> <span class="n">kc_std</span><span class="p">,</span> <span class="n">stg</span><span class="p">,</span> <span class="n">comp_bla_len</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">M_bla</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">r_bla</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">comp_bla_len</span><span class="p">,</span> <span class="n">stages</span>


<span class="nd">@numba</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_stages_bla</span><span class="p">(</span><span class="n">ref_orbit_len</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    number of needed &quot;stages&quot; (ref_orbit_len).bit_length()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">ref_orbit_len</span><span class="p">)))</span>

<span class="nd">@numba</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">error_model</span><span class="o">=</span><span class="s2">&quot;numpy&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">combine_BLA</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">kc_std</span><span class="p">,</span> <span class="n">stg</span><span class="p">,</span> <span class="n">ref_orbit_len</span><span class="p">,</span> <span class="n">eps</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Populate successive stages of a BLA tree</span>
<span class="sd">    A_bla, B_bla, r_bla : data of the BLA tree</span>
<span class="sd">    kc : majorant of |c|</span>
<span class="sd">    stg : stage of the tree that is populated by merging (stg - 1) items</span>
<span class="sd">    ref_orbit_len : the len for the reference orbit</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Combine all BVA at stage stg-1 to make stage stg with stg &gt; 0</span>
    <span class="n">step</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">stg</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ref_orbit_len</span> <span class="o">-</span> <span class="n">step</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span> <span class="c1"># +1 for power of 2 case</span>
        <span class="n">ii</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">step</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
        <span class="c1"># If ref_orbit_len is not a power of 2, we might get outside the array</span>
        <span class="k">if</span> <span class="n">ii</span> <span class="o">&gt;=</span> <span class="n">ref_orbit_len</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">index1</span> <span class="o">=</span> <span class="n">BLA_index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">stg</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">index2</span> <span class="o">=</span> <span class="n">BLA_index</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="n">stg</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">index_res</span> <span class="o">=</span> <span class="n">BLA_index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">stg</span><span class="p">)</span>

        <span class="c1"># Combines linear approximations</span>
        <span class="c1">#  M_res =  [ M2[0]  M2[1]] * [ M1[0]  M1[1]] </span>
        <span class="c1">#           [     0      1]   [     0      1]</span>
        <span class="n">M</span><span class="p">[</span><span class="n">index_res</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="n">index2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">M</span><span class="p">[</span><span class="n">index1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">M</span><span class="p">[</span><span class="n">index_res</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="n">index2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">M</span><span class="p">[</span><span class="n">index1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">M</span><span class="p">[</span><span class="n">index2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Combines the validity radii</span>
        <span class="n">r1</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">index1</span><span class="p">]</span>
        <span class="n">r2</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">index2</span><span class="p">]</span>
        <span class="c1"># r1 is a direct criteria however for r2 we need to go &#39;backw the flow&#39;</span>
        <span class="c1"># z0 -&gt; z1 -&gt; z2 with z1 = A1 z0 + B1 c, |z1| &lt; r2</span>
        <span class="c1"># Valid if:</span>
        <span class="c1"># |A1 z0| + |B1 c| &lt; r2</span>
        <span class="c1"># |z0| &lt; |r2 - |B1 c|| / |A1|</span>

        <span class="c1"># Note: &quot;Strict inequality factor&quot; of 0.95 is mandatory to pass the</span>
        <span class="c1"># glitch test</span>

        <span class="n">mA1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">index1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">mB1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">index1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">r2_backw</span> <span class="o">=</span> <span class="mf">0.95</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="p">(</span><span class="n">r2</span> <span class="o">-</span> <span class="n">mB1</span> <span class="o">*</span> <span class="n">kc_std</span><span class="p">)</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="n">mA1</span><span class="p">,</span> <span class="n">eps</span><span class="p">))</span>
        <span class="n">r</span><span class="p">[</span><span class="n">index_res</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2_backw</span><span class="p">)</span>


<span class="nd">@numba</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">combine_BLA_BS</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">kc_std</span><span class="p">,</span> <span class="n">stg</span><span class="p">,</span> <span class="n">ref_orbit_len</span><span class="p">,</span> <span class="n">eps</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Populate successive stages of a BLA tree</span>
<span class="sd">    A_bla, B_bla, r_bla : data of the BLA tree</span>
<span class="sd">    kc : majorant of |c|</span>
<span class="sd">    stg : stage of the tree that is populated by merging (stg - 1) items</span>
<span class="sd">    ref_orbit_len : the len for the reference orbit</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Combine all BVA at stage stg-1 to make stage stg with stg &gt; 0</span>
    <span class="n">step</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">stg</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ref_orbit_len</span> <span class="o">-</span> <span class="n">step</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>
        <span class="n">ii</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">step</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
        <span class="c1"># If ref_orbit_len is not a power of 2, we might get outside the array</span>
        <span class="k">if</span> <span class="n">ii</span> <span class="o">&gt;=</span> <span class="n">ref_orbit_len</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">index1</span> <span class="o">=</span> <span class="n">BLA_index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">stg</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">index2</span> <span class="o">=</span> <span class="n">BLA_index</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="n">stg</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">index_res</span> <span class="o">=</span> <span class="n">BLA_index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">stg</span><span class="p">)</span>

        <span class="c1"># Combines linear approximations</span>

        <span class="c1">#  M =  [M2_1   M2_2] x  [M1_1   M1_2]</span>
        <span class="c1">#       [   0      I]    [   0      I]</span>
        <span class="c1">#   Mx_1 = [M[0] M[1]]   Mx_2 = [M[4] M[5]]</span>
        <span class="c1">#          [M[2] M[3]]          [M[6] M[7]] </span>
        <span class="c1">#  Mres_1 = M2_1 * M1_1</span>
        <span class="c1">#  Mres_2 = M2_1 * M1_1 + M2_2</span>

        <span class="c1"># Mres_1 = M2_1 * M1_1 :</span>
        <span class="n">M</span><span class="p">[</span><span class="n">index_res</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">M</span><span class="p">[</span><span class="n">index2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">M</span><span class="p">[</span><span class="n">index1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">M</span><span class="p">[</span><span class="n">index2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">M</span><span class="p">[</span><span class="n">index1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">M</span><span class="p">[</span><span class="n">index_res</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">M</span><span class="p">[</span><span class="n">index2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">M</span><span class="p">[</span><span class="n">index1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">M</span><span class="p">[</span><span class="n">index2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">M</span><span class="p">[</span><span class="n">index1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">M</span><span class="p">[</span><span class="n">index_res</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">M</span><span class="p">[</span><span class="n">index2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">M</span><span class="p">[</span><span class="n">index1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">M</span><span class="p">[</span><span class="n">index2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="n">M</span><span class="p">[</span><span class="n">index1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">M</span><span class="p">[</span><span class="n">index_res</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">M</span><span class="p">[</span><span class="n">index2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">M</span><span class="p">[</span><span class="n">index1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">M</span><span class="p">[</span><span class="n">index2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="n">M</span><span class="p">[</span><span class="n">index1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="c1">#  Mres_2 = M2_1 * M1_1 + M2_2</span>
        <span class="n">M</span><span class="p">[</span><span class="n">index_res</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">M</span><span class="p">[</span><span class="n">index2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">M</span><span class="p">[</span><span class="n">index1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="n">M</span><span class="p">[</span><span class="n">index2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">M</span><span class="p">[</span><span class="n">index1</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
            <span class="o">+</span> <span class="n">M</span><span class="p">[</span><span class="n">index2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">M</span><span class="p">[</span><span class="n">index_res</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">M</span><span class="p">[</span><span class="n">index2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">M</span><span class="p">[</span><span class="n">index1</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span> <span class="o">+</span> <span class="n">M</span><span class="p">[</span><span class="n">index2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">M</span><span class="p">[</span><span class="n">index1</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
            <span class="o">+</span> <span class="n">M</span><span class="p">[</span><span class="n">index2</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">M</span><span class="p">[</span><span class="n">index_res</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">M</span><span class="p">[</span><span class="n">index2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">M</span><span class="p">[</span><span class="n">index1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="n">M</span><span class="p">[</span><span class="n">index2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="n">M</span><span class="p">[</span><span class="n">index1</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
            <span class="o">+</span> <span class="n">M</span><span class="p">[</span><span class="n">index2</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">M</span><span class="p">[</span><span class="n">index_res</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">M</span><span class="p">[</span><span class="n">index2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">M</span><span class="p">[</span><span class="n">index1</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span> <span class="o">+</span> <span class="n">M</span><span class="p">[</span><span class="n">index2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="n">M</span><span class="p">[</span><span class="n">index1</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
            <span class="o">+</span> <span class="n">M</span><span class="p">[</span><span class="n">index2</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># Combines the validity radii</span>
        <span class="n">r1</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">index1</span><span class="p">]</span>
        <span class="n">r2</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">index2</span><span class="p">]</span>
        <span class="c1"># r1 is a direct criteria however for r2 we need to go &#39;backw the flow&#39;</span>
        <span class="c1"># z0 -&gt; z1 -&gt; z2 with z1 = A1 z0 + B1 c, |z1| &lt; r2</span>
        <span class="n">mA1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">index1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> 
            <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">index1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">index1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span> 
            <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">index1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]),</span>
        <span class="p">)</span>
        <span class="n">mB1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">index1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]),</span> 
            <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">index1</span><span class="p">,</span> <span class="mi">5</span><span class="p">]),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">index1</span><span class="p">,</span> <span class="mi">6</span><span class="p">]),</span> 
            <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">index1</span><span class="p">,</span> <span class="mi">7</span><span class="p">]),</span>
        <span class="p">)</span>
        <span class="n">r2_backw</span> <span class="o">=</span> <span class="mf">0.95</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="p">(</span><span class="n">r2</span> <span class="o">-</span> <span class="n">mB1</span> <span class="o">*</span> <span class="n">kc_std</span><span class="p">)</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="n">mA1</span><span class="p">,</span> <span class="n">eps</span><span class="p">))</span>
        <span class="n">r</span><span class="p">[</span><span class="n">index_res</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2_backw</span><span class="p">)</span>


<span class="nd">@numba</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">BLA_index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">stg</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the indices in BLA table for this iteration and stage</span>
<span class="sd">    this is the jump from i to j = i + (1 &lt;&lt; stg)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">stg</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

<span class="nd">@numba</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">ref_BLA_get</span><span class="p">(</span><span class="n">M_bla</span><span class="p">,</span> <span class="n">r_bla</span><span class="p">,</span> <span class="n">bla_len</span><span class="p">,</span> <span class="n">stages_bla</span><span class="p">,</span> <span class="n">zn</span><span class="p">,</span> <span class="n">n_iter</span><span class="p">,</span>
                <span class="n">first_invalid_index</span><span class="p">,</span> <span class="n">M_out</span><span class="p">,</span> <span class="n">holomorphic</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Paramters:</span>
<span class="sd">    ----------</span>
<span class="sd">    A_bla, B_bla, r_bla: arrays</span>
<span class="sd">        Bilinear approx tree</span>
<span class="sd">    zn :</span>
<span class="sd">        The current value of dz</span>
<span class="sd">    n_iter :</span>
<span class="sd">        The current iteration for ref pt</span>
<span class="sd">    M_out :</span>
<span class="sd">        Container for the Bla coefficient</span>
<span class="sd">    holomorphic: boolean</span>
<span class="sd">        True if the base function is holomorphic</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">     step</span>
<span class="sd">         The interation &quot;jump&quot; provided by this linear interpolation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">k_comp</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">STG_COMPRESSED</span><span class="p">)</span>
    <span class="n">_iter</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_iter</span> <span class="o">&gt;&gt;</span> <span class="n">STG_COMPRESSED</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">stages</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">STG_COMPRESSED</span><span class="p">,</span> <span class="n">stages_bla</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">_iter</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">_iter</span> <span class="o">=</span> <span class="n">_iter</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>

    <span class="c1"># The first invalid step /!\</span>
    <span class="n">invalid_step</span> <span class="o">=</span> <span class="n">first_invalid_index</span> <span class="o">-</span> <span class="n">n_iter</span> 

    <span class="c1"># numba version of reversed(range(stages_bla)):</span>
    <span class="k">for</span> <span class="n">stg</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">stages</span><span class="p">,</span> <span class="n">STG_COMPRESSED</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">step</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">stg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">step</span> <span class="o">&gt;=</span> <span class="n">invalid_step</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">index_bla</span> <span class="o">=</span> <span class="n">BLA_index</span><span class="p">(</span><span class="n">n_iter</span> <span class="o">//</span> <span class="n">k_comp</span><span class="p">,</span> <span class="n">stg</span> <span class="o">-</span> <span class="n">STG_COMPRESSED</span><span class="p">)</span>

        <span class="n">r</span> <span class="o">=</span> <span class="n">r_bla</span><span class="p">[</span><span class="n">index_bla</span><span class="p">]</span>
        <span class="c1"># /!\ Use strict comparisons here: to rule out underflow</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">zn</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">holomorphic</span><span class="p">:</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">index_bla</span>
                <span class="n">M_out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">M_bla</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span>
                <span class="n">M_out</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">M_bla</span><span class="p">[</span><span class="n">loc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

                <span class="k">return</span> <span class="n">step</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">):</span>
                    <span class="n">loc</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">index_bla</span>
                    <span class="n">M_out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">M_bla</span><span class="p">[</span><span class="n">loc</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span>

                <span class="k">return</span> <span class="n">step</span>
    <span class="k">return</span> <span class="mi">0</span> <span class="c1"># No BLA applicable</span>

<span class="nd">@numba</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">need_xr</span><span class="p">(</span><span class="n">x_std</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    True if norm L-inf of std is lower than xrange_zoom_level</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">x_std</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">fs</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">xrange_zoom_level</span><span class="p">)</span>
         <span class="ow">and</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">x_std</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">fs</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">xrange_zoom_level</span><span class="p">)</span>
    <span class="p">)</span>

<span class="nd">@numba</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">ensure_xr</span><span class="p">(</span><span class="n">val_std</span><span class="p">,</span> <span class="n">val_xr</span><span class="p">,</span> <span class="n">is_xr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a valid Xrange. if not(Z_xr_trigger) we return x_std</span>
<span class="sd">    converted</span>
<span class="sd">    </span>
<span class="sd">    val_xr : complex128_Xrange_scalar or float64_Xrange_scalar</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">is_xr</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fsxn</span><span class="o">.</span><span class="n">to_Xrange_scalar</span><span class="p">(</span><span class="n">val_xr</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fsxn</span><span class="o">.</span><span class="n">to_Xrange_scalar</span><span class="p">(</span><span class="n">val_std</span><span class="p">)</span>

<span class="nd">@numba</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">ensure_xr_BS</span><span class="p">(</span><span class="n">val_std</span><span class="p">,</span> <span class="n">valx_xr</span><span class="p">,</span> <span class="n">valy_xr</span><span class="p">,</span> <span class="n">is_xr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a valid Xrange. if not(Z_xr_trigger) we return x_std</span>
<span class="sd">    converted</span>
<span class="sd">    </span>
<span class="sd">    val_xr : complex128_Xrange_scalar or float64_Xrange_scalar</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">is_xr</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">fsxn</span><span class="o">.</span><span class="n">to_Xrange_scalar</span><span class="p">(</span><span class="n">valx_xr</span><span class="p">),</span>
            <span class="n">fsxn</span><span class="o">.</span><span class="n">to_Xrange_scalar</span><span class="p">(</span><span class="n">valy_xr</span><span class="p">),</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">fsxn</span><span class="o">.</span><span class="n">to_Xrange_scalar</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">val_std</span><span class="p">)),</span>
            <span class="n">fsxn</span><span class="o">.</span><span class="n">to_Xrange_scalar</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">val_std</span><span class="p">))</span>
        <span class="p">)</span>

<span class="nd">@numba</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">ref_path_c_from_pix</span><span class="p">(</span><span class="n">pix</span><span class="p">,</span> <span class="n">proj_impl</span><span class="p">,</span> <span class="n">lin_mat</span><span class="p">,</span> <span class="n">lin_scale_xr</span><span class="p">,</span> <span class="n">drift_xr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the true c (coords from ref point) from the pixel coords</span>
<span class="sd">    ie c = C - refp</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pix :  complex</span>
<span class="sd">        pixel location in fraction of dx</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    c, c_xr : c value as complex and as Xrange</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">c_xr</span> <span class="o">=</span> <span class="n">lin_proj_impl</span><span class="p">(</span><span class="n">lin_mat</span><span class="p">,</span> <span class="n">lin_scale_xr</span><span class="p">,</span> <span class="n">proj_impl</span><span class="p">(</span><span class="n">pix</span><span class="p">))</span> <span class="o">+</span> <span class="n">drift_xr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">fsxn</span><span class="o">.</span><span class="n">to_standard</span><span class="p">(</span><span class="n">c_xr</span><span class="p">),</span> <span class="n">c_xr</span>


<span class="nd">@numba</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">std_C_from_pix</span><span class="p">(</span><span class="n">pix</span><span class="p">,</span> <span class="n">proj_impl</span><span class="p">,</span> <span class="n">lin_mat</span><span class="p">,</span> <span class="n">lin_scale_std</span><span class="p">,</span> <span class="n">center</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the true C (C = cref + dc) from the pixel coords</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pix :  complex</span>
<span class="sd">        pixel location in fraction of dx</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    C : Full C value, as complex</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">center</span> <span class="o">+</span> <span class="n">lin_proj_impl</span><span class="p">(</span><span class="n">lin_mat</span><span class="p">,</span> <span class="n">lin_scale_std</span><span class="p">,</span> <span class="n">proj_impl</span><span class="p">(</span><span class="n">pix</span><span class="p">))</span>


<span class="nd">@numba</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">fill1d_std_C_from_pix</span><span class="p">(</span>
        <span class="n">c_pix</span><span class="p">,</span> <span class="n">proj_impl</span><span class="p">,</span> <span class="n">lin_mat</span><span class="p">,</span> <span class="n">lin_scale_std</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">c_out</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; same as std_C_from_pix but fills in-place a 1d vec &quot;&quot;&quot;</span>
    <span class="n">nx</span> <span class="o">=</span> <span class="n">c_pix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nx</span><span class="p">):</span>
        <span class="n">c_out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">std_C_from_pix</span><span class="p">(</span>
            <span class="n">c_pix</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">proj_impl</span><span class="p">,</span> <span class="n">lin_mat</span><span class="p">,</span> <span class="n">lin_scale_std</span><span class="p">,</span> <span class="n">center</span>
        <span class="p">)</span>

<span class="nd">@numba</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">ref_path_c_from_pix_BS</span><span class="p">(</span>
        <span class="n">pix</span><span class="p">,</span> <span class="n">proj_impl</span><span class="p">,</span> <span class="n">lin_mat</span><span class="p">,</span> <span class="n">lin_scale_xr</span><span class="p">,</span> <span class="n">driftx_xr</span><span class="p">,</span> <span class="n">drifty_xr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the true a + i b (coords from ref point) from the pixel coords</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pix :  complex</span>
<span class="sd">        pixel location in fraction of dx</span>
<span class="sd">    dx : Xrange float</span>
<span class="sd">        width of the image</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    a, b, a_xr, b_xr : c value as complex and as Xrange</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">c_xr</span> <span class="o">=</span> <span class="n">lin_proj_impl</span><span class="p">(</span><span class="n">lin_mat</span><span class="p">,</span> <span class="n">lin_scale_xr</span><span class="p">,</span> <span class="n">proj_impl</span><span class="p">(</span><span class="n">pix</span><span class="p">))</span>
    <span class="n">a_xr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">c_xr</span><span class="p">)</span> <span class="o">+</span> <span class="n">driftx_xr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">b_xr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">c_xr</span><span class="p">)</span> <span class="o">+</span> <span class="n">drifty_xr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">fsxn</span><span class="o">.</span><span class="n">to_standard</span><span class="p">(</span><span class="n">a_xr</span><span class="p">),</span> <span class="n">fsxn</span><span class="o">.</span><span class="n">to_standard</span><span class="p">(</span><span class="n">b_xr</span><span class="p">),</span> <span class="n">a_xr</span><span class="p">,</span> <span class="n">b_xr</span>

<span class="nd">@numba</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">numba_dZndc_path</span><span class="p">(</span><span class="n">Zn_path</span><span class="p">,</span> <span class="n">has_xr</span><span class="p">,</span> <span class="n">ref_index_xr</span><span class="p">,</span> <span class="n">ref_xr</span><span class="p">,</span>
                    <span class="n">ref_div_iter</span><span class="p">,</span> <span class="n">ref_order</span><span class="p">,</span> <span class="n">dfdz</span><span class="p">,</span>
                    <span class="n">scale_deriv_xr</span><span class="p">,</span> <span class="n">xr_detect_activated</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute dZndc in Xr, or std precision, depending on xr_detect_activated</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Development note: the dx_xr which is imposed at each step</span>
    <span class="c1"># imposes the deivative scaling</span>
    <span class="n">ref_orbit_len</span> <span class="o">=</span> <span class="n">Zn_path</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">valid_pts</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">ref_orbit_len</span><span class="p">,</span> <span class="n">ref_div_iter</span><span class="p">)</span>

    <span class="n">xr_act</span> <span class="o">=</span> <span class="n">xr_detect_activated</span>
    <span class="c1"># dx = fsxn.to_standard(dx_xr[0])</span>
    <span class="n">scale_deriv</span> <span class="o">=</span> <span class="n">fsxn</span><span class="o">.</span><span class="n">to_standard</span><span class="p">(</span><span class="n">scale_deriv_xr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">xr_act</span><span class="p">:</span>
        <span class="n">dZndc_path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numba</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span> <span class="c1"># dummy</span>
        <span class="n">dZndc_xr_path</span> <span class="o">=</span> <span class="n">Xr_template</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">ref_orbit_len</span><span class="p">)</span> 

        <span class="n">refpath_ptr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numba</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">out_is_xr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numba</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
        <span class="n">out_xr</span> <span class="o">=</span> <span class="n">Xr_template</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">valid_pts</span><span class="p">):</span>
            <span class="n">ref_zn</span> <span class="o">=</span> <span class="n">ref_path_get</span><span class="p">(</span>
                <span class="n">Zn_path</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                <span class="n">has_xr</span><span class="p">,</span> <span class="n">ref_index_xr</span><span class="p">,</span> <span class="n">ref_xr</span><span class="p">,</span> <span class="n">refpath_ptr</span><span class="p">,</span>
                <span class="n">out_is_xr</span><span class="p">,</span> <span class="n">out_xr</span><span class="p">,</span> <span class="mi">0</span>
            <span class="p">)</span>
            <span class="n">ref_zn_xr</span> <span class="o">=</span> <span class="n">ensure_xr</span><span class="p">(</span><span class="n">ref_zn</span><span class="p">,</span> <span class="n">out_xr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">out_is_xr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">dZndc_xr_path</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfdz</span><span class="p">(</span><span class="n">ref_zn_xr</span><span class="p">)</span> <span class="o">*</span> <span class="n">dZndc_xr_path</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">scale_deriv_xr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> 

        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">ref_order</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># /!\ We have a cycle, use the &quot;wrapped&quot; value at 0</span>
            <span class="c1"># Note that this value will be used... a lot !</span>
            <span class="n">ref_zn</span> <span class="o">=</span> <span class="n">ref_path_get</span><span class="p">(</span>
                <span class="n">Zn_path</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
                <span class="n">has_xr</span><span class="p">,</span> <span class="n">ref_index_xr</span><span class="p">,</span> <span class="n">ref_xr</span><span class="p">,</span> <span class="n">refpath_ptr</span><span class="p">,</span>
                <span class="n">out_is_xr</span><span class="p">,</span> <span class="n">out_xr</span><span class="p">,</span> <span class="mi">0</span>
            <span class="p">)</span>
            <span class="n">ref_zn_xr</span> <span class="o">=</span> <span class="n">ensure_xr</span><span class="p">(</span><span class="n">ref_zn</span><span class="p">,</span> <span class="n">out_xr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">out_is_xr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">dZndc_xr_path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfdz</span><span class="p">(</span><span class="n">Zn_path</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="n">dZndc_xr_path</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">scale_deriv_xr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># Note: the wraped is [0] !!</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">dZndc_path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ref_orbit_len</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numba</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
        <span class="n">dZndc_xr_path</span> <span class="o">=</span> <span class="n">Xr_template</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># dummy</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">valid_pts</span><span class="p">):</span>
            <span class="n">dZndc_path</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfdz</span><span class="p">(</span><span class="n">Zn_path</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">dZndc_path</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">scale_deriv</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">ref_order</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># /!\ We have a cycle, use the &quot;wrapped&quot; value at 0</span>
            <span class="c1"># Note that this value will be used... a lot !</span>
            <span class="n">dZndc_path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfdz</span><span class="p">(</span><span class="n">Zn_path</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="n">dZndc_path</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">scale_deriv</span> <span class="c1"># Note: the wraped is [0] !!</span>

    <span class="k">return</span> <span class="n">dZndc_path</span><span class="p">,</span> <span class="n">dZndc_xr_path</span>


<span class="nd">@numba</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">numba_dZndc_path_BS</span><span class="p">(</span><span class="n">Zn_path</span><span class="p">,</span> <span class="n">has_xr</span><span class="p">,</span> <span class="n">ref_index_xr</span><span class="p">,</span> <span class="n">refx_xr</span><span class="p">,</span> <span class="n">refy_xr</span><span class="p">,</span>
                    <span class="n">ref_div_iter</span><span class="p">,</span> <span class="n">ref_order</span><span class="p">,</span> <span class="n">dfxdx</span><span class="p">,</span> <span class="n">dfxdy</span><span class="p">,</span> <span class="n">dfydx</span><span class="p">,</span> <span class="n">dfydy</span><span class="p">,</span>
                    <span class="n">scale_deriv_xr</span><span class="p">,</span> <span class="n">xr_detect_activated</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute dXndb, dXnda, dYnda , dYndb in Xr, or std precision, depending on</span>
<span class="sd">    xr_detect_activated</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ref_orbit_len</span> <span class="o">=</span> <span class="n">Zn_path</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">valid_pts</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">ref_orbit_len</span><span class="p">,</span> <span class="n">ref_div_iter</span><span class="p">)</span>
    <span class="n">scale_deriv</span> <span class="o">=</span> <span class="n">fsxn</span><span class="o">.</span><span class="n">to_standard</span><span class="p">(</span><span class="n">scale_deriv_xr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">xr_detect_activated</span><span class="p">:</span>
        <span class="n">dXnda_path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numba</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="c1"># dummy</span>
        <span class="n">dXndb_path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numba</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="c1"># dummy</span>
        <span class="n">dYnda_path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numba</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="c1"># dummy</span>
        <span class="n">dYndb_path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numba</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="c1"># dummy</span>
        <span class="n">dXnda_xr_path</span> <span class="o">=</span> <span class="n">Xr_float_template</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">ref_orbit_len</span><span class="p">)</span> 
        <span class="n">dXndb_xr_path</span> <span class="o">=</span> <span class="n">Xr_float_template</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">ref_orbit_len</span><span class="p">)</span> 
        <span class="n">dYnda_xr_path</span> <span class="o">=</span> <span class="n">Xr_float_template</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">ref_orbit_len</span><span class="p">)</span> 
        <span class="n">dYndb_xr_path</span> <span class="o">=</span> <span class="n">Xr_float_template</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">ref_orbit_len</span><span class="p">)</span> 

        <span class="n">refpath_ptr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numba</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">out_is_xr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numba</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
        <span class="n">out_xr</span> <span class="o">=</span> <span class="n">Xr_float_template</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># coord X, coord Y</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">valid_pts</span><span class="p">):</span>
            <span class="n">from_i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">to_i</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">ref_zn</span> <span class="o">=</span> <span class="n">ref_path_get_BS</span><span class="p">(</span>
                <span class="n">Zn_path</span><span class="p">,</span><span class="n">from_i</span><span class="p">,</span>
                <span class="n">has_xr</span><span class="p">,</span> <span class="n">ref_index_xr</span><span class="p">,</span> <span class="n">refx_xr</span><span class="p">,</span> <span class="n">refy_xr</span><span class="p">,</span> <span class="n">refpath_ptr</span><span class="p">,</span>
                <span class="n">out_is_xr</span><span class="p">,</span> <span class="n">out_xr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
            <span class="p">)</span>
            <span class="n">ref_xn_xr</span><span class="p">,</span> <span class="n">ref_yn_xr</span> <span class="o">=</span> <span class="n">ensure_xr_BS</span><span class="p">(</span>
                <span class="n">ref_zn</span><span class="p">,</span> <span class="n">out_xr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">out_xr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">out_is_xr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">incr_deriv_ref_BS</span><span class="p">(</span>
                <span class="n">dXnda_xr_path</span><span class="p">,</span> <span class="n">dXndb_xr_path</span><span class="p">,</span> <span class="n">dYnda_xr_path</span><span class="p">,</span> <span class="n">dYndb_xr_path</span><span class="p">,</span>
                <span class="n">from_i</span><span class="p">,</span> <span class="n">to_i</span><span class="p">,</span> <span class="n">scale_deriv_xr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">ref_xn_xr</span><span class="p">,</span> <span class="n">ref_yn_xr</span><span class="p">,</span> <span class="n">dfxdx</span><span class="p">,</span> <span class="n">dfxdy</span><span class="p">,</span> <span class="n">dfydx</span><span class="p">,</span> <span class="n">dfydy</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">ref_order</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># /!\ We have a cycle, use the &quot;wrapped&quot; value at 0</span>
            <span class="c1"># Note that this value will be used... a lot !</span>
            <span class="n">from_i</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">to_i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">ref_zn</span> <span class="o">=</span> <span class="n">ref_path_get_BS</span><span class="p">(</span>
                <span class="n">Zn_path</span><span class="p">,</span> <span class="n">from_i</span><span class="p">,</span>
                <span class="n">has_xr</span><span class="p">,</span> <span class="n">ref_index_xr</span><span class="p">,</span> <span class="n">refx_xr</span><span class="p">,</span> <span class="n">refy_xr</span><span class="p">,</span> <span class="n">refpath_ptr</span><span class="p">,</span>
                <span class="n">out_is_xr</span><span class="p">,</span> <span class="n">out_xr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
            <span class="p">)</span>
            <span class="n">ref_xn_xr</span><span class="p">,</span> <span class="n">ref_yn_xr</span> <span class="o">=</span> <span class="n">ensure_xr_BS</span><span class="p">(</span>
                <span class="n">ref_zn</span><span class="p">,</span> <span class="n">out_xr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">out_xr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">out_is_xr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">incr_deriv_ref_BS</span><span class="p">(</span>
                <span class="n">dXnda_xr_path</span><span class="p">,</span> <span class="n">dXndb_xr_path</span><span class="p">,</span> <span class="n">dYnda_xr_path</span><span class="p">,</span> <span class="n">dYndb_xr_path</span><span class="p">,</span>
                <span class="n">from_i</span><span class="p">,</span> <span class="n">to_i</span><span class="p">,</span> <span class="n">scale_deriv_xr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">ref_xn_xr</span><span class="p">,</span> <span class="n">ref_yn_xr</span><span class="p">,</span> <span class="n">dfxdx</span><span class="p">,</span> <span class="n">dfxdy</span><span class="p">,</span> <span class="n">dfydx</span><span class="p">,</span> <span class="n">dfydy</span>
            <span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">dXnda_path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ref_orbit_len</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numba</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">dXndb_path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ref_orbit_len</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numba</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">dYnda_path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ref_orbit_len</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numba</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">dYndb_path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ref_orbit_len</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numba</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">dXnda_xr_path</span> <span class="o">=</span> <span class="n">Xr_float_template</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># dummy</span>
        <span class="n">dXndb_xr_path</span> <span class="o">=</span> <span class="n">Xr_float_template</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># dummy</span>
        <span class="n">dYnda_xr_path</span> <span class="o">=</span> <span class="n">Xr_float_template</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># dummy</span>
        <span class="n">dYndb_xr_path</span> <span class="o">=</span> <span class="n">Xr_float_template</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># dummy</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">valid_pts</span><span class="p">):</span>
            <span class="n">from_i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">to_i</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">Xn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">Zn_path</span><span class="p">[</span><span class="n">from_i</span><span class="p">])</span> <span class="c1">#.real</span>
            <span class="n">Yn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">Zn_path</span><span class="p">[</span><span class="n">from_i</span><span class="p">])</span> <span class="c1">#.imag</span>
            <span class="n">incr_deriv_ref_BS</span><span class="p">(</span>
                <span class="n">dXnda_path</span><span class="p">,</span> <span class="n">dXndb_path</span><span class="p">,</span> <span class="n">dYnda_path</span><span class="p">,</span> <span class="n">dYndb_path</span><span class="p">,</span>
                <span class="n">from_i</span><span class="p">,</span> <span class="n">to_i</span><span class="p">,</span> <span class="n">scale_deriv</span><span class="p">,</span>
                <span class="n">Xn</span><span class="p">,</span> <span class="n">Yn</span><span class="p">,</span> <span class="n">dfxdx</span><span class="p">,</span> <span class="n">dfxdy</span><span class="p">,</span> <span class="n">dfydx</span><span class="p">,</span> <span class="n">dfydy</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">ref_order</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># /!\ We have a cycle, use the &quot;wrapped&quot; value at 0</span>
            <span class="c1"># Note that this value will be used... a lot !</span>
            <span class="n">from_i</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">to_i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">Xn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">Zn_path</span><span class="p">[</span><span class="n">from_i</span><span class="p">])</span> <span class="c1">#.real</span>
            <span class="n">Yn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">Zn_path</span><span class="p">[</span><span class="n">from_i</span><span class="p">])</span> <span class="c1">#.imag</span>
            <span class="n">incr_deriv_ref_BS</span><span class="p">(</span>
                <span class="n">dXnda_path</span><span class="p">,</span> <span class="n">dXndb_path</span><span class="p">,</span> <span class="n">dYnda_path</span><span class="p">,</span> <span class="n">dYndb_path</span><span class="p">,</span>
                <span class="n">from_i</span><span class="p">,</span> <span class="n">to_i</span><span class="p">,</span> <span class="n">scale_deriv</span><span class="p">,</span>
                <span class="n">Xn</span><span class="p">,</span> <span class="n">Yn</span><span class="p">,</span> <span class="n">dfxdx</span><span class="p">,</span> <span class="n">dfxdy</span><span class="p">,</span> <span class="n">dfydx</span><span class="p">,</span> <span class="n">dfydy</span>
            <span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span>
        <span class="n">dXnda_path</span><span class="p">,</span> <span class="n">dXndb_path</span><span class="p">,</span> <span class="n">dYnda_path</span><span class="p">,</span> <span class="n">dYndb_path</span><span class="p">,</span>
        <span class="n">dXnda_xr_path</span><span class="p">,</span> <span class="n">dXndb_xr_path</span><span class="p">,</span> <span class="n">dYnda_xr_path</span><span class="p">,</span> <span class="n">dYndb_xr_path</span>
    <span class="p">)</span>

<span class="nd">@numba</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">incr_deriv_ref_BS</span><span class="p">(</span>
    <span class="n">dXnda_path</span><span class="p">,</span> <span class="n">dXndb_path</span><span class="p">,</span> <span class="n">dYnda_path</span><span class="p">,</span> <span class="n">dYndb_path</span><span class="p">,</span>
    <span class="n">from_i</span><span class="p">,</span> <span class="n">to_i</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span>
    <span class="n">Xn</span><span class="p">,</span> <span class="n">Yn</span><span class="p">,</span> <span class="n">dfxdx</span><span class="p">,</span> <span class="n">dfxdy</span><span class="p">,</span> <span class="n">dfydx</span><span class="p">,</span> <span class="n">dfydy</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    H = [dfxdx dfxdy]    [dfx] = H x [dx]</span>
<span class="sd">        [dfydx dfydy]    [dfy]       [dy]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dfxdx</span> <span class="o">=</span> <span class="n">dfxdx</span><span class="p">(</span><span class="n">Xn</span><span class="p">,</span> <span class="n">Yn</span><span class="p">)</span>
    <span class="n">dfxdy</span> <span class="o">=</span> <span class="n">dfxdy</span><span class="p">(</span><span class="n">Xn</span><span class="p">,</span> <span class="n">Yn</span><span class="p">)</span>
    <span class="n">dfydx</span> <span class="o">=</span> <span class="n">dfydx</span><span class="p">(</span><span class="n">Xn</span><span class="p">,</span> <span class="n">Yn</span><span class="p">)</span>
    <span class="n">dfydy</span> <span class="o">=</span> <span class="n">dfydy</span><span class="p">(</span><span class="n">Xn</span><span class="p">,</span> <span class="n">Yn</span><span class="p">)</span>

    <span class="n">dXnda</span> <span class="o">=</span> <span class="n">dXnda_path</span><span class="p">[</span><span class="n">from_i</span><span class="p">]</span>
    <span class="n">dXndb</span> <span class="o">=</span> <span class="n">dXndb_path</span><span class="p">[</span><span class="n">from_i</span><span class="p">]</span>
    <span class="n">dYnda</span> <span class="o">=</span> <span class="n">dYnda_path</span><span class="p">[</span><span class="n">from_i</span><span class="p">]</span>
    <span class="n">dYndb</span> <span class="o">=</span> <span class="n">dYndb_path</span><span class="p">[</span><span class="n">from_i</span><span class="p">]</span>

    <span class="n">dXnda_path</span><span class="p">[</span><span class="n">to_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfxdx</span> <span class="o">*</span> <span class="n">dXnda</span> <span class="o">+</span> <span class="n">dfxdy</span> <span class="o">*</span> <span class="n">dYnda</span> <span class="o">+</span> <span class="n">dx</span>
    <span class="n">dXndb_path</span><span class="p">[</span><span class="n">to_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfxdx</span> <span class="o">*</span> <span class="n">dXndb</span> <span class="o">+</span> <span class="n">dfxdy</span> <span class="o">*</span> <span class="n">dYndb</span>
    <span class="n">dYnda_path</span><span class="p">[</span><span class="n">to_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfydx</span> <span class="o">*</span> <span class="n">dXnda</span> <span class="o">+</span> <span class="n">dfydy</span> <span class="o">*</span> <span class="n">dYnda</span>
    <span class="n">dYndb_path</span><span class="p">[</span><span class="n">to_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfydx</span> <span class="o">*</span> <span class="n">dXndb</span> <span class="o">+</span> <span class="n">dfydy</span> <span class="o">*</span> <span class="n">dYndb</span> <span class="o">-</span> <span class="n">dx</span>


<span class="nd">@numba</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">numba_dZndz_path</span><span class="p">(</span><span class="n">Zn_path</span><span class="p">,</span> <span class="n">has_xr</span><span class="p">,</span> <span class="n">ref_index_xr</span><span class="p">,</span> <span class="n">ref_xr</span><span class="p">,</span>
                    <span class="n">ref_div_iter</span><span class="p">,</span> <span class="n">ref_order</span><span class="p">,</span> <span class="n">dfdz</span><span class="p">,</span> <span class="n">xr_detect_activated</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute dZndz in Xr, or std precision, depending on xr_detect_activated</span>
<span class="sd">    Same as dZndc except the +dx is missing</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ref_orbit_len</span> <span class="o">=</span> <span class="n">Zn_path</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">valid_pts</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">ref_orbit_len</span><span class="p">,</span> <span class="n">ref_div_iter</span><span class="p">)</span>

    <span class="n">xr_act</span> <span class="o">=</span> <span class="n">xr_detect_activated</span>

    <span class="k">if</span> <span class="n">xr_act</span><span class="p">:</span>
        <span class="n">dZndz_path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numba</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span> <span class="c1"># dummy</span>
        <span class="n">dZndz_xr_path</span> <span class="o">=</span> <span class="n">Xr_template</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">ref_orbit_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">dZndz_xr_path</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">fsxn</span><span class="o">.</span><span class="n">one</span><span class="p">()</span>

        <span class="n">refpath_ptr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numba</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">out_is_xr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numba</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
        <span class="n">out_xr</span> <span class="o">=</span> <span class="n">Xr_template</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">valid_pts</span><span class="p">):</span>
            <span class="n">ref_zn</span> <span class="o">=</span> <span class="n">ref_path_get</span><span class="p">(</span>
                <span class="n">Zn_path</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                <span class="n">has_xr</span><span class="p">,</span> <span class="n">ref_index_xr</span><span class="p">,</span> <span class="n">ref_xr</span><span class="p">,</span> <span class="n">refpath_ptr</span><span class="p">,</span>
                <span class="n">out_is_xr</span><span class="p">,</span> <span class="n">out_xr</span><span class="p">,</span> <span class="mi">0</span>
            <span class="p">)</span>
            <span class="n">ref_zn_xr</span> <span class="o">=</span> <span class="n">ensure_xr</span><span class="p">(</span><span class="n">ref_zn</span><span class="p">,</span> <span class="n">out_xr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">out_is_xr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">dZndz_xr_path</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfdz</span><span class="p">(</span><span class="n">ref_zn_xr</span><span class="p">)</span> <span class="o">*</span> <span class="n">dZndz_xr_path</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

        <span class="c1"># /!\ Store the &quot;wrapped&quot; value at last pos</span>
        <span class="n">ref_zn</span> <span class="o">=</span> <span class="n">ref_path_get</span><span class="p">(</span>
            <span class="n">Zn_path</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
            <span class="n">has_xr</span><span class="p">,</span> <span class="n">ref_index_xr</span><span class="p">,</span> <span class="n">ref_xr</span><span class="p">,</span> <span class="n">refpath_ptr</span><span class="p">,</span>
            <span class="n">out_is_xr</span><span class="p">,</span> <span class="n">out_xr</span><span class="p">,</span> <span class="mi">0</span>
        <span class="p">)</span>
        <span class="n">ref_zn_xr</span> <span class="o">=</span> <span class="n">ensure_xr</span><span class="p">(</span><span class="n">ref_zn</span><span class="p">,</span> <span class="n">out_xr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">out_is_xr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">dZndz_xr_path</span><span class="p">[</span><span class="n">ref_orbit_len</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfdz</span><span class="p">(</span><span class="n">ref_zn_xr</span><span class="p">)</span> <span class="o">*</span> <span class="n">dZndz_xr_path</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">dZndz_path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ref_orbit_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numba</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
        <span class="n">dZndz_xr_path</span> <span class="o">=</span> <span class="n">Xr_template</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># dummy</span>
        <span class="n">dZndz_path</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">valid_pts</span><span class="p">):</span>
            <span class="n">dZndz_path</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfdz</span><span class="p">(</span><span class="n">Zn_path</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">dZndz_path</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

        <span class="c1"># /!\ Store the &quot;wrapped&quot; value at last pos</span>
        <span class="n">dZndz_path</span><span class="p">[</span><span class="n">ref_orbit_len</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfdz</span><span class="p">(</span><span class="n">Zn_path</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="n">dZndz_path</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">dZndz_path</span><span class="p">,</span> <span class="n">dZndz_xr_path</span>


<span class="nd">@numba</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">ref_path_get</span><span class="p">(</span><span class="n">ref_path</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">has_xr</span><span class="p">,</span> <span class="n">ref_index_xr</span><span class="p">,</span> <span class="n">ref_xr</span><span class="p">,</span> <span class="n">refpath_ptr</span><span class="p">,</span>
                 <span class="n">out_is_xr</span><span class="p">,</span> <span class="n">out_xr</span><span class="p">,</span> <span class="n">out_index</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Alternative to getitem which also takes as input prev_idx, curr_xr :</span>
<span class="sd">    allows to optimize the look-up of Xrange values in case of successive calls</span>
<span class="sd">    with increasing idx.</span>

<span class="sd">    idx :</span>
<span class="sd">        index requested</span>
<span class="sd">    (prev_idx, curr_xr) :</span>
<span class="sd">        couple returned from last call, last index requested + next xr target</span>
<span class="sd">        Contract : curr_xr the smallest integer that verify :</span>
<span class="sd">            prev_idx &lt;= ref_index_xr[curr_xr]</span>
<span class="sd">            or curr_xr = ref_index_xr.size (No more xr)</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    (val, xr_val, is_xr, prev_idx, curr_xr)</span>
<span class="sd">        val : np.complex128</span>
<span class="sd">    </span>
<span class="sd">    Modify in place:</span>
<span class="sd">        xr_val : complex128_Xrange_scalar -&gt; pushed to out_xr[out_index]</span>
<span class="sd">        is_xr : bool -&gt; pushed to out_is_xr[out_index]</span>
<span class="sd">        prev_idx == refpath_ptr[0] : int</span>
<span class="sd">        curr_xr == refpath_ptr[1] : int (index in path ref_xr)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">has_xr</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ref_path</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

    <span class="c1"># Not an increasing sequence, reset to restart a new sequence</span>
    <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">refpath_ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="c1"># Rewind to 0</span>
        <span class="n">refpath_ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># prev_idx = 0</span>
        <span class="n">refpath_ptr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># curr_xr = 0</span>

    <span class="c1"># In increasing sequence (idx &gt;= prev_idx)</span>
    <span class="k">if</span> <span class="p">(</span>
        <span class="p">(</span><span class="n">refpath_ptr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">ref_index_xr</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="ow">or</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">ref_index_xr</span><span class="p">[</span><span class="n">refpath_ptr</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
    <span class="p">):</span>
        <span class="n">refpath_ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>
        <span class="n">out_is_xr</span><span class="p">[</span><span class="n">out_index</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">ref_path</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

    <span class="k">elif</span> <span class="n">idx</span> <span class="o">==</span> <span class="n">ref_index_xr</span><span class="p">[</span><span class="n">refpath_ptr</span><span class="p">[</span><span class="mi">1</span><span class="p">]]:</span>
        <span class="n">refpath_ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>
        <span class="n">out_is_xr</span><span class="p">[</span><span class="n">out_index</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">out_xr</span><span class="p">[</span><span class="n">out_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">ref_xr</span><span class="p">[</span><span class="n">refpath_ptr</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">return</span> <span class="n">ref_path</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Here we have idx &gt; ref_index_xr[curr_xr]:</span>
        <span class="k">while</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">idx</span> <span class="o">&gt;</span> <span class="n">ref_index_xr</span><span class="p">[</span><span class="n">refpath_ptr</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
            <span class="ow">and</span> <span class="p">(</span><span class="n">refpath_ptr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">ref_index_xr</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">refpath_ptr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">refpath_ptr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">ref_index_xr</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">ref_index_xr</span><span class="p">[</span><span class="n">refpath_ptr</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="p">):</span>
            <span class="n">refpath_ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>
            <span class="n">out_is_xr</span><span class="p">[</span><span class="n">out_index</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="n">ref_path</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="c1"># Here idx == ref_index_xr[refpath_ptr[1]]</span>
        <span class="n">refpath_ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>
        <span class="n">out_is_xr</span><span class="p">[</span><span class="n">out_index</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">out_xr</span><span class="p">[</span><span class="n">out_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">ref_xr</span><span class="p">[</span><span class="n">refpath_ptr</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

        <span class="k">return</span> <span class="n">ref_path</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>


<span class="nd">@numba</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">ref_path_get_BS</span><span class="p">(</span><span class="n">ref_path</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">has_xr</span><span class="p">,</span> <span class="n">ref_index_xr</span><span class="p">,</span> <span class="n">refx_xr</span><span class="p">,</span> <span class="n">refy_xr</span><span class="p">,</span> <span class="n">refpath_ptr</span><span class="p">,</span>
                    <span class="n">out_is_xr</span><span class="p">,</span> <span class="n">out_xr</span><span class="p">,</span> <span class="n">outx_index</span><span class="p">,</span> <span class="n">outy_index</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Alternative to getitem which also takes as input prev_idx, curr_xr :</span>
<span class="sd">    allows to optimize the look-up of Xrange values in case of successive calls</span>
<span class="sd">    with increasing idx.</span>

<span class="sd">    idx :</span>
<span class="sd">        index requested</span>
<span class="sd">    refpath_ptr = (prev_idx, curr_xr) :</span>
<span class="sd">        couple returned from last call, last index requested + next xr target</span>
<span class="sd">        Contract : curr_xr the smallest integer that verify :</span>
<span class="sd">            prev_idx &lt;= ref_index_xr[curr_xr]</span>
<span class="sd">            or curr_xr = ref_index_xr.size (No more xr)</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    val np.complex128</span>
<span class="sd">        satndard value</span>

<span class="sd">    Modify in place:</span>
<span class="sd">        xr_val : complex128_Xrange_scalar -&gt; pushed to out_xr[out_index]</span>
<span class="sd">        is_xr : bool -&gt; pushed to out_is_xr[out_index]</span>
<span class="sd">        prev_idx == refpath_ptr[0] : int</span>
<span class="sd">        curr_xr == refpath_ptr[1] : int (index in path ref_xr)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">has_xr</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ref_path</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

    <span class="c1"># Not an increasing sequence, reset to restart a new sequence</span>
    <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">refpath_ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="c1"># Rewind to 0</span>
        <span class="n">refpath_ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># prev_idx = 0</span>
        <span class="n">refpath_ptr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># curr_xr = 0</span>

    <span class="c1"># In increasing sequence (idx &gt;= prev_idx)</span>
    <span class="k">if</span> <span class="p">(</span>
        <span class="p">(</span><span class="n">refpath_ptr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">ref_index_xr</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="ow">or</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">ref_index_xr</span><span class="p">[</span><span class="n">refpath_ptr</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
    <span class="p">):</span>
        <span class="n">refpath_ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>
        <span class="n">out_is_xr</span><span class="p">[</span><span class="n">outx_index</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">ref_path</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

    <span class="k">elif</span> <span class="n">idx</span> <span class="o">==</span> <span class="n">ref_index_xr</span><span class="p">[</span><span class="n">refpath_ptr</span><span class="p">[</span><span class="mi">1</span><span class="p">]]:</span>
        <span class="n">refpath_ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>
        <span class="n">out_is_xr</span><span class="p">[</span><span class="n">outx_index</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">out_xr</span><span class="p">[</span><span class="n">outx_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">refx_xr</span><span class="p">[</span><span class="n">refpath_ptr</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">out_xr</span><span class="p">[</span><span class="n">outy_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">refy_xr</span><span class="p">[</span><span class="n">refpath_ptr</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">return</span> <span class="n">ref_path</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Here we have idx &gt; ref_index_xr[curr_xr]:</span>
        <span class="k">while</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">idx</span> <span class="o">&gt;</span> <span class="n">ref_index_xr</span><span class="p">[</span><span class="n">refpath_ptr</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
            <span class="ow">and</span> <span class="p">(</span><span class="n">refpath_ptr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">ref_index_xr</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">refpath_ptr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">refpath_ptr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">ref_index_xr</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">ref_index_xr</span><span class="p">[</span><span class="n">refpath_ptr</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="p">):</span>
            <span class="n">refpath_ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>
            <span class="n">out_is_xr</span><span class="p">[</span><span class="n">outx_index</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="n">ref_path</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="c1"># Here idx == ref_index_xr[refpath_ptr[1]]</span>
        <span class="n">refpath_ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>
        <span class="n">out_is_xr</span><span class="p">[</span><span class="n">outx_index</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">out_xr</span><span class="p">[</span><span class="n">outx_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">refx_xr</span><span class="p">[</span><span class="n">refpath_ptr</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">out_xr</span><span class="p">[</span><span class="n">outy_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">refy_xr</span><span class="p">[</span><span class="n">refpath_ptr</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

        <span class="k">return</span> <span class="n">ref_path</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

<span class="c1"># Linear projection routines</span>
<span class="nd">@numba</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">lin_proj_impl</span><span class="p">(</span><span class="n">lin_mat</span><span class="p">,</span> <span class="n">linscale</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">real</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">imag</span>
    <span class="n">x1</span> <span class="o">=</span> <span class="n">lin_mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">lin_mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">y</span>
    <span class="n">y1</span> <span class="o">=</span> <span class="n">lin_mat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">lin_mat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">y</span>
    <span class="k">return</span>  <span class="n">linscale</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">complex</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">)</span>

<span class="c1">#@numba.njit(cache=True, fastmath=True, nogil=True)</span>
<span class="c1">#def lin_proj_impl_noscale(lin_mat, z):</span>
<span class="c1">#    x = z.real</span>
<span class="c1">#    y = z.imag</span>
<span class="c1">#    x1 = lin_mat[0, 0] * x + lin_mat[0, 1] * y</span>
<span class="c1">#    y1 = lin_mat[1, 0] * x + lin_mat[1, 1] * y</span>
<span class="c1">#    return complex(x1, y1)</span>

<span class="k">def</span> <span class="nf">mpc_lin_proj_impl_noscale</span><span class="p">(</span><span class="n">lin_mat</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="n">x1</span> <span class="o">=</span> <span class="n">lin_mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">lin_mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">y</span>
    <span class="n">y1</span> <span class="o">=</span> <span class="n">lin_mat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">lin_mat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">y</span>
    <span class="k">return</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">mpc</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">)</span>
</pre></div>

           </div>
          </div>
<div class="ribbon">
  <a href="https://github.com/GBillotey/Fractalshades">Fork me on GitHub</a>
</div>

          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Fractalshades development team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 
<style>
  .wy-nav-content { max-width: 1250px !important; }
</style>


</body>
</html>