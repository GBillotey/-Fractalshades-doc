<!== Adding "Fork me on Github" ribbon ==>
<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>fractalshades.core &mdash; Fractalshades 1.1.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../../_static/rtd_dark.css?v=e3debd14" />
      <link rel="stylesheet" type="text/css" href="../../_static/math.css?v=7fc59cab" />
      <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery.css?v=61a4c737" />
      <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-binder.css?v=f4aeca0c" />
      <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-dataframe.css?v=2082cf3c" />
      <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-rendered-html.css?v=1277b6f3" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=58fbf978"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link href="../../_static/ribbon.css" rel="stylesheet" type="text/css">

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            Fractalshades
              <img src="../../_static/logo3.jpg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                1.1.1
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started.html">Getting started</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../getting_started.html#installing">Installing</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../getting_started.html#installing-gmp-mpfr-mpc-windows-users">Installing GMP / MPFR / MPC: Windows users</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../getting_started.html#installing-gmp-mpfr-mpc-unix-linux-users">Installing GMP / MPFR / MPC: Unix / Linux users</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../getting_started.html#installing-gmp-mpfr-mpc-mac-users">Installing GMP / MPFR / MPC: Mac users</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../getting_started.html#a-5-minutes-guide-to-fractalshades">A 5-minutes guide to fractalshades</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../getting_started.html#graphical-user-interface">Graphical user interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../getting_started.html#finding-areas-of-interest">Finding areas of interest</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../getting_started.html#unskewing-streched-areas">Unskewing streched areas</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../math.html">Mathematical background</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../math.html#zoom-level-and-native-floating-point-precision">Zoom level and native floating-point precision</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../math.html#perturbation-theory">Perturbation Theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../math.html#avoiding-loss-of-precision">Avoiding loss of precision</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../math.html#billinear-approximations">Billinear approximations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../math.html#extended-range-floating-points">Extended range floating points</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../math.html#finding-minibrots">Finding minibrots</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../math.html#going-further-a-few-references">Going further: a few references</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/index.html">Gallery</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../examples/index.html#batch-mode-gallery">Batch mode gallery</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../examples/index.html#colormaps-template-gallery">Colormaps template gallery</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../examples/index.html#gui-mode-arbitrary-precision-implementations">GUI-mode: arbitrary precision implementations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../examples/index.html#gui-mode-standard-implementation-examples">GUI-mode: standard implementation examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../examples/index.html#lighting-examples-gallery">Lighting examples gallery</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../examples/index.html#projections">Projections</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../examples/batch_mode/index.html">Batch mode gallery</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../examples/batch_mode/01-full_basic.html">01 - Full Mandelbrot basic example</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/batch_mode/02-bulb_fieldlines1.html">02 - Bulb fieldlines example “tint_or_shade”</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/batch_mode/03-bulb_fieldlines2.html">03 - Bulb fieldlines example “twinfield”</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/batch_mode/04-seahorse_shaded.html">04 - Seahorse shaded example</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/batch_mode/05-seahorse_shaded_colored.html">05 - Seahorse shaded and colored example</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/batch_mode/06-seahorse_interior.html">06 - Seahorse interior example</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/batch_mode/07-seahorse_DEM.html">07 - Seahorse DEM example</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/batch_mode/08-run_perturb_DEM.html">08 - DEM example with perturbation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/batch_mode/09-run_flake_DEM.html">09 - A deeper DEM example</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/batch_mode/10-double_embedded_julia.html">10 - Double embedded Julia set</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/batch_mode/11-run_perturbdeep.html">11- Ultra-deep embedded Julia set</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/batch_mode/12-burning_ship_deep.html">12 - Burning Ship deep zoom</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/batch_mode/13-burning_ship.html">13 - Burning ship DEM</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/batch_mode/14-burning_ship-deeper_DEM.html">14 - Burning ship deeper DEM</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/batch_mode/15-burning_ship-deepJulia_DEM.html">15 - Burning Ship ultra-deep embedded Julia set</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/batch_mode/16-tetration_spring.html">16 - Tetration (power tower) zoom: “Spring”</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/batch_mode/17-perpendicular_burning_ship_DEM.html">17 - “Perpendicular” Burning Ship</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/batch_mode/18-perpendicular_burning_ship_glynn.html">18 - “Perpendicular” Burning Ship: hidden Glynn spiral</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/batch_mode/19-perpendicular_burning_ship_Koch.html">19 - “Perpendicular” Burning Ship: hidden Koch snowflakes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/batch_mode/20-perpendicular_burning_ship_Sierpinski.html">20 - “Perpendicular” Burning Ship: hidden Sierpinski carpets</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/batch_mode/21-perpendicular_burning_ship_trees.html">21 - “Perpendicular” Burning Ship: tree structures</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/batch_mode/22-shark_fin_deep.html">22 - “Shark Fin” escape-time fractal</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/batch_mode/23-deep_min.html">23 - A deep mini</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../examples/colormaps/index.html">Colormaps template gallery</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../examples/colormaps/plot_cmaps.html">Colormaps: available templates</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../examples/interactive_deepzoom/index.html">GUI-mode: arbitrary precision implementations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../examples/interactive_deepzoom/D01_run_interactive.html">D01 - Mandelbrot arbitrary-precision explorer</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/interactive_deepzoom/D02_run_BS_interactive.html">D02 - Burning Ship arbitrary-precision explorer</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/interactive_deepzoom/D03_run_interactive_Mn.html">D03 - Mandelbrot arbitrary-precision explorer</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../examples/interactive_standard/index.html">GUI-mode: standard implementation examples</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../examples/interactive_standard/S01_run_interactive_shallow.html">S01 - Mandelbrot explorer - Standard precision</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/interactive_standard/S02_run_BS_shallow.html">S02 - Burning ship explorer - Standard precision</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/interactive_standard/S03_run_interactive_Mn_shallow.html">S03 - Mandelbrot power n explorer - Standard precision</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/interactive_standard/S04_run_collatz.html">S04 - Collatz explorer - Standard precision</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/interactive_standard/S05_run_power_tower_shallow.html">S05 - Tetration fractal explorer - Standard precision</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../examples/lighting/index.html">Lighting examples gallery</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../examples/lighting/plot_lighting.html">Ligthings: available effects</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../examples/projections/index.html">Projections</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../examples/projections/P01-feigenbaum_expmap.html">P01 - Exponential mapping: Feigenbaum point</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/projections/P02-inversion.html">P02 - Inversion of the Mandelbrot set</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/projections/P03-Elephant_valley_moebius.html">P03 - Moebius mapping: Elephant and Seahorse valleys</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../examples/projections/P04-deep_expmap.html">P04 - Exponential mapping for deep zoom</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../API.html">Application Programming Interface</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../API/settings.html">Application-level settings</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../API/settings.html#fractalshades.settings.enable_multithreading"><code class="docutils literal notranslate"><span class="pre">enable_multithreading</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../API/settings.html#fractalshades.settings.skip_calc"><code class="docutils literal notranslate"><span class="pre">skip_calc</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../API/settings.html#fractalshades.settings.newton_zoom_level"><code class="docutils literal notranslate"><span class="pre">newton_zoom_level</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../API/settings.html#fractalshades.settings.no_newton"><code class="docutils literal notranslate"><span class="pre">no_newton</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../API/settings.html#fractalshades.settings.inspect_calc"><code class="docutils literal notranslate"><span class="pre">inspect_calc</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../API/settings.html#fractalshades.settings.chunk_size"><code class="docutils literal notranslate"><span class="pre">chunk_size</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../API/settings.html#fractalshades.settings.verbosity"><code class="docutils literal notranslate"><span class="pre">verbosity</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../API/settings.html#fractalshades.settings.postproc_dtype"><code class="docutils literal notranslate"><span class="pre">postproc_dtype</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../API/settings.html#fractalshades.settings.log_directory"><code class="docutils literal notranslate"><span class="pre">log_directory</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../API/settings.html#fractalshades.settings.disable_decompression_size_check"><code class="docutils literal notranslate"><span class="pre">disable_decompression_size_check()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../API/settings.html#fractalshades.settings.BLA_compression"><code class="docutils literal notranslate"><span class="pre">BLA_compression</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../API/settings.html#fractalshades.settings.GUI_image_Mblimit"><code class="docutils literal notranslate"><span class="pre">GUI_image_Mblimit</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../API/core.html">Core components</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../API/core.html#fractalshades.Fractal"><code class="docutils literal notranslate"><span class="pre">Fractal</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/core.html#fractalshades.Fractal.__init__"><code class="docutils literal notranslate"><span class="pre">Fractal.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/core.html#fractalshades.Fractal.clean_up"><code class="docutils literal notranslate"><span class="pre">Fractal.clean_up()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/core.html#fractalshades.Fractal.zoom"><code class="docutils literal notranslate"><span class="pre">Fractal.zoom()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/core.html#fractalshades.PerturbationFractal"><code class="docutils literal notranslate"><span class="pre">PerturbationFractal</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/core.html#fractalshades.PerturbationFractal.__init__"><code class="docutils literal notranslate"><span class="pre">PerturbationFractal.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/core.html#fractalshades.PerturbationFractal.zoom"><code class="docutils literal notranslate"><span class="pre">PerturbationFractal.zoom()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/core.html#fractalshades.Fractal_plotter"><code class="docutils literal notranslate"><span class="pre">Fractal_plotter</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/core.html#fractalshades.Fractal_plotter.__init__"><code class="docutils literal notranslate"><span class="pre">Fractal_plotter.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/core.html#fractalshades.Fractal_plotter.add_layer"><code class="docutils literal notranslate"><span class="pre">Fractal_plotter.add_layer()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/core.html#fractalshades.Fractal_plotter.plot"><code class="docutils literal notranslate"><span class="pre">Fractal_plotter.plot()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/core.html#fractalshades.Fractal_plotter.save_db"><code class="docutils literal notranslate"><span class="pre">Fractal_plotter.save_db()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/core.html#fractalshades.zoom_options"><code class="docutils literal notranslate"><span class="pre">zoom_options()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../API/core.html#fractalshades.calc_options"><code class="docutils literal notranslate"><span class="pre">calc_options()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../API/core.html#fractalshades.interactive_options"><code class="docutils literal notranslate"><span class="pre">interactive_options()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../API/projection.html">Projections</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../API/projection.html#fractalshades.projection.Projection"><code class="docutils literal notranslate"><span class="pre">Projection</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/projection.html#fractalshades.projection.Projection.__init__"><code class="docutils literal notranslate"><span class="pre">Projection.__init__()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/projection.html#fractalshades.projection.Cartesian"><code class="docutils literal notranslate"><span class="pre">Cartesian</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/projection.html#fractalshades.projection.Cartesian.__init__"><code class="docutils literal notranslate"><span class="pre">Cartesian.__init__()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/projection.html#fractalshades.projection.Expmap"><code class="docutils literal notranslate"><span class="pre">Expmap</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/projection.html#fractalshades.projection.Expmap.__init__"><code class="docutils literal notranslate"><span class="pre">Expmap.__init__()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/projection.html#fractalshades.projection.Generic_mapping"><code class="docutils literal notranslate"><span class="pre">Generic_mapping</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/projection.html#fractalshades.projection.Generic_mapping.__init__"><code class="docutils literal notranslate"><span class="pre">Generic_mapping.__init__()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../API/arbitrary_models.html">Fractal models: Arbitrary-precision implementations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../API/arbitrary_models.html#fractalshades.models.Perturbation_mandelbrot"><code class="docutils literal notranslate"><span class="pre">Perturbation_mandelbrot</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/arbitrary_models.html#fractalshades.models.Perturbation_mandelbrot.__init__"><code class="docutils literal notranslate"><span class="pre">Perturbation_mandelbrot.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/arbitrary_models.html#fractalshades.models.Perturbation_mandelbrot.calc_std_div"><code class="docutils literal notranslate"><span class="pre">Perturbation_mandelbrot.calc_std_div()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/arbitrary_models.html#fractalshades.models.Perturbation_mandelbrot_N"><code class="docutils literal notranslate"><span class="pre">Perturbation_mandelbrot_N</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/arbitrary_models.html#fractalshades.models.Perturbation_mandelbrot_N.__init__"><code class="docutils literal notranslate"><span class="pre">Perturbation_mandelbrot_N.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/arbitrary_models.html#fractalshades.models.Perturbation_mandelbrot_N.calc_std_div"><code class="docutils literal notranslate"><span class="pre">Perturbation_mandelbrot_N.calc_std_div()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/arbitrary_models.html#fractalshades.models.Perturbation_burning_ship"><code class="docutils literal notranslate"><span class="pre">Perturbation_burning_ship</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/arbitrary_models.html#fractalshades.models.Perturbation_burning_ship.__init__"><code class="docutils literal notranslate"><span class="pre">Perturbation_burning_ship.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/arbitrary_models.html#fractalshades.models.Perturbation_burning_ship.calc_std_div"><code class="docutils literal notranslate"><span class="pre">Perturbation_burning_ship.calc_std_div()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../API/standard_models.html">Fractal models: Standard-precision implementations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../API/standard_models.html#fractalshades.models.Mandelbrot"><code class="docutils literal notranslate"><span class="pre">Mandelbrot</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/standard_models.html#fractalshades.models.Mandelbrot.__init__"><code class="docutils literal notranslate"><span class="pre">Mandelbrot.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/standard_models.html#fractalshades.models.Mandelbrot.calc_std_div"><code class="docutils literal notranslate"><span class="pre">Mandelbrot.calc_std_div()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/standard_models.html#fractalshades.models.Mandelbrot.newton_calc"><code class="docutils literal notranslate"><span class="pre">Mandelbrot.newton_calc()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/standard_models.html#fractalshades.models.Mandelbrot_N"><code class="docutils literal notranslate"><span class="pre">Mandelbrot_N</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/standard_models.html#fractalshades.models.Mandelbrot_N.__init__"><code class="docutils literal notranslate"><span class="pre">Mandelbrot_N.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/standard_models.html#fractalshades.models.Mandelbrot_N.calc_std_div"><code class="docutils literal notranslate"><span class="pre">Mandelbrot_N.calc_std_div()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/standard_models.html#fractalshades.models.Mandelbrot_N.newton_calc"><code class="docutils literal notranslate"><span class="pre">Mandelbrot_N.newton_calc()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/standard_models.html#fractalshades.models.Burning_ship"><code class="docutils literal notranslate"><span class="pre">Burning_ship</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/standard_models.html#fractalshades.models.Burning_ship.__init__"><code class="docutils literal notranslate"><span class="pre">Burning_ship.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/standard_models.html#fractalshades.models.Burning_ship.calc_std_div"><code class="docutils literal notranslate"><span class="pre">Burning_ship.calc_std_div()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/standard_models.html#fractalshades.models.Power_tower"><code class="docutils literal notranslate"><span class="pre">Power_tower</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/standard_models.html#fractalshades.models.Power_tower.__init__"><code class="docutils literal notranslate"><span class="pre">Power_tower.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/standard_models.html#fractalshades.models.Power_tower.newton_calc"><code class="docutils literal notranslate"><span class="pre">Power_tower.newton_calc()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/standard_models.html#fractalshades.models.Collatz"><code class="docutils literal notranslate"><span class="pre">Collatz</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/standard_models.html#fractalshades.models.Collatz.__init__"><code class="docutils literal notranslate"><span class="pre">Collatz.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/standard_models.html#fractalshades.models.Collatz.base_calc"><code class="docutils literal notranslate"><span class="pre">Collatz.base_calc()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../API/postproc.html">Postprocessing fields</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../API/postproc.html#fractalshades.postproc.Postproc_batch"><code class="docutils literal notranslate"><span class="pre">Postproc_batch</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/postproc.html#fractalshades.postproc.Postproc_batch.__init__"><code class="docutils literal notranslate"><span class="pre">Postproc_batch.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/postproc.html#fractalshades.postproc.Postproc_batch.add_postproc"><code class="docutils literal notranslate"><span class="pre">Postproc_batch.add_postproc()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/postproc.html#fractalshades.postproc.Postproc"><code class="docutils literal notranslate"><span class="pre">Postproc</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../API/postproc.html#fractalshades.postproc.Raw_pp"><code class="docutils literal notranslate"><span class="pre">Raw_pp</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/postproc.html#fractalshades.postproc.Raw_pp.__init__"><code class="docutils literal notranslate"><span class="pre">Raw_pp.__init__()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/postproc.html#fractalshades.postproc.Continuous_iter_pp"><code class="docutils literal notranslate"><span class="pre">Continuous_iter_pp</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/postproc.html#fractalshades.postproc.Continuous_iter_pp.__init__"><code class="docutils literal notranslate"><span class="pre">Continuous_iter_pp.__init__()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/postproc.html#fractalshades.postproc.Fieldlines_pp"><code class="docutils literal notranslate"><span class="pre">Fieldlines_pp</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/postproc.html#fractalshades.postproc.Fieldlines_pp.__init__"><code class="docutils literal notranslate"><span class="pre">Fieldlines_pp.__init__()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/postproc.html#fractalshades.postproc.DEM_pp"><code class="docutils literal notranslate"><span class="pre">DEM_pp</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/postproc.html#fractalshades.postproc.DEM_pp.__init__"><code class="docutils literal notranslate"><span class="pre">DEM_pp.__init__()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/postproc.html#fractalshades.postproc.DEM_normal_pp"><code class="docutils literal notranslate"><span class="pre">DEM_normal_pp</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/postproc.html#fractalshades.postproc.DEM_normal_pp.__init__"><code class="docutils literal notranslate"><span class="pre">DEM_normal_pp.__init__()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/postproc.html#fractalshades.postproc.Attr_pp"><code class="docutils literal notranslate"><span class="pre">Attr_pp</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/postproc.html#fractalshades.postproc.Attr_pp.__init__"><code class="docutils literal notranslate"><span class="pre">Attr_pp.__init__()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/postproc.html#fractalshades.postproc.Attr_normal_pp"><code class="docutils literal notranslate"><span class="pre">Attr_normal_pp</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/postproc.html#fractalshades.postproc.Attr_normal_pp.__init__"><code class="docutils literal notranslate"><span class="pre">Attr_normal_pp.__init__()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/postproc.html#fractalshades.postproc.Fractal_array"><code class="docutils literal notranslate"><span class="pre">Fractal_array</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/postproc.html#fractalshades.postproc.Fractal_array.__init__"><code class="docutils literal notranslate"><span class="pre">Fractal_array.__init__()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../API/layers.html">Image layers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../API/layers.html#fractalshades.colors.layers.Virtual_layer"><code class="docutils literal notranslate"><span class="pre">Virtual_layer</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/layers.html#fractalshades.colors.layers.Virtual_layer.__init__"><code class="docutils literal notranslate"><span class="pre">Virtual_layer.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/layers.html#fractalshades.colors.layers.Virtual_layer.set_mask"><code class="docutils literal notranslate"><span class="pre">Virtual_layer.set_mask()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/layers.html#fractalshades.colors.layers.Bool_layer"><code class="docutils literal notranslate"><span class="pre">Bool_layer</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/layers.html#fractalshades.colors.layers.Bool_layer.__init__"><code class="docutils literal notranslate"><span class="pre">Bool_layer.__init__()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/layers.html#fractalshades.colors.layers.Color_layer"><code class="docutils literal notranslate"><span class="pre">Color_layer</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/layers.html#fractalshades.colors.layers.Color_layer.__init__"><code class="docutils literal notranslate"><span class="pre">Color_layer.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/layers.html#fractalshades.colors.layers.Color_layer.overlay"><code class="docutils literal notranslate"><span class="pre">Color_layer.overlay()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/layers.html#fractalshades.colors.layers.Color_layer.set_mask"><code class="docutils literal notranslate"><span class="pre">Color_layer.set_mask()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/layers.html#fractalshades.colors.layers.Color_layer.set_twin_field"><code class="docutils literal notranslate"><span class="pre">Color_layer.set_twin_field()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/layers.html#fractalshades.colors.layers.Color_layer.shade"><code class="docutils literal notranslate"><span class="pre">Color_layer.shade()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/layers.html#fractalshades.colors.layers.Normal_map_layer"><code class="docutils literal notranslate"><span class="pre">Normal_map_layer</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/layers.html#fractalshades.colors.layers.Normal_map_layer.__init__"><code class="docutils literal notranslate"><span class="pre">Normal_map_layer.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/layers.html#fractalshades.colors.layers.Normal_map_layer.set_mask"><code class="docutils literal notranslate"><span class="pre">Normal_map_layer.set_mask()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/layers.html#fractalshades.colors.layers.Grey_layer"><code class="docutils literal notranslate"><span class="pre">Grey_layer</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/layers.html#fractalshades.colors.layers.Grey_layer.__init__"><code class="docutils literal notranslate"><span class="pre">Grey_layer.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/layers.html#fractalshades.colors.layers.Grey_layer.set_mask"><code class="docutils literal notranslate"><span class="pre">Grey_layer.set_mask()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/layers.html#fractalshades.colors.layers.Disp_layer"><code class="docutils literal notranslate"><span class="pre">Disp_layer</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/layers.html#fractalshades.colors.layers.Disp_layer.__init__"><code class="docutils literal notranslate"><span class="pre">Disp_layer.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/layers.html#fractalshades.colors.layers.Disp_layer.set_mask"><code class="docutils literal notranslate"><span class="pre">Disp_layer.set_mask()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/layers.html#fractalshades.colors.layers.Blinn_lighting"><code class="docutils literal notranslate"><span class="pre">Blinn_lighting</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/layers.html#fractalshades.colors.layers.Blinn_lighting.__init__"><code class="docutils literal notranslate"><span class="pre">Blinn_lighting.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/layers.html#fractalshades.colors.layers.Blinn_lighting.add_light_source"><code class="docutils literal notranslate"><span class="pre">Blinn_lighting.add_light_source()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/layers.html#fractalshades.colors.layers.Overlay_mode"><code class="docutils literal notranslate"><span class="pre">Overlay_mode</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/layers.html#fractalshades.colors.layers.Overlay_mode.__init__"><code class="docutils literal notranslate"><span class="pre">Overlay_mode.__init__()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../API/colors.html">Color mapping</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../API/colors.html#fractalshades.colors.Fractal_colormap"><code class="docutils literal notranslate"><span class="pre">Fractal_colormap</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/colors.html#fractalshades.colors.Fractal_colormap.__init__"><code class="docutils literal notranslate"><span class="pre">Fractal_colormap.__init__()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../API/GUI.html">GUI</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../API/GUI.html#fractalshades.gui.guimodel.Fractal_GUI"><code class="docutils literal notranslate"><span class="pre">Fractal_GUI</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/GUI.html#fractalshades.gui.guimodel.Fractal_GUI.__init__"><code class="docutils literal notranslate"><span class="pre">Fractal_GUI.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/GUI.html#fractalshades.gui.guimodel.Fractal_GUI.connect_image"><code class="docutils literal notranslate"><span class="pre">Fractal_GUI.connect_image()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/GUI.html#fractalshades.gui.guimodel.Fractal_GUI.connect_mouse"><code class="docutils literal notranslate"><span class="pre">Fractal_GUI.connect_mouse()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/GUI.html#fractalshades.gui.guimodel.Fractal_GUI.show"><code class="docutils literal notranslate"><span class="pre">Fractal_GUI.show()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/GUI.html#fractalshades.gui.guitemplates.std_zooming"><code class="docutils literal notranslate"><span class="pre">std_zooming</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/GUI.html#fractalshades.gui.guitemplates.std_zooming.__init__"><code class="docutils literal notranslate"><span class="pre">std_zooming.__init__()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../API/logging.html">Logging</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../API/logging.html#fractalshades.log.set_log_handlers"><code class="docutils literal notranslate"><span class="pre">set_log_handlers()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../API/db.html">Databases</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../API/db.html#fractalshades.db.Db"><code class="docutils literal notranslate"><span class="pre">Db</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/db.html#fractalshades.db.Db.__init__"><code class="docutils literal notranslate"><span class="pre">Db.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/db.html#fractalshades.db.Db.plot"><code class="docutils literal notranslate"><span class="pre">Db.plot()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/db.html#fractalshades.db.Db.set_plotter"><code class="docutils literal notranslate"><span class="pre">Db.set_plotter()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/db.html#fractalshades.db.Frame"><code class="docutils literal notranslate"><span class="pre">Frame</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/db.html#fractalshades.db.Frame.__init__"><code class="docutils literal notranslate"><span class="pre">Frame.__init__()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/db.html#fractalshades.db.Exp_db"><code class="docutils literal notranslate"><span class="pre">Exp_db</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/db.html#fractalshades.db.Exp_db.__init__"><code class="docutils literal notranslate"><span class="pre">Exp_db.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/db.html#fractalshades.db.Exp_db.plot"><code class="docutils literal notranslate"><span class="pre">Exp_db.plot()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/db.html#fractalshades.db.Exp_frame"><code class="docutils literal notranslate"><span class="pre">Exp_frame</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/db.html#fractalshades.db.Exp_frame.__init__"><code class="docutils literal notranslate"><span class="pre">Exp_frame.__init__()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../API/movie.html">Movie module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../API/movie.html#fractalshades.movie.Movie"><code class="docutils literal notranslate"><span class="pre">Movie</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/movie.html#fractalshades.movie.Movie.__init__"><code class="docutils literal notranslate"><span class="pre">Movie.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/movie.html#fractalshades.movie.Movie.add_sequence"><code class="docutils literal notranslate"><span class="pre">Movie.add_sequence()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/movie.html#fractalshades.movie.Movie.export_frame"><code class="docutils literal notranslate"><span class="pre">Movie.export_frame()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../API/movie.html#fractalshades.movie.Movie.make"><code class="docutils literal notranslate"><span class="pre">Movie.make()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/movie.html#fractalshades.movie.Camera_pan"><code class="docutils literal notranslate"><span class="pre">Camera_pan</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/movie.html#fractalshades.movie.Camera_pan.__init__"><code class="docutils literal notranslate"><span class="pre">Camera_pan.__init__()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/movie.html#fractalshades.movie.Camera_zoom"><code class="docutils literal notranslate"><span class="pre">Camera_zoom</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/movie.html#fractalshades.movie.Camera_zoom.__init__"><code class="docutils literal notranslate"><span class="pre">Camera_zoom.__init__()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../API/movie.html#fractalshades.movie.Custom_sequence"><code class="docutils literal notranslate"><span class="pre">Custom_sequence</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../API/movie.html#fractalshades.movie.Custom_sequence.__init__"><code class="docutils literal notranslate"><span class="pre">Custom_sequence.__init__()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../making_movies.html">Making movies</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../making_movies.html#example-pan-sequence">Example: pan sequence</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../making_movies.html#example-zoom-sequence">Example: zoom sequence</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../making_movies.html#example-custom-zoom-sequence">Example: “Custom” zoom sequence</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../making_movies.html#example-using-distance-estimation-plots">Example: Using Distance Estimation plots</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../changelog.html">Changelog</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#rev-1-1">Rev 1.1</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../changelog.html#rev-1-1-0">Rev 1.1.0</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../changelog.html#rev-1-1-1">Rev 1.1.1</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#rev-1-0">Rev 1.0</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../changelog.html#rev-1-0-3">Rev 1.0.3</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../changelog.html#rev-1-0-2">Rev 1.0.2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../changelog.html#rev-1-0-1">Rev 1.0.1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../changelog.html#rev-1-0-0">Rev 1.0.0</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#rev-0-5">Rev 0.5</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../changelog.html#rev-0-5-6">Rev 0.5.6</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../changelog.html#rev-0-5-5">Rev 0.5.5</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../changelog.html#rev-0-5-4">Rev 0.5.4</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../changelog.html#rev-0-5-3">Rev 0.5.3</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../changelog.html#rev-0-5-2">Rev 0.5.2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../changelog.html#rev-0-5-0">Rev 0.5.0</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#rev-0-4">Rev 0.4</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../changelog.html#rev-0-4-3">Rev 0.4.3</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../changelog.html#rev-0-4-2">Rev 0.4.2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../changelog.html#rev-0-4-1">Rev 0.4.1</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../acknowledgment.html">Acknowledgment</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Fractalshades</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">fractalshades.core</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">

           <div itemprop="articleBody">
             
  <h1>Source code for fractalshades.core</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">fnmatch</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">textwrap</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">types</span>
<span class="kn">import</span> <span class="nn">typing</span>
<span class="kn">import</span> <span class="nn">enum</span>
<span class="kn">import</span> <span class="nn">inspect</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy.lib.format</span> <span class="kn">import</span> <span class="n">open_memmap</span>
<span class="kn">import</span> <span class="nn">PIL</span>
<span class="kn">import</span> <span class="nn">PIL.PngImagePlugin</span>
<span class="kn">import</span> <span class="nn">numba</span>

<span class="kn">import</span> <span class="nn">fractalshades</span> <span class="k">as</span> <span class="nn">fs</span>
<span class="kn">import</span> <span class="nn">fractalshades.settings</span>
<span class="kn">import</span> <span class="nn">fractalshades.utils</span>
<span class="kn">import</span> <span class="nn">fractalshades.postproc</span>
<span class="kn">import</span> <span class="nn">fractalshades.projection</span>

<span class="kn">from</span> <span class="nn">fractalshades.mthreading</span> <span class="kn">import</span> <span class="n">Multithreading_iterator</span>
<span class="kn">import</span> <span class="nn">fractalshades.numpy_utils.expr_parser</span> <span class="k">as</span> <span class="nn">fs_parser</span>


<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">_Pillow_figure</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="n">pnginfo</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This class is a wrapper that can be used to redirect a Fractal_plotter</span>
<span class="sd">        output, for instance when generating the documentation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">img</span> <span class="o">=</span> <span class="n">img</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pnginfo</span> <span class="o">=</span> <span class="n">pnginfo</span>

    <span class="k">def</span> <span class="nf">save_png</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">im_path</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Saves as a png with Lanczos resizing filter if exceeds the max width</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">im</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">img</span>
        <span class="n">width</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">size</span>
        <span class="n">max_width</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">output_context</span><span class="p">[</span><span class="s2">&quot;doc_max_width&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">width</span> <span class="o">&gt;</span> <span class="n">max_width</span><span class="p">:</span>
            <span class="n">ratio</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">width</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">max_width</span><span class="p">)</span>
            <span class="n">new_height</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">height</span> <span class="o">/</span> <span class="n">ratio</span><span class="p">)</span>
            <span class="n">im</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">resize</span><span class="p">((</span><span class="n">max_width</span><span class="p">,</span> <span class="n">new_height</span><span class="p">),</span> <span class="n">PIL</span><span class="o">.</span><span class="n">Image</span><span class="o">.</span><span class="n">LANCZOS</span><span class="p">)</span>
        <span class="n">im</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">im_path</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;png&quot;</span><span class="p">,</span> <span class="n">pnginfo</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pnginfo</span><span class="p">)</span>


<span class="n">SUPERSAMPLING_DIC</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;2x2&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
    <span class="s2">&quot;3x3&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
    <span class="s2">&quot;4x4&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
    <span class="s2">&quot;5x5&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
    <span class="s2">&quot;6x6&quot;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span>
    <span class="s2">&quot;7x7&quot;</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span>
    <span class="s2">&quot;None&quot;</span><span class="p">:</span> <span class="kc">None</span>
<span class="p">}</span>

<span class="n">SUPERSAMPLING_ENUM</span> <span class="o">=</span> <span class="n">enum</span><span class="o">.</span><span class="n">Enum</span><span class="p">(</span>
    <span class="s2">&quot;SUPERSAMPLING_ENUM&quot;</span><span class="p">,</span>
    <span class="nb">list</span><span class="p">(</span><span class="n">SUPERSAMPLING_DIC</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span><span class="c1"># ,</span>
    <span class="n">module</span><span class="o">=</span><span class="vm">__name__</span>
<span class="p">)</span>

<span class="n">supersampling_type</span> <span class="o">=</span> <span class="n">typing</span><span class="o">.</span><span class="n">Literal</span><span class="p">[</span><span class="n">SUPERSAMPLING_ENUM</span><span class="p">]</span>


<div class="viewcode-block" id="Fractal_plotter">
<a class="viewcode-back" href="../../API/core.html#fractalshades.Fractal_plotter">[docs]</a>
<span class="k">class</span> <span class="nc">Fractal_plotter</span><span class="p">:</span>

<div class="viewcode-block" id="Fractal_plotter.__init__">
<a class="viewcode-back" href="../../API/core.html#fractalshades.Fractal_plotter.__init__">[docs]</a>
    <span class="k">def</span>  <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
        <span class="n">postproc_batch</span><span class="p">,</span>
        <span class="n">final_render</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">supersampling</span><span class="p">:</span> <span class="n">supersampling_type</span> <span class="o">=</span> <span class="s2">&quot;None&quot;</span><span class="p">,</span>
        <span class="n">jitter</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">recovery_mode</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The base plotting class.</span>

<span class="sd">        A Fractal plotter is a container for </span>
<span class="sd">        `fractalshades.postproc.Postproc_batch` and fractal layers.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        postproc_batch</span>
<span class="sd">            A single `fractalshades.postproc.Postproc_batch` or a list of </span>
<span class="sd">            theses. They shall  to the same</span>
<span class="sd">            unique `Fractal` object.</span>
<span class="sd">        final_render : bool</span>
<span class="sd">            - If ``False``, this is an exploration rendering, the raw arrays</span>
<span class="sd">              will be stored to allow fast modification of the plotting</span>
<span class="sd">              options for an already computed zoom - without recomputing.</span>
<span class="sd">              High-quality rendering (supersampling, jitter) is disabled in</span>
<span class="sd">              this case.</span>
<span class="sd">            - If ``True``, this is the final rendering, the image tiles will</span>
<span class="sd">              be directly computed by chunks on the fly to limit disk usage,</span>
<span class="sd">              and stored in a memory-mapped array (.postdb extension).</span>
<span class="sd">              High quality rendering options are available only in this case</span>
<span class="sd">              (antialising, jitter). Raw arrays are *not* stored in this case,</span>
<span class="sd">              any change made to the plotting parametrers will need a new</span>
<span class="sd">              calculation. However an interrupted calculation might still be</span>
<span class="sd">              restarted, see parameter `recovery_mode`.</span>
<span class="sd">        supersampling : None | &quot;2x2&quot; | &quot;3x3&quot; | ... | &quot;7x7&quot;</span>
<span class="sd">            Used only for the final render. if not None, the final image will</span>
<span class="sd">            leverage supersampling (from 4 to 49 pixels computed for 1 pixel in </span>
<span class="sd">            the saved image)</span>
<span class="sd">        jitter : bool | float</span>
<span class="sd">            Used only for the final render. If not None, the final image will</span>
<span class="sd">            leverage jitter, default intensity is 1. This can help reduce moiré</span>
<span class="sd">            effect</span>
<span class="sd">        recovery_mode : bool</span>
<span class="sd">            Used only for the final render. If True, will attempt to reload</span>
<span class="sd">            the image tiles already computed. Allows to restart an interrupted</span>
<span class="sd">            calculation in final render mode (this will result in a &#39;patchwork&#39;</span>
<span class="sd">            if plotting parameters have been modified).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        .. warning::</span>
<span class="sd">            When passed a list of `fractalshades.postproc.Postproc_batch`</span>
<span class="sd">            objects, each postprocessing batch shall point to the same</span>
<span class="sd">            unique `Fractal` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">supersampling</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># Nonetype not allowed in Enum...</span>
            <span class="n">supersampling</span> <span class="o">=</span> <span class="s2">&quot;None&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">postproc_options</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;final_render&quot;</span><span class="p">:</span> <span class="n">final_render</span><span class="p">,</span>
            <span class="s2">&quot;supersampling&quot;</span><span class="p">:</span> <span class="n">supersampling</span><span class="p">,</span>
            <span class="s2">&quot;jitter&quot;</span><span class="p">:</span> <span class="n">jitter</span><span class="p">,</span>
            <span class="s2">&quot;recovery_mode&quot;</span><span class="p">:</span> <span class="n">recovery_mode</span>
        <span class="p">}</span>

        <span class="c1"># postproc_batches can be single or an enumeration</span>
        <span class="c1"># At this stage it is unfrozen (more can be added),</span>
        <span class="c1"># waiting for a register_postprocs call</span>
        <span class="n">postproc_batches</span> <span class="o">=</span> <span class="n">postproc_batch</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">postproc_batch</span><span class="p">,</span> <span class="n">fs</span><span class="o">.</span><span class="n">postproc</span><span class="o">.</span><span class="n">Postproc_batch</span><span class="p">):</span>
            <span class="n">postproc_batches</span> <span class="o">=</span> <span class="p">[</span><span class="n">postproc_batch</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_postproc_batches</span> <span class="o">=</span> <span class="n">postproc_batches</span> <span class="c1"># unfrozen </span>

        <span class="bp">self</span><span class="o">.</span><span class="n">register_postprocs</span><span class="p">()</span></div>



    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">postnames</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">posts</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># The image size </span>
        <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fractal</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">ny</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">db_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># The array shapes</span>
        <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fractal</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">nx</span><span class="p">)</span>  


    <span class="k">def</span> <span class="nf">add_postproc_batch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">postproc_batch</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds another post-processing batch &amp; register the associated postproc</span>
<span class="sd">        names. `postproc_batch` shall map to the same fractal.</span>
<span class="sd">        Note : several postproc_batches are needed whenever different </span>
<span class="sd">        calculations need to be combined in an output plot, as a postproc</span>
<span class="sd">        batch can only map to a unique calc_name.</span>
<span class="sd">        :meta private:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">postproc_batch</span><span class="o">.</span><span class="n">fractal</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fractal</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Attempt to add a postproc_batch from a different&quot;</span>
                             <span class="s2">&quot;fractal: </span><span class="si">{}</span><span class="s2"> from </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">postproc_batch</span><span class="o">.</span><span class="n">fractal</span><span class="p">,</span> <span class="n">postproc_batch</span><span class="o">.</span><span class="n">calc_name</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">postproc_batches</span> <span class="o">+=</span> <span class="p">[</span><span class="n">postproc_batch</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">posts</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">postproc_batch</span><span class="o">.</span><span class="n">posts</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">postnames_2d</span> <span class="o">+=</span> <span class="n">postproc_batch</span><span class="o">.</span><span class="n">postnames_2d</span>


    <span class="k">def</span> <span class="nf">register_postprocs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Register of the postprocs - call could be delayed after a plotter</span>
<span class="sd">        instanciation but shall be before any coloring method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">postproc_batches</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_postproc_batches</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">postproc_batch</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">postproc_batches</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">postproc_batches</span> <span class="o">=</span> <span class="p">[</span><span class="n">postproc_batch</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">posts</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">postproc_batch</span><span class="o">.</span><span class="n">posts</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">postnames_2d</span> <span class="o">=</span> <span class="n">postproc_batch</span><span class="o">.</span><span class="n">postnames_2d</span>
                <span class="c1"># iterator :</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fractal</span> <span class="o">=</span> <span class="n">postproc_batch</span><span class="o">.</span><span class="n">fractal</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_postproc_batch</span><span class="p">(</span><span class="n">postproc_batch</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">chunk_slices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fractal</span><span class="o">.</span><span class="n">chunk_slices</span>
        <span class="c1"># layer data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">layers</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scalings</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># to be computed !</span>
        <span class="c1"># Plotting directory</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot_dir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fractal</span><span class="o">.</span><span class="n">directory</span>

        <span class="c1"># Mem mapping dtype</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">post_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">postproc_dtype</span><span class="p">)</span>


<div class="viewcode-block" id="Fractal_plotter.add_layer">
<a class="viewcode-back" href="../../API/core.html#fractalshades.Fractal_plotter.add_layer">[docs]</a>
    <span class="k">def</span> <span class="nf">add_layer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">layer</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a layer field to allow subsequent graphical operations or outputs.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        layer : `fractalshades.colors.layers.Virtual_layer` or a derived class</span>
<span class="sd">            The layer to add</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. warning::</span>
<span class="sd">            Layer `postname` shall have been already registered in one of the</span>
<span class="sd">            plotter batches (see method</span>
<span class="sd">            `fractalshades.postproc.Postproc_batch.add_postproc`).</span>

<span class="sd">        .. warning::</span>
<span class="sd">            When a layer is added, a link layer -&gt; Fractal_plotter is </span>
<span class="sd">            created ; a layer can therefore only be added to a single</span>
<span class="sd">            `Fractal_plotter`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">postname</span> <span class="o">=</span> <span class="n">layer</span><span class="o">.</span><span class="n">postname</span>
        <span class="k">if</span> <span class="n">postname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">postnames</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">postnames_2d</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Layer `</span><span class="si">{}</span><span class="s2">` shall be registered in Fractal_plotter &quot;</span>
                <span class="s2">&quot;postproc_batches: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">postname</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">postnames</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">postnames_2d</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">layers</span> <span class="o">+=</span> <span class="p">[</span><span class="n">layer</span><span class="p">]</span>
        <span class="n">layer</span><span class="o">.</span><span class="n">link_plotter</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Get the layer by its postname</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">layers</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">layer</span><span class="o">.</span><span class="n">postname</span> <span class="o">==</span> <span class="n">layer_name</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">layer</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Layer </span><span class="si">{}</span><span class="s2"> not in available layers: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">layer_name</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">postname</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">layers</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">plotter_info_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
        <span class="k">if</span> <span class="s2">&quot;db&quot;</span> <span class="ow">in</span> <span class="n">mode</span><span class="p">:</span>
            <span class="n">str_info</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Output to database .</span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s2">: plotter options&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">str_info</span> <span class="o">=</span> <span class="s2">&quot;Plotting images: plotter options&quot;</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postproc_options</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">str_info</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">    </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">str_info</span> <span class="o">+=</span> <span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">  /!</span><span class="se">\\</span><span class="s2"> supersampling and jitter only activated &quot;</span>
                     <span class="o">+</span> <span class="s2">&quot;for final render&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">str_info</span>

    <span class="k">def</span> <span class="nf">zoom_info_str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">str_info</span> <span class="o">=</span> <span class="s2">&quot;Plotting images: zoom kwargs&quot;</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fractal</span><span class="o">.</span><span class="n">zoom_kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">str_info</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">    </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="n">str_info</span>

<div class="viewcode-block" id="Fractal_plotter.plot">
<a class="viewcode-back" href="../../API/core.html#fractalshades.Fractal_plotter.plot">[docs]</a>
    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The base method to produce images.</span>
<span class="sd">        </span>
<span class="sd">        When called, it will got through all the instance-registered layers</span>
<span class="sd">        and plot each layer for which the `output` attribute is set to `True`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_relpath</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Use default locations for the output files</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">=</span> <span class="s2">&quot;img&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;img&quot;</span><span class="p">)</span></div>



    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">postdb_layer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tile_validator</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        mode: &quot;img&quot; | &quot;db&quot; | &quot;postdb&quot;</span>
<span class="sd">        postdb_layer: Optional Layer object, used if exporting a .postdb</span>
<span class="sd">        tile_validator: Optional, func: tile -&gt; bool - used fot large expmap</span>
<span class="sd">            reference recomputing</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plotter_info_str</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zoom_info_str</span><span class="p">())</span>

        <span class="k">assert</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;img&quot;</span><span class="p">,</span> <span class="s2">&quot;db&quot;</span><span class="p">,</span> <span class="s2">&quot;postdb&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">postdb_layer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Convert the str to its Layer object</span>
            <span class="n">postdb_layer</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">postdb_layer</span><span class="p">]</span>

        <span class="c1"># Open the image memory mappings; open PIL images</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;img&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">open_images</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">final_render</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">layer</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">layers</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">layer</span><span class="o">.</span><span class="n">output</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">open_postdb</span><span class="p">(</span><span class="n">layer</span><span class="p">)</span>
                        <span class="c1"># self.create_img_mmap(layer)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">open_any_db</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">postdb_layer</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">final_render</span><span class="p">:</span>
            <span class="c1"># We need to delete because if will not be recomputed in the</span>
            <span class="c1"># calc process - so it is invalidated</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fractal</span><span class="o">.</span><span class="n">delete_fingerprint</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_raw_arr</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_tile</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_tiles_stack&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
            <span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="mf">0.</span>  <span class="c1"># time of last evt in seconds</span>
        <span class="p">}</span>

        <span class="c1"># Here we follow a 2-step approach:</span>
        <span class="c1"># if &quot;dev&quot; (= not final) render, we first compute the &#39;raw&#39; arrays.</span>
        <span class="c1"># This is done by pbatches, due to the univoque relationship</span>
        <span class="c1"># one postproc_batches &lt;-&gt; Fractal calculation</span>
        <span class="c1"># if &quot;final&quot; we do not store raw datas, but we still need to create a</span>
        <span class="c1"># mmap for the &quot;subset&quot; arrays</span>
        <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fractal</span>
        <span class="k">for</span> <span class="n">pbatch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postproc_batches</span><span class="p">:</span>
            <span class="n">calc_name</span> <span class="o">=</span> <span class="n">pbatch</span><span class="o">.</span><span class="n">calc_name</span>
            <span class="n">f</span><span class="o">.</span><span class="n">clean_postproc_attr</span><span class="p">(</span><span class="n">when</span><span class="o">=</span><span class="s2">&quot;pre&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">postproc_options</span><span class="p">[</span><span class="s2">&quot;final_render&quot;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s2">&quot;_subset_hook&quot;</span><span class="p">)</span>
                        <span class="ow">and</span> <span class="n">calc_name</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">_subset_hook</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Adding subset output for </span><span class="si">{</span><span class="n">calc_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">init_subset_mmap</span><span class="p">(</span><span class="n">calc_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">supersampling</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Computing and storing raw data for </span><span class="si">{</span><span class="n">calc_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">f</span><span class="o">.</span><span class="n">calc_raw</span><span class="p">(</span><span class="n">calc_name</span><span class="p">,</span> <span class="n">tile_validator</span><span class="p">)</span>

        <span class="c1"># Now 2nd step approach:</span>
        <span class="c1"># if &quot;dev&quot; (= not final) render, we already know the &#39;raw&#39; arrays, so</span>
        <span class="c1"># just a postprocessing step</span>
        <span class="c1"># if &quot;final&quot; render, we compute on the fly</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">process_tiles</span><span class="p">(</span>
            <span class="n">chunk_slice</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">postdb_layer</span><span class="o">=</span><span class="n">postdb_layer</span><span class="p">,</span>
            <span class="n">tile_validator</span><span class="o">=</span><span class="n">tile_validator</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;img&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">save_images</span><span class="p">()</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Plotting images: done&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Saved layer database to </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">db_path</span><span class="si">}</span><span class="s2">: done&quot;</span><span class="p">)</span>


        <span class="c1"># Output data file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write_postproc_report</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">fs</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">inspect_calc</span><span class="p">:</span>
            <span class="c1"># Detailed debugging &quot;inspect_calc&quot; report</span>
            <span class="k">for</span> <span class="n">pbatch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postproc_batches</span><span class="p">:</span>
                <span class="n">calc_name</span> <span class="o">=</span> <span class="n">pbatch</span><span class="o">.</span><span class="n">calc_name</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write_inspect_calc</span><span class="p">(</span>
                    <span class="n">calc_name</span><span class="p">,</span> <span class="n">final</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">final_render</span>
                <span class="p">)</span>

        <span class="c1"># Clean-up</span>
        <span class="k">for</span> <span class="n">pbatch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postproc_batches</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">postproc_options</span><span class="p">[</span><span class="s2">&quot;final_render&quot;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s2">&quot;_subset_hook&quot;</span><span class="p">)</span>
                        <span class="ow">and</span> <span class="n">calc_name</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">_subset_hook</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">close_subset_mmap</span><span class="p">(</span><span class="n">calc_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">supersampling</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">clean_postproc_attr</span><span class="p">(</span><span class="n">when</span><span class="o">=</span><span class="s2">&quot;post&quot;</span><span class="p">)</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">try_recover</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Will we try to reopen saved image chunks ?&quot;&quot;&quot;</span>
        <span class="c1"># Nice to have ? Refactor of the logic: we could &quot;try recover&quot; if:</span>
        <span class="c1"># - we have a .postdb</span>
        <span class="c1"># - Its associated fingerprints collection matches with the fractal</span>
        <span class="c1"># - Its associated postproc collection file matches too</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">==</span> <span class="s2">&quot;img&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">postproc_options</span><span class="p">[</span><span class="s2">&quot;recovery_mode&quot;</span><span class="p">]</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">postproc_options</span><span class="p">[</span><span class="s2">&quot;final_render&quot;</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_db_recovery_mode</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">final_render</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Just an alias&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">postproc_options</span><span class="p">[</span><span class="s2">&quot;final_render&quot;</span><span class="p">]</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">supersampling</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Will really implement antialiasing ? &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">postproc_options</span><span class="p">[</span><span class="s2">&quot;final_render&quot;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">SUPERSAMPLING_DIC</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">postproc_options</span><span class="p">[</span><span class="s2">&quot;supersampling&quot;</span><span class="p">]]</span>
        <span class="c1"># Note: implicitely None by default...</span>

    <span class="nd">@Multithreading_iterator</span><span class="p">(</span>
        <span class="n">iterable_attr</span><span class="o">=</span><span class="s2">&quot;chunk_slices&quot;</span><span class="p">,</span> <span class="n">iter_kwargs</span><span class="o">=</span><span class="s2">&quot;chunk_slice&quot;</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">process_tiles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chunk_slice</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">postdb_layer</span><span class="p">,</span> <span class="n">tile_validator</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        postdb_layer: target layer in .postdb mode</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tile_validator</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">tile_validator</span><span class="p">(</span><span class="n">chunk_slice</span><span class="p">)):</span>
                <span class="k">return</span>

        <span class="c1"># 0) early exit if already computed: push the image tiles</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">try_recover</span> <span class="ow">and</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;img&quot;</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fractal</span>
            <span class="n">rank</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">chunk_rank</span><span class="p">(</span><span class="n">chunk_slice</span><span class="p">)</span>
            <span class="n">_mmap_status</span> <span class="o">=</span> <span class="n">open_memmap</span><span class="p">(</span>
                <span class="n">filename</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">postdb_status_path</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r+&quot;</span>
            <span class="p">)</span>
            <span class="n">is_valid</span> <span class="o">=</span> <span class="p">(</span><span class="n">_mmap_status</span><span class="p">[</span><span class="n">rank</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">_mmap_status</span>
            <span class="k">if</span> <span class="n">is_valid</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">layer</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">layers</span><span class="p">):</span>
                    <span class="c1"># We need the postproc</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">push_reloaded</span><span class="p">(</span>
                        <span class="n">chunk_slice</span><span class="p">,</span> <span class="n">layer</span><span class="o">=</span><span class="n">layer</span><span class="p">,</span> <span class="n">im</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_im</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="p">)</span>
                    <span class="c1"># TODO  &#39;update scaling&#39; may be invalid as we lost the</span>
                    <span class="c1"># data... would need a separate mmap to store min / max</span>
                <span class="n">f</span><span class="o">.</span><span class="n">incr_tiles_status</span><span class="p">(</span><span class="n">which</span><span class="o">=</span><span class="s2">&quot;Plot tiles&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">incr_tiles_status</span><span class="p">(</span><span class="n">chunk_slice</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
                <span class="k">return</span>

        <span class="k">if</span> <span class="s2">&quot;db&quot;</span> <span class="ow">in</span> <span class="n">mode</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;db&quot;</span><span class="p">:</span>
                <span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_status_path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">db_path</span><span class="p">())</span>
            <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;postdb&quot;</span><span class="p">:</span>
                <span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">postdb_status_path</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">postdb_path</span><span class="p">(</span><span class="n">postdb_layer</span><span class="p">)</span>
                <span class="p">)</span>

            <span class="n">rank</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fractal</span><span class="o">.</span><span class="n">chunk_rank</span><span class="p">(</span><span class="n">chunk_slice</span><span class="p">)</span>
            <span class="n">_db_status</span> <span class="o">=</span> <span class="n">open_memmap</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r+&quot;</span><span class="p">)</span>
            <span class="n">is_valid</span> <span class="o">=</span> <span class="p">(</span><span class="n">_db_status</span><span class="p">[</span><span class="n">rank</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">_db_status</span>
            <span class="k">if</span> <span class="n">is_valid</span><span class="p">:</span>
                <span class="c1"># Nothing to compute here, skipping this CALC</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipping db calculation for tile </span><span class="si">{</span><span class="n">chunk_slice</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">return</span>


        <span class="c1"># 1) Compute the raw postprocs for this field</span>
        <span class="n">n_pp</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">posts</span><span class="p">)</span>
        <span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">ixx</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">iyy</span><span class="p">)</span> <span class="o">=</span> <span class="n">chunk_slice</span>
        <span class="n">npts</span> <span class="o">=</span> <span class="p">(</span><span class="n">ixx</span> <span class="o">-</span> <span class="n">ix</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">iyy</span> <span class="o">-</span> <span class="n">iy</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">supersampling</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">npts</span> <span class="o">=</span> <span class="n">npts</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">supersampling</span> <span class="o">**</span> <span class="mi">2</span>

        <span class="n">arr_shp</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_pp</span><span class="p">,</span> <span class="n">npts</span><span class="p">)</span>
        <span class="n">raw_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">arr_shp</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">post_dtype</span><span class="p">)</span>

        <span class="n">batch_first_post</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># index of the first post for the current batch</span>
        <span class="n">is_ok</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">batch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postproc_batches</span><span class="p">:</span>
            <span class="c1"># Do the real job</span>
            <span class="n">is_ok</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_raw_arr</span><span class="p">(</span>
                <span class="n">raw_arr</span><span class="p">,</span> <span class="n">chunk_slice</span><span class="p">,</span> <span class="n">batch</span><span class="p">,</span> <span class="n">batch_first_post</span>
            <span class="p">)</span>
            <span class="c1"># Just count index</span>
            <span class="n">batch_first_post</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">batch</span><span class="o">.</span><span class="n">posts</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_ok</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_raw_arr</span><span class="p">[</span><span class="n">chunk_slice</span><span class="p">]</span> <span class="o">=</span> <span class="n">raw_arr</span>

        <span class="c1"># 2) Push each layer crop to the relevant image </span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">layer</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">layers</span><span class="p">):</span>
            <span class="n">layer</span><span class="o">.</span><span class="n">update_scaling</span><span class="p">(</span><span class="n">chunk_slice</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;img&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">layer</span><span class="o">.</span><span class="n">output</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">push_cropped</span><span class="p">(</span>
                        <span class="n">chunk_slice</span><span class="p">,</span> <span class="n">layer</span><span class="o">=</span><span class="n">layer</span><span class="p">,</span> <span class="n">im</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_im</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ilayer</span><span class="o">=</span><span class="n">i</span>
                    <span class="p">)</span>
            <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;db&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">push_db</span><span class="p">(</span><span class="n">chunk_slice</span><span class="p">,</span> <span class="n">layer</span><span class="o">=</span><span class="n">layer</span><span class="p">)</span>

        <span class="c1"># Push the postdb layer at the end only (in case some blending occurs)</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;postdb&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">push_postdb</span><span class="p">(</span><span class="n">chunk_slice</span><span class="p">,</span> <span class="n">layer</span><span class="o">=</span><span class="n">postdb_layer</span><span class="p">)</span>

        <span class="c1"># clean-up</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">incr_tiles_status</span><span class="p">(</span><span class="n">chunk_slice</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">postdb_layer</span><span class="p">)</span> <span class="c1"># mmm not really but...</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw_arr</span><span class="p">[</span><span class="n">chunk_slice</span><span class="p">]</span>


    <span class="k">def</span> <span class="nf">fill_raw_arr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raw_arr</span><span class="p">,</span> <span class="n">chunk_slice</span><span class="p">,</span> <span class="n">batch</span><span class="p">,</span> <span class="n">batch_first_post</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Compute &amp; store temporary arrays for this postproc batch</span>
<span class="sd">            Note : inc_postproc_rank rank shift to take into account potential</span>
<span class="sd">            other batches for this plotter.</span>
<span class="sd">            (memory mapping version)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fractal</span>
        <span class="n">inc</span> <span class="o">=</span> <span class="n">batch_first_post</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">postproc</span><span class="p">(</span><span class="n">batch</span><span class="p">,</span> <span class="n">chunk_slice</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">postproc_options</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ret</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Interrupted calculation</span>
            <span class="k">return</span> <span class="mi">1</span>

        <span class="n">post_array</span><span class="p">,</span> <span class="n">subset</span> <span class="o">=</span> <span class="n">ret</span>
        <span class="n">arr_1d</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">reshape1d</span><span class="p">(</span>
            <span class="n">post_array</span><span class="p">,</span> <span class="n">subset</span><span class="p">,</span> <span class="n">chunk_slice</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">supersampling</span>
        <span class="p">)</span>
        <span class="n">n_posts</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">arr_1d</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">raw_arr</span><span class="p">[</span><span class="n">inc</span><span class="p">:</span> <span class="p">(</span><span class="n">inc</span> <span class="o">+</span> <span class="n">n_posts</span><span class="p">),</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">arr_1d</span>
        <span class="k">return</span> <span class="mi">0</span> <span class="c1"># OK</span>


    <span class="k">def</span> <span class="nf">incr_tiles_status</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chunk_slice</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">postdb_layer</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the GUI and the tile-status tracking files</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fractal</span>
        <span class="n">curr_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_tile</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_tile</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_val</span>

        <span class="n">prev_log</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_tile</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span>
        <span class="n">curr_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">time_diff</span> <span class="o">=</span> <span class="n">curr_time</span> <span class="o">-</span> <span class="n">prev_log</span>
        
        <span class="n">ntiles</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">chunks_count</span>
        <span class="n">bool_log</span> <span class="o">=</span> <span class="p">((</span><span class="n">time_diff</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">curr_val</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">curr_val</span> <span class="o">==</span> <span class="n">ntiles</span><span class="p">))</span>
        
        <span class="c1"># Marking this chunk as valid (in case of &#39;final render&#39;)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">final_render</span> <span class="ow">and</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;img&quot;</span><span class="p">):</span>
            <span class="n">rank</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">chunk_rank</span><span class="p">(</span><span class="n">chunk_slice</span><span class="p">)</span>
            <span class="n">_mmap_status</span> <span class="o">=</span> <span class="n">open_memmap</span><span class="p">(</span>
                <span class="n">filename</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">postdb_status_path</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r+&quot;</span>
            <span class="p">)</span>
            <span class="n">_mmap_status</span><span class="p">[</span><span class="n">rank</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">del</span> <span class="n">_mmap_status</span>
        
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;db&quot;</span><span class="p">:</span>
            <span class="n">rank</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">chunk_rank</span><span class="p">(</span><span class="n">chunk_slice</span><span class="p">)</span>
            <span class="n">_db_status</span> <span class="o">=</span> <span class="n">open_memmap</span><span class="p">(</span>
                <span class="n">filename</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">db_status_path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">db_path</span><span class="p">()),</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r+&quot;</span>
            <span class="p">)</span>
            <span class="n">_db_status</span><span class="p">[</span><span class="n">rank</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">del</span> <span class="n">_db_status</span>

        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;postdb&quot;</span><span class="p">:</span>
            <span class="n">rank</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">chunk_rank</span><span class="p">(</span><span class="n">chunk_slice</span><span class="p">)</span>
            <span class="n">_db_status</span> <span class="o">=</span> <span class="n">open_memmap</span><span class="p">(</span>
                <span class="n">filename</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">postdb_status_path</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">postdb_path</span><span class="p">(</span><span class="n">postdb_layer</span><span class="p">)</span>
                <span class="p">),</span>
                <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r+&quot;</span>
            <span class="p">)</span>
            <span class="n">_db_status</span><span class="p">[</span><span class="n">rank</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">del</span> <span class="n">_db_status</span>


        <span class="k">if</span> <span class="n">bool_log</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_current_tile</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_time</span>
            <span class="n">str_val</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">curr_val</span><span class="p">)</span><span class="o">+</span> <span class="s2">&quot; / &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">chunks_count</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Image output: </span><span class="si">{</span><span class="n">str_val</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">get_2d_arr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">post_index</span><span class="p">,</span> <span class="n">chunk_slice</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a 2d view of a chunk for the given post-processed field</span>
<span class="sd">        Note that the PIL convention is followed for the coordinates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw_arr</span><span class="p">[</span><span class="n">chunk_slice</span><span class="p">][</span><span class="n">post_index</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">ixx</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">iyy</span><span class="p">)</span> <span class="o">=</span> <span class="n">chunk_slice</span>
        <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">ixx</span> <span class="o">-</span> <span class="n">ix</span><span class="p">,</span> <span class="n">iyy</span> <span class="o">-</span> <span class="n">iy</span>
        
        <span class="n">ssg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">supersampling</span>
        <span class="k">if</span> <span class="n">ssg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nx</span> <span class="o">*=</span> <span class="n">ssg</span>
            <span class="n">ny</span> <span class="o">*=</span> <span class="n">ssg</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="p">(</span><span class="n">ny</span><span class="p">,</span> <span class="n">nx</span><span class="p">))</span>


    <span class="k">def</span> <span class="nf">write_postproc_report</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">txt_report_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fractal</span><span class="o">.</span><span class="n">txt_report_path</span>

        <span class="k">def</span> <span class="nf">write_layer_report</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">layer</span><span class="p">,</span> <span class="n">report</span><span class="p">):</span>
            <span class="n">report</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot; - Layer #</span><span class="si">{}</span><span class="s2"> :</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
            <span class="n">postname</span> <span class="o">=</span> <span class="n">layer</span><span class="o">.</span><span class="n">postname</span>
            <span class="n">report</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;post-processing: `</span><span class="si">{}</span><span class="s2">`</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">postname</span><span class="p">))</span>
            <span class="n">report</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;kind: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">layer</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
            <span class="n">report</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;func: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">_func_arg</span><span class="p">))</span>

            <span class="n">mask</span> <span class="o">=</span> <span class="n">layer</span><span class="o">.</span><span class="n">mask</span>
            <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">mask_str</span> <span class="o">=</span> <span class="s2">&quot;None&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mask_str</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> `</span><span class="si">{}</span><span class="s2">` with mask color: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">type</span><span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                    <span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">postname</span><span class="p">,</span>
                    <span class="n">mask</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">report</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;mask: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mask_str</span><span class="p">))</span>

            <span class="n">report</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;output: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">output</span><span class="p">))</span>
            <span class="n">report</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;min: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">min</span><span class="p">))</span>
            <span class="n">report</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;max: </span><span class="si">{}</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">max</span><span class="p">))</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">txt_report_path</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">report</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">layer</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">layers</span><span class="p">):</span>
                <span class="n">write_layer_report</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">layer</span><span class="p">,</span> <span class="n">report</span><span class="p">)</span>
        
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">textwrap</span><span class="o">.</span><span class="n">dedent</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">            Plotting image - postprocessing fields info saved to:</span>
<span class="s2">              </span><span class="si">{</span><span class="n">txt_report_path</span><span class="si">}</span><span class="s2">&quot;&quot;&quot;</span>
        <span class="p">))</span>


    <span class="k">def</span> <span class="nf">image_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">layer</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">layer</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">layer</span><span class="o">.</span><span class="n">postname</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">open_images</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Open </span>
<span class="sd">         - the image files</span>
<span class="sd">         - the associated memory mappings in case of &quot;final render&quot;</span>
<span class="sd">        (&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_im</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">layers</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">layer</span><span class="o">.</span><span class="n">output</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_im</span> <span class="o">+=</span> <span class="p">[</span><span class="n">PIL</span><span class="o">.</span><span class="n">Image</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="n">layer</span><span class="o">.</span><span class="n">mode</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">try_recover</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">open_postdb</span><span class="p">(</span><span class="n">layer</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_im</span> <span class="o">+=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">final_render</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">try_recover</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Reloading option disabled, all image recomputed&quot;</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">save_images</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Writes the images to disk &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">layer</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">layers</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">output</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="n">file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image_name</span><span class="p">(</span><span class="n">layer</span><span class="p">)</span>
            <span class="n">base_img_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plot_dir</span><span class="p">,</span> <span class="n">file_name</span> <span class="o">+</span> <span class="s2">&quot;.png&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">save_tagged</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_im</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">base_img_path</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fractal</span><span class="o">.</span><span class="n">tag</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">save_tagged</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="n">img_path</span><span class="p">,</span> <span class="n">tag_dict</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Saves *img* to png format at *path*, tagging with *tag_dict*.</span>
<span class="sd">        https://dev.exiv2.org/projects/exiv2/wiki/The_Metadata_in_PNG_files</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pnginfo</span> <span class="o">=</span> <span class="n">PIL</span><span class="o">.</span><span class="n">PngImagePlugin</span><span class="o">.</span><span class="n">PngInfo</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">tag_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">pnginfo</span><span class="o">.</span><span class="n">add_text</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">output_context</span><span class="p">[</span><span class="s2">&quot;doc&quot;</span><span class="p">]</span>
            <span class="ow">and</span> <span class="ow">not</span><span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">output_context</span><span class="p">[</span><span class="s2">&quot;gui_iter&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)):</span>
            <span class="n">fs</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">add_figure</span><span class="p">(</span><span class="n">_Pillow_figure</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">pnginfo</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">img</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">img_path</span><span class="p">,</span> <span class="n">pnginfo</span><span class="o">=</span><span class="n">pnginfo</span><span class="p">)</span>
            
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">textwrap</span><span class="o">.</span><span class="n">dedent</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">                Image of shape </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s2"> saved to:</span>
<span class="s2">                  </span><span class="si">{</span><span class="n">img_path</span><span class="si">}</span><span class="s2">&quot;&quot;&quot;</span>
            <span class="p">))</span>


    <span class="k">def</span> <span class="nf">push_cropped</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chunk_slice</span><span class="p">,</span> <span class="n">layer</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">ilayer</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; push &quot;cropped image&quot; from layer for this chunk to the image&quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">ixx</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">iyy</span><span class="p">)</span> <span class="o">=</span> <span class="n">chunk_slice</span>
        <span class="n">crop_slice</span> <span class="o">=</span> <span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ixx</span><span class="p">,</span> <span class="n">iyy</span><span class="p">)</span>

        <span class="c1"># Key: Calling get_2d_arr</span>
        <span class="n">paste_crop</span> <span class="o">=</span> <span class="n">layer</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="n">chunk_slice</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">paste_crop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">supersampling</span><span class="p">:</span>
            <span class="c1"># Here, we should apply a resizing filter</span>
            <span class="n">resample</span> <span class="o">=</span> <span class="n">PIL</span><span class="o">.</span><span class="n">Image</span><span class="o">.</span><span class="n">LANCZOS</span>
            <span class="n">paste_crop</span> <span class="o">=</span> <span class="n">paste_crop</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span>
                <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">ixx</span> <span class="o">-</span> <span class="n">ix</span><span class="p">,</span> <span class="n">iyy</span> <span class="o">-</span> <span class="n">iy</span><span class="p">),</span>
                <span class="n">resample</span><span class="o">=</span><span class="n">resample</span><span class="p">,</span>
                <span class="n">box</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">reducing_gap</span><span class="o">=</span><span class="kc">None</span>
            <span class="p">)</span>

        <span class="c1"># left, upper, right, and lower pixel</span>
        <span class="n">im</span><span class="o">.</span><span class="n">paste</span><span class="p">(</span><span class="n">paste_crop</span><span class="p">,</span> <span class="n">box</span><span class="o">=</span><span class="n">crop_slice</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">final_render</span><span class="p">:</span>
            <span class="c1"># NOW let&#39;s also try to save this beast</span>
            <span class="n">paste_crop_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">paste_crop</span><span class="p">)</span>
            
            <span class="n">layer_mmap</span> <span class="o">=</span> <span class="n">open_memmap</span><span class="p">(</span>
                <span class="n">filename</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">postdb_path</span><span class="p">(</span><span class="n">layer</span><span class="p">),</span>
                <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r+&quot;</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">layer_mmap</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># For a 1-channel image, PIL will remove the last dim...</span>
                <span class="n">layer_mmap</span><span class="p">[</span><span class="n">iy</span><span class="p">:</span> <span class="n">iyy</span><span class="p">,</span> <span class="n">ix</span><span class="p">:</span> <span class="n">ixx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">paste_crop_arr</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">layer_mmap</span><span class="p">[</span><span class="n">iy</span><span class="p">:</span> <span class="n">iyy</span><span class="p">,</span> <span class="n">ix</span><span class="p">:</span> <span class="n">ixx</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">paste_crop_arr</span>

            <span class="k">del</span> <span class="n">layer_mmap</span>


    <span class="k">def</span> <span class="nf">push_reloaded</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chunk_slice</span><span class="p">,</span> <span class="n">layer</span><span class="p">,</span> <span class="n">im</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Copy the already computed pixels and paste them in the image&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">im</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">ixx</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">iyy</span><span class="p">)</span> <span class="o">=</span> <span class="n">chunk_slice</span>
        <span class="n">crop_slice</span> <span class="o">=</span> <span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ixx</span><span class="p">,</span> <span class="n">iyy</span><span class="p">)</span>
        
        <span class="n">layer_mmap</span> <span class="o">=</span> <span class="n">open_memmap</span><span class="p">(</span>
            <span class="n">filename</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">postdb_path</span><span class="p">(</span><span class="n">layer</span><span class="p">),</span>
            <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r+&quot;</span>
        <span class="p">)</span>
        <span class="n">crop_arr</span> <span class="o">=</span> <span class="n">layer_mmap</span><span class="p">[</span><span class="n">iy</span><span class="p">:</span> <span class="n">iyy</span><span class="p">,</span> <span class="n">ix</span><span class="p">:</span> <span class="n">ixx</span><span class="p">,</span> <span class="p">:]</span>

        <span class="c1"># If crop_arr has only 1 channel, like grey or bool, Pillow won&#39;t</span>
        <span class="c1"># handle it...</span>
        <span class="k">if</span> <span class="n">crop_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">crop_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">crop_arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">paste_crop</span> <span class="o">=</span> <span class="n">PIL</span><span class="o">.</span><span class="n">Image</span><span class="o">.</span><span class="n">fromarray</span><span class="p">(</span><span class="n">crop_arr</span><span class="p">)</span>
        <span class="n">im</span><span class="o">.</span><span class="n">paste</span><span class="p">(</span><span class="n">paste_crop</span><span class="p">,</span> <span class="n">box</span><span class="o">=</span><span class="n">crop_slice</span><span class="p">)</span>

        <span class="k">del</span> <span class="n">layer_mmap</span>

<span class="c1">#==============================================================================</span>
<span class="c1"># Memory-mapping related operations</span>
<span class="c1">#==============================================================================</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">relpath</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Generic relative path for the db, might be set by save_db</span>
<span class="sd">        defaults to None &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_relpath</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        

    <span class="c1"># def image_name(self, layer, relpath=None):</span>
    <span class="k">def</span> <span class="nf">db_path</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Absolute path of the file storing layers data (as float)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">head</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">tail</span> <span class="o">=</span> <span class="s2">&quot;layers&quot;</span>

        <span class="n">relpath</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">relpath</span>
        <span class="k">if</span> <span class="n">relpath</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">)</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">relpath</span><span class="p">)</span>
            <span class="n">tail</span><span class="p">,</span> <span class="n">user_ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">tail</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">user_ext</span> <span class="o">!=</span> <span class="s2">&quot;.db&quot;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Expecting a .db extension, given: </span><span class="si">{</span><span class="n">user_ext</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">tail</span><span class="si">}</span><span class="s2">.db&quot;</span>

        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span>
                <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fractal</span><span class="o">.</span><span class="n">directory</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>
        <span class="p">)</span>


    <span class="c1"># def image_name(self, layer, relpath=None):</span>
    <span class="k">def</span> <span class="nf">postdb_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">layer</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Absolute path for the file storing layer image data (as rgb array)</span>
<span class="sd">        layer: Layer instance (not the postname)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Final render mmap backup files default to ./data directory </span>
        <span class="n">head</span> <span class="o">=</span> <span class="s2">&quot;data&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">==</span> <span class="s2">&quot;img&quot;</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
        <span class="n">tail</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="n">relpath</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">relpath</span>
        <span class="k">if</span> <span class="n">relpath</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">)</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">relpath</span><span class="p">)</span>
            <span class="n">tail</span><span class="p">,</span> <span class="n">user_ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">tail</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">user_ext</span> <span class="o">!=</span> <span class="s2">&quot;.postdb&quot;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Expecting a .postdb extension, given: </span><span class="si">{</span><span class="n">user_ext</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">.postdb&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">tail</span><span class="p">,</span>
            <span class="nb">type</span><span class="p">(</span><span class="n">layer</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">layer</span><span class="o">.</span><span class="n">postname</span> <span class="c1"># i.e.: layer_obj.postname</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span>
                <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fractal</span><span class="o">.</span><span class="n">directory</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>
        <span class="p">)</span>


<div class="viewcode-block" id="Fractal_plotter.save_db">
<a class="viewcode-back" href="../../API/core.html#fractalshades.Fractal_plotter.save_db">[docs]</a>
    <span class="k">def</span> <span class="nf">save_db</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">relpath</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">postdb_layer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">recovery_mode</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Saves the post-processed data in a numpy structured memmap.</span>

<span class="sd">        Goes through all the registered layers and stores the results in a </span>
<span class="sd">        (nposts, ny, nx) memory mapping - with PIL-compliant coordinate</span>
<span class="sd">        indexing order.</span>
<span class="sd">        In case of supersampling all data points are stored (Downsampling </span>
<span class="sd">        filtering is delayed to the coloring stage), unless the `postdb` option</span>
<span class="sd">        is activated.</span>
<span class="sd">        A companion text file &lt;relpath&gt;.info is also written: it provides a</span>
<span class="sd">        short description of the data structure.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        relpath : Optional, str</span>
<span class="sd">            path relative to self.fractal.directory. If not provided, defaults</span>
<span class="sd">            to either:</span>

<span class="sd">                - :code:`&quot;layers.db&quot;` (when parameter`postdb_layer` is not</span>
<span class="sd">                  provided, and all layers are saved as float)</span>
<span class="sd">                - :code:`f&quot;{postdb_layer}.postdb&quot;` (when parameter</span>
<span class="sd">                  `postdb_layer` is provided, and this layer is saved as rgb)</span>
<span class="sd">        postdb_layer : Optional, str</span>
<span class="sd">            If provided, instead of saving all the layers, saves the layer with</span>
<span class="sd">            this name as a rgb array (ny, nx, nchannels) memory mapping, with</span>
<span class="sd">            extension \*.postdb. This offers less flexibility (post processing</span>
<span class="sd">            is &#39;frozen&#39;) but optimises performances &amp; disk use - esp. in case</span>
<span class="sd">            of supersampling as L2 downsampling filter can  be applied before</span>
<span class="sd">            storing the image data.</span>
<span class="sd">        recovery_mode : bool</span>
<span class="sd">            If True, will attempt to reload the .db / .postdb tiles already</span>
<span class="sd">            computed. Allows to restart an interrupted calculation (this will</span>
<span class="sd">            result in a &#39;patchwork&#39; if plotting parameters have been modified).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The file extension is either :</span>

<span class="sd">          - .db (denoting the float values of fields are saved)</span>
<span class="sd">          - .postdb (denoting the rgb arrays are saved) </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_relpath</span> <span class="o">=</span> <span class="n">relpath</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">=</span> <span class="n">mode</span> <span class="o">=</span> <span class="s2">&quot;postdb&quot;</span> <span class="k">if</span> <span class="n">postdb_layer</span> <span class="k">else</span> <span class="s2">&quot;db&quot;</span>
        
        <span class="k">if</span> <span class="n">postdb_layer</span><span class="p">:</span>
            <span class="n">any_db_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">postdb_path</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">postdb_layer</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">any_db_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_path</span><span class="p">()</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">save_db_recovery_mode</span> <span class="o">=</span> <span class="n">recovery_mode</span>

        <span class="n">proj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fractal</span><span class="o">.</span><span class="n">projection</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">proj</span><span class="p">,</span> <span class="n">fractalshades</span><span class="o">.</span><span class="n">projection</span><span class="o">.</span><span class="n">Expmap</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">save_expdb_by_steps</span><span class="p">(</span><span class="n">postdb_layer</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">postdb_layer</span><span class="o">=</span><span class="n">postdb_layer</span><span class="p">)</span>

        <span class="c1"># Writes a short description of the db</span>
        <span class="n">info_path</span> <span class="o">=</span> <span class="n">any_db_path</span> <span class="o">+</span> <span class="s2">&quot;.info&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">info_path</span><span class="p">,</span> <span class="s1">&#39;w+&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">info_file</span><span class="p">:</span>
            <span class="n">info_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Db file description</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
            <span class="n">info_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;written time: </span><span class="si">{</span><span class="n">now</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">info_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;recovery_mode: </span><span class="si">{recovery_mode}</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">info_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;*array description*</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">info_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  dtype: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">post_dtype</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">postnames</span><span class="p">),)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_shape</span>
            <span class="n">info_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  shape: </span><span class="si">{</span><span class="n">shape</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">ss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">supersampling</span>
            <span class="n">info_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  supersampling: </span><span class="si">{</span><span class="n">ss</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">info_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  postdb_layer: </span><span class="si">{</span><span class="n">postdb_layer</span><span class="si">}</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">info_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;*fields description*</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">pn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postnames</span><span class="p">:</span>
                <span class="n">info_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">pn</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">any_db_path</span></div>



    <span class="k">def</span> <span class="nf">save_expdb_by_steps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">postdb_layer</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Specialised flow for large exp mappings using steps in zoom</span>
<span class="sd">        mode is &quot;db&quot; or &quot;postdb&quot;</span>

<span class="sd">        For an exponential zoom covering a very large range, it is more</span>
<span class="sd">        efficient to evalutate the bilinear validity radius at successive</span>
<span class="sd">        depths. This setting tells the program to recompute the billinear</span>
<span class="sd">        validity radius for a tile whose ending pixels differs from the</span>
<span class="sd">        last reference from more than `exp_zoom_step` (in the `h`</span>
<span class="sd">        direction). Only valid with a</span>
<span class="sd">        `fractalshades.projection.Expmap` projection and for perturbation</span>
<span class="sd">        fractals.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fractal</span>
        <span class="n">proj</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">projection</span>
        <span class="n">orientation</span> <span class="o">=</span> <span class="n">proj</span><span class="o">.</span><span class="n">orientation</span>
        <span class="n">exp_zoom_step</span> <span class="o">=</span> <span class="n">proj</span><span class="o">.</span><span class="n">nt</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

        <span class="n">hmin</span> <span class="o">=</span> <span class="n">proj</span><span class="o">.</span><span class="n">hmin</span>
        <span class="n">hmax</span> <span class="o">=</span> <span class="n">proj</span><span class="o">.</span><span class="n">hmax</span>
        <span class="n">nh</span> <span class="o">=</span> <span class="n">proj</span><span class="o">.</span><span class="n">nh</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="n">stp</span> <span class="o">=</span> <span class="n">exp_zoom_step</span> 
        <span class="n">chunk_size</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">chunk_size</span>

        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nh</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">stp</span><span class="p">):</span>
            <span class="c1"># Need to trigger a recalculation of BLA validity radius</span>
            <span class="c1"># we will call reset_bla_tree and modify in place cycle_indep_args</span>
            <span class="n">i_max</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="n">stp</span><span class="p">,</span> <span class="n">nh</span><span class="p">)</span>
            <span class="n">i_min</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">chunk_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> 
            <span class="n">exp_step_hmax</span> <span class="o">=</span> <span class="p">(</span><span class="n">hmax</span> <span class="o">*</span> <span class="n">i_max</span> <span class="o">+</span> <span class="n">hmin</span> <span class="o">*</span> <span class="p">(</span><span class="n">nh</span> <span class="o">-</span> <span class="n">i_max</span><span class="p">))</span> <span class="o">/</span> <span class="n">nh</span>
            <span class="n">exp_step_hmin</span> <span class="o">=</span> <span class="p">(</span><span class="n">hmax</span> <span class="o">*</span> <span class="n">i_min</span> <span class="o">+</span> <span class="n">hmin</span> <span class="o">*</span> <span class="p">(</span><span class="n">nh</span> <span class="o">-</span> <span class="n">i_min</span><span class="p">))</span> <span class="o">/</span> <span class="n">nh</span>

            <span class="n">proj</span><span class="o">.</span><span class="n">set_exp_zoom_step</span><span class="p">(</span><span class="n">exp_step_hmax</span><span class="p">,</span> <span class="n">exp_step_hmin</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reset_bla_tree</span><span class="p">()</span>

            <span class="k">def</span> <span class="nf">validates_h</span><span class="p">(</span><span class="n">chunk_slice</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot; Escapes the tiles not matching the target h range&quot;&quot;&quot;</span>
                <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">ixx</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">chunk_slice</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">ixx</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="n">stp</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">ret</span>

            <span class="k">def</span> <span class="nf">validates_v</span><span class="p">(</span><span class="n">chunk_slice</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot; Escapes the tiles not matching the target h range&quot;&quot;&quot;</span>
                <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">iyy</span><span class="p">)</span> <span class="o">=</span> <span class="n">chunk_slice</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">iyy</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="n">stp</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">ret</span>

            <span class="n">validates</span> <span class="o">=</span> <span class="p">(</span><span class="n">validates_h</span> <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s2">&quot;horizontal&quot;</span> 
                         <span class="k">else</span> <span class="n">validates_v</span><span class="p">)</span>

            <span class="c1"># manage the self._current_tile[&quot;value&quot;] increment</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_tiles_stack</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_tile</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_tiles_stack</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span>
                <span class="n">mode</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="p">,</span>
                <span class="n">postdb_layer</span><span class="o">=</span><span class="n">postdb_layer</span><span class="p">,</span>
                <span class="n">tile_validator</span><span class="o">=</span><span class="n">validates</span>
            <span class="p">)</span>

        <span class="n">proj</span><span class="o">.</span><span class="n">del_exp_zoom_step</span><span class="p">()</span>


    <span class="k">def</span> <span class="nf">reset_bla_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Reset the BLA tree used for calculation taking into account </span>
<span class="sd">        the projection modifications</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fractal</span>
        <span class="k">for</span> <span class="n">calc_name</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">_calc_data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">cycle_indep_args</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;cycle_indep_args&quot;</span><span class="p">]</span>
            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;cycle_indep_args&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">reset_bla_tree</span><span class="p">(</span><span class="n">cycle_indep_args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">open_any_db</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">postdb_layer</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Open a .db or .postdb according to mode, managing</span>
<span class="sd">           - the database memory mappings</span>
<span class="sd">           - its associated &quot;progress tracking&quot; [post]db_status</span>

<span class="sd">         Note that the .db size is inflated in case of supersampling, all data</span>
<span class="sd">         is stored - but not the .postdb size which is stored after</span>
<span class="sd">         image post-processing</span>
<span class="sd">         </span>
<span class="sd">         mode: &quot;db&quot; | &quot;postdb&quot;</span>
<span class="sd">         postdb_layer: Layer instance (the object, not the str postname)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;db&quot;</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">postdb_layer</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">open_db</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span><span class="s2">&quot;postdb&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">open_postdb</span><span class="p">(</span><span class="n">postdb_layer</span><span class="p">)</span>


<span class="c1">#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="c1"># Full mmap of the fields: .db</span>
    <span class="k">def</span> <span class="nf">open_db</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Specialized method for a .db memmap</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">db_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_path</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">open_db_status</span><span class="p">(</span><span class="n">db_path</span><span class="p">)</span>

        <span class="c1"># The db shape</span>
        <span class="n">ssg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">supersampling</span>
        <span class="n">ss_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_shape</span>
        <span class="n">db_field_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">postnames</span><span class="p">)</span> <span class="c1"># Accounting for 2-fields layers</span>
        <span class="k">if</span> <span class="n">ssg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ss_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ssg</span> <span class="o">*</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ss_shape</span><span class="p">)</span>
        <span class="n">expected_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">db_field_count</span><span class="p">,)</span> <span class="o">+</span> <span class="n">ss_shape</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">try_recover</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Invalidated db, as `recovery_mode` is set to False&quot;</span>
                <span class="p">)</span>
            <span class="n">_mmap_db</span> <span class="o">=</span> <span class="n">open_memmap</span><span class="p">(</span>
                <span class="n">filename</span><span class="o">=</span><span class="n">db_path</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span>
            <span class="p">)</span>

            <span class="c1"># Checking that the size matches...</span>
            <span class="n">valid</span> <span class="o">=</span> <span class="p">(</span><span class="n">expected_shape</span> <span class="o">==</span> <span class="n">_mmap_db</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">valid</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid db&quot;</span><span class="p">)</span>

            <span class="n">_db_status</span> <span class="o">=</span> <span class="n">open_memmap</span><span class="p">(</span>
                <span class="n">filename</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">db_status_path</span><span class="p">(</span><span class="n">db_path</span><span class="p">),</span>
                <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r+&quot;</span>
            <span class="p">)</span>
            <span class="n">valid_chunks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">_db_status</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">_db_status</span>
            <span class="k">del</span> <span class="n">_mmap_db</span>
            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fractal</span><span class="o">.</span><span class="n">chunks_count</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;Attempt to restart interrupted calculation,</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;    Valid database tiles found: </span><span class="si">{</span><span class="n">valid_chunks</span><span class="si">}</span><span class="s2"> / </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span>

        <span class="k">except</span> <span class="p">(</span><span class="ne">FileNotFoundError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Invalidated db, recomputing full db:</span><span class="se">\n</span><span class="s2">    </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Creates the new datatase == structured memory mapping</span>
        <span class="n">fs</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">mkdir_p</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">db_path</span><span class="p">))</span>
        <span class="n">_mmap_db</span> <span class="o">=</span> <span class="n">open_memmap</span><span class="p">(</span>
            <span class="n">filename</span><span class="o">=</span><span class="n">db_path</span><span class="p">,</span> 
            <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w+&#39;</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">post_dtype</span><span class="p">,</span>
            <span class="n">shape</span><span class="o">=</span><span class="n">expected_shape</span><span class="p">,</span>
            <span class="n">fortran_order</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">version</span><span class="o">=</span><span class="kc">None</span>
        <span class="p">)</span>
        <span class="c1"># Here as we didnt find information for this layer, sadly the whole</span>
        <span class="c1"># memory mapping is invalidated</span>
        <span class="n">_db_status</span> <span class="o">=</span> <span class="n">open_memmap</span><span class="p">(</span>
            <span class="n">filename</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">db_status_path</span><span class="p">(</span><span class="n">db_path</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r+&quot;</span>
        <span class="p">)</span>
        <span class="n">_db_status</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">del</span> <span class="n">_mmap_db</span>


    <span class="k">def</span> <span class="nf">db_status_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">db_path</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; returns the db_status_path if db_path is provided&quot;&quot;&quot;</span>
        <span class="n">root</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">db_path</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">root</span> <span class="o">+</span> <span class="s2">&quot;_status&quot;</span> <span class="o">+</span> <span class="n">ext</span>

    <span class="k">def</span> <span class="nf">open_db_status</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">db_path</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Small mmap array to flag the validated db tiles</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_chunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fractal</span><span class="o">.</span><span class="n">chunks_count</span>
        <span class="n">file_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_status_path</span><span class="p">(</span><span class="n">db_path</span><span class="p">)</span>
        <span class="n">fs</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">mkdir_p</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">file_path</span><span class="p">))</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Does layer the mmap already exists, and does it seems to suit</span>
            <span class="c1"># our need ?</span>
            <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">try_recover</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Invalidated db_status: `recovery_mode` is set to False&quot;</span>
                <span class="p">)</span>
            <span class="n">_db_status</span> <span class="o">=</span> <span class="n">open_memmap</span><span class="p">(</span>
                <span class="n">filename</span><span class="o">=</span><span class="n">file_path</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r+&quot;</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">_db_status</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">n_chunk</span><span class="p">,)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Incompatible shapes for plotter mmap_status&quot;</span><span class="p">)</span>

        <span class="k">except</span> <span class="p">(</span><span class="ne">FileNotFoundError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c1"># Lets create it from scratch</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;No valid db status file found - recompute db:</span><span class="se">\n</span><span class="s2">    </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="n">_db_status</span> <span class="o">=</span> <span class="n">open_memmap</span><span class="p">(</span>
                    <span class="n">filename</span><span class="o">=</span><span class="n">file_path</span><span class="p">,</span> 
                    <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w+&#39;</span><span class="p">,</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span>
                    <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n_chunk</span><span class="p">,),</span>
                    <span class="n">fortran_order</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">version</span><span class="o">=</span><span class="kc">None</span>
            <span class="p">)</span>
            <span class="n">_db_status</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">del</span> <span class="n">_db_status</span>


    <span class="k">def</span> <span class="nf">push_db</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chunk_slice</span><span class="p">,</span> <span class="n">layer</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; push &quot;postprocessed data&quot; (from the layer&#39;s postproc field)</span>
<span class="sd">        to the db memory mapping</span>
<span class="sd">        Note: Lanczos downsampling  is delayed to the image making stage,</span>
<span class="sd">        size might be inflated if &quot;final render + supersampling</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">ixx</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">iyy</span><span class="p">)</span> <span class="o">=</span> <span class="n">chunk_slice</span>

        <span class="n">field_count</span><span class="p">,</span> <span class="n">post_index</span> <span class="o">=</span> <span class="n">layer</span><span class="o">.</span><span class="n">get_postproc_index</span><span class="p">()</span>
        <span class="n">db_crop</span> <span class="o">=</span> <span class="n">layer</span><span class="o">.</span><span class="n">db_crop</span><span class="p">(</span><span class="n">chunk_slice</span><span class="p">)</span>

        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">supersampling</span>
        <span class="k">if</span> <span class="n">s</span><span class="p">:</span>
            <span class="c1"># Here, we inflate alls dims by s</span>
            <span class="n">ix</span> <span class="o">*=</span> <span class="n">s</span>
            <span class="n">ixx</span> <span class="o">*=</span> <span class="n">s</span>
            <span class="n">iy</span> <span class="o">*=</span> <span class="n">s</span>
            <span class="n">iyy</span> <span class="o">*=</span> <span class="n">s</span>

        <span class="n">db_mmap</span> <span class="o">=</span> <span class="n">open_memmap</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">db_path</span><span class="p">(),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r+&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">field_count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">db_mmap</span><span class="p">[</span><span class="n">post_index</span><span class="p">,</span> <span class="n">iy</span><span class="p">:</span><span class="n">iyy</span><span class="p">,</span> <span class="n">ix</span><span class="p">:</span><span class="n">ixx</span><span class="p">]</span> <span class="o">=</span> <span class="n">db_crop</span>
        <span class="k">elif</span> <span class="n">field_count</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">db_mmap</span><span class="p">[</span><span class="n">post_index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">iy</span><span class="p">:</span><span class="n">iyy</span><span class="p">,</span> <span class="n">ix</span><span class="p">:</span><span class="n">ixx</span><span class="p">]</span> <span class="o">=</span> <span class="n">db_crop</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
            <span class="n">db_mmap</span><span class="p">[</span><span class="n">post_index</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">iy</span><span class="p">:</span><span class="n">iyy</span><span class="p">,</span> <span class="n">ix</span><span class="p">:</span><span class="n">ixx</span><span class="p">]</span> <span class="o">=</span> <span class="n">db_crop</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
        <span class="k">del</span> <span class="n">db_mmap</span>

<span class="c1">#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="c1">## mmap of the image array: .postdb</span>

    <span class="k">def</span> <span class="nf">open_postdb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">layer</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Specialized method for a .postdb memmap</span>
<span class="sd">        It need the layer name because we reuse the same codepath</span>
<span class="sd">        for different layer (final render restart data)</span>
<span class="sd">        </span>
<span class="sd">        note: layer is layer obj</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        
        <span class="n">postdb_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">postdb_path</span><span class="p">(</span><span class="n">layer</span><span class="p">)</span>
        <span class="n">layer_name</span> <span class="o">=</span> <span class="n">layer</span><span class="o">.</span><span class="n">postname</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">open_postdb_status</span><span class="p">(</span><span class="n">postdb_path</span><span class="p">)</span>

        <span class="n">mode</span> <span class="o">=</span> <span class="n">layer</span><span class="o">.</span><span class="n">mode</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">Virtual_layer</span><span class="o">.</span><span class="n">DTYPE_FROM_MODE</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span>
        <span class="n">channel</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">Virtual_layer</span><span class="o">.</span><span class="n">N_CHANNEL_FROM_MODE</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span>
        <span class="n">expected_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_shape</span> <span class="o">+</span> <span class="p">(</span><span class="n">channel</span><span class="p">,)</span>

        <span class="c1"># Does the mmap already exists, and does it seems to suit our need ?</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Does layer the mmap already exists, and does it seems to suit</span>
            <span class="c1"># our need ?</span>
            <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">try_recover</span><span class="p">):</span> <span class="c1">#self.postproc_options[&quot;recovery_mode&quot;]):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Invalidated postdb: `recovery_mode` is set to False&quot;</span>
                <span class="p">)</span>
            <span class="n">_mmap_postdb</span> <span class="o">=</span> <span class="n">open_memmap</span><span class="p">(</span>
                <span class="n">filename</span><span class="o">=</span><span class="n">postdb_path</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r+&quot;</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">_mmap_postdb</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">expected_shape</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">_mmap_postdb</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Incompatible shapes for mmap, recomputing&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">_mmap_postdb</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">dtype</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">_mmap_postdb</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Incompatible dtype for mmap, recomputing&quot;</span><span class="p">)</span>

            <span class="n">_db_status</span> <span class="o">=</span> <span class="n">open_memmap</span><span class="p">(</span>
                <span class="n">filename</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">postdb_status_path</span><span class="p">(</span><span class="n">postdb_path</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r+&quot;</span>
            <span class="p">)</span>
            <span class="n">valid_chunks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">_db_status</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">_db_status</span>
            <span class="k">del</span> <span class="n">_mmap_postdb</span>
            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fractal</span><span class="o">.</span><span class="n">chunks_count</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;Attempt to restart interrupted calculation,</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;    Valid postdb tiles found: </span><span class="si">{</span><span class="n">valid_chunks</span><span class="si">}</span><span class="s2"> / </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span>


        <span class="k">except</span> <span class="p">(</span><span class="ne">FileNotFoundError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;No valid .postdb found for layer </span><span class="si">{</span><span class="n">layer_name</span><span class="si">}</span><span class="s2">:</span><span class="se">\n</span><span class="s2">    </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Create a new one...</span>
        <span class="n">mmap</span> <span class="o">=</span> <span class="n">open_memmap</span><span class="p">(</span>
            <span class="n">filename</span><span class="o">=</span><span class="n">postdb_path</span><span class="p">,</span> 
            <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w+&#39;</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">),</span>
            <span class="n">shape</span><span class="o">=</span><span class="n">expected_shape</span><span class="p">,</span>
            <span class="n">fortran_order</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">version</span><span class="o">=</span><span class="kc">None</span>
        <span class="p">)</span>
        <span class="c1"># Here as we didnt find information for this layer, sadly the whole</span>
        <span class="c1"># memory mapping is invalidated</span>
        <span class="n">_db_status</span> <span class="o">=</span> <span class="n">open_memmap</span><span class="p">(</span>
            <span class="n">filename</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">postdb_status_path</span><span class="p">(</span><span class="n">postdb_path</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r+&quot;</span>
        <span class="p">)</span>
        <span class="n">_db_status</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">del</span> <span class="n">_db_status</span>
        <span class="k">del</span> <span class="n">mmap</span>


    <span class="k">def</span> <span class="nf">postdb_status_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">postdb_path</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Return the postdb_status_path if db_path is provided &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">==</span> <span class="s2">&quot;img&quot;</span><span class="p">:</span>
            <span class="c1"># Default a unique status &quot;guard&quot; for a image layer set</span>
            <span class="n">postdb_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fractal</span><span class="o">.</span><span class="n">directory</span><span class="p">,</span> <span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="s2">&quot;final_render.postdb&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_status_path</span><span class="p">(</span><span class="n">postdb_path</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">open_postdb_status</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">postdb_path</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Open the postdb_status mmap if db_path is provided &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">==</span> <span class="s2">&quot;img&quot;</span><span class="p">:</span>
            <span class="c1"># Default a unique status &quot;guard&quot; for a image layer set</span>
            <span class="n">postdb_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fractal</span><span class="o">.</span><span class="n">directory</span><span class="p">,</span> <span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="s2">&quot;final_render.postdb&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">open_db_status</span><span class="p">(</span><span class="n">postdb_path</span><span class="p">)</span>
            

    <span class="k">def</span> <span class="nf">push_postdb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chunk_slice</span><span class="p">,</span> <span class="n">layer</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Push the image pixels to the back-up mmap (/!\Follows PIL block</span>
<span class="sd">        order) &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">ixx</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">iyy</span><span class="p">)</span> <span class="o">=</span> <span class="n">chunk_slice</span>
        <span class="n">paste_crop</span> <span class="o">=</span> <span class="n">layer</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="n">chunk_slice</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">paste_crop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="n">postdb_mmap</span> <span class="o">=</span> <span class="n">open_memmap</span><span class="p">(</span>
            <span class="n">filename</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">postdb_path</span><span class="p">(</span><span class="n">layer</span><span class="p">),</span>
            <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r+&quot;</span>
        <span class="p">)</span>

        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">supersampling</span>
        <span class="k">if</span> <span class="n">s</span><span class="p">:</span>
            <span class="n">resample</span> <span class="o">=</span> <span class="n">PIL</span><span class="o">.</span><span class="n">Image</span><span class="o">.</span><span class="n">LANCZOS</span>
            <span class="n">paste_crop</span> <span class="o">=</span> <span class="n">paste_crop</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span>
                <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">ixx</span> <span class="o">-</span> <span class="n">ix</span><span class="p">,</span> <span class="n">iyy</span> <span class="o">-</span> <span class="n">iy</span><span class="p">),</span> <span class="c1"># Note: Pillow order here</span>
                <span class="n">resample</span><span class="o">=</span><span class="n">resample</span><span class="p">,</span>
                <span class="n">box</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">reducing_gap</span><span class="o">=</span><span class="kc">None</span>
            <span class="p">)</span>

        <span class="n">postdb_mmap</span><span class="p">[</span><span class="n">iy</span><span class="p">:</span><span class="n">iyy</span><span class="p">,</span> <span class="n">ix</span><span class="p">:</span><span class="n">ixx</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">paste_crop</span><span class="p">)</span>

        <span class="k">del</span> <span class="n">postdb_mmap</span></div>



<span class="k">class</span> <span class="nc">_Null_status_wget</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fractal</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Internal class</span>
<span class="sd">        Emulates a status bar wget in case we do not use the GUI</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">status</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">status</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">fractal</span><span class="o">.</span><span class="n">new_status</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_status</span> <span class="o">=</span> <span class="n">status</span>

    <span class="k">def</span> <span class="nf">update_status</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">str_val</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Update the text status</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_status</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s2">&quot;str_val&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">str_val</span>


<div class="viewcode-block" id="Fractal">
<a class="viewcode-back" href="../../API/core.html#fractalshades.Fractal">[docs]</a>
<span class="k">class</span> <span class="nc">Fractal</span><span class="p">:</span>

    <span class="n">REPORT_ITEMS</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;chunk1d_begin&quot;</span><span class="p">,</span>
        <span class="s2">&quot;chunk1d_end&quot;</span><span class="p">,</span>
        <span class="s2">&quot;chunk_pts&quot;</span><span class="p">,</span>
        <span class="s2">&quot;done&quot;</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="n">SAVE_ARRS</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;Z&quot;</span><span class="p">,</span>
        <span class="s2">&quot;U&quot;</span><span class="p">,</span>
        <span class="s2">&quot;stop_reason&quot;</span><span class="p">,</span>
        <span class="s2">&quot;stop_iter&quot;</span>
    <span class="p">]</span>

    <span class="n">USER_INTERRUPTED</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># return code for a user-interrupted computation</span>

<div class="viewcode-block" id="Fractal.__init__">
<a class="viewcode-back" href="../../API/core.html#fractalshades.Fractal.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directory</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The base class for all escape-time fractals calculations.</span>

<span class="sd">Derived class should implement the actual calculation methods used in the</span>
<span class="sd">innner loop. This class provides the outer looping (calculation is run on </span>
<span class="sd">successive tiles), enables multiprocessing, and manage raw-result storing </span>
<span class="sd">and retrieving.</span>

<span class="sd">Parameters</span>
<span class="sd">----------</span>
<span class="sd">directory : str</span>
<span class="sd">    Path for the working base directory</span>


<span class="sd">Notes</span>
<span class="sd">-----</span>

<span class="sd">These notes describe implementation details and should be useful mostly to</span>
<span class="sd">advanced users when subclassing.</span>

<span class="sd">.. note::</span>

<span class="sd">    **Special methods**</span>
<span class="sd">    </span>
<span class="sd">    this class and its subclasses may define several methods decorated with</span>
<span class="sd">    specific tags:</span>
<span class="sd">    </span>
<span class="sd">    `fractalshades.zoom_options`</span>
<span class="sd">        decorates the method used to define the zooming</span>
<span class="sd">    `fractalshades.calc_options`</span>
<span class="sd">        decorates the methods defining the calculation inner-loop</span>
<span class="sd">    `fractalshades.interactive_options` </span>
<span class="sd">        decorates the methods that can be called</span>
<span class="sd">        interactively from the GUI (right-click then context menu selection).</span>
<span class="sd">        The coordinates of the click are passed to the called method.</span>


<span class="sd">.. note::</span>

<span class="sd">    **Saved data**</span>

<span class="sd">        The calculation raw results (raw output of the inner loop at exit) are</span>
<span class="sd">        saved to disk and internally accessed during plotting phase through</span>
<span class="sd">        memory-mapping. They are however not saved for a final render.</span>
<span class="sd">        These arrays are:</span>

<span class="sd">        subset    </span>
<span class="sd">            boolean</span>
<span class="sd">            Saved to disk as ``calc_name``\_Z.arr in ``data`` folder</span>
<span class="sd">        Z</span>
<span class="sd">            Complex fields, several fields can be defined and accessed through</span>
<span class="sd">            a field string identifier.</span>
<span class="sd">            Saved to disk as ``calc_name``\_Z.arr in ``data`` folder</span>
<span class="sd">        U</span>
<span class="sd">            Integer fields, several fields can be defined and accessed through</span>
<span class="sd">            a field string identifier.</span>
<span class="sd">            Saved to disk as ``calc_name``\_U.arr in ``data`` folder</span>
<span class="sd">        stop_reason</span>
<span class="sd">            Byte codes: the reasons for loop exit (max iteration reached ?</span>
<span class="sd">            overflow ? other ?)</span>
<span class="sd">            Saved to disk as ``calc_name_stop_reason.arr`` in ``data`` folder</span>
<span class="sd">        stop_iter</span>
<span class="sd">            Integer: iterations count at loop exit</span>
<span class="sd">            Saved to disk as ``calc_name``\_stop_iter.arr in ``data`` folder</span>

<span class="sd">        The string identifiers are stored in ``codes`` attributes.</span>
<span class="sd">&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">directory</span> <span class="o">=</span> <span class="n">directory</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subset</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_interrupted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
        
        <span class="c1"># datatypes used for raw data storing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">float_postproc_type</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">postproc_dtype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">termination_type</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">int_type</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span>

        <span class="c1"># Default listener</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_status_wget</span> <span class="o">=</span> <span class="n">_Null_status_wget</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">init_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Return a dict of parameters used during __init__ call&quot;&quot;&quot;</span>
        <span class="n">init_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="p">(</span>
            <span class="n">p_name</span><span class="p">,</span> <span class="n">param</span>
        <span class="p">)</span> <span class="ow">in</span> <span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="fm">__init__</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># By contract, __init__ params shall be stored as instance attrib.</span>
            <span class="c1"># (&#39;Fractal&#39; interface)</span>
            <span class="n">init_kwargs</span><span class="p">[</span><span class="n">p_name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p_name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">init_kwargs</span>

    <span class="k">def</span> <span class="nf">init_signature</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="fm">__init__</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Serialisation of a Fractal object. The fractal state (zoom, calc)</span>
<span class="sd">        is dropped and shall be re-instated externally if need be.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">init_kwargs</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">vals</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">script_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indent</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;String used to serialize this instance in GUI-generated scripts</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Mainly a call to __init__ with the directory tuned to be the </span>
        <span class="c1"># local variable `plot_dir`</span>
        <span class="n">fullname</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">Code_writer</span><span class="o">.</span><span class="n">fullname</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>

        <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_kwargs</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;directory&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">Rawcode</span><span class="p">(</span><span class="s2">&quot;plot_dir&quot;</span><span class="p">)</span> <span class="c1"># get rid of quotes</span>
        <span class="n">kwargs_code</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">Code_writer</span><span class="o">.</span><span class="n">func_args</span><span class="p">(</span>
            <span class="n">kwargs</span><span class="p">,</span> <span class="n">indent</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">False</span>
        <span class="p">)</span>
        <span class="n">shift</span>  <span class="o">=</span> <span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">indent</span> 

        <span class="n">str_call_init</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">fullname</span><span class="si">}</span><span class="s2">(</span><span class="se">\n</span><span class="si">{</span><span class="n">kwargs_code</span><span class="si">}{</span><span class="n">shift</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="k">return</span> <span class="n">str_call_init</span>


<div class="viewcode-block" id="Fractal.zoom">
<a class="viewcode-back" href="../../API/core.html#fractalshades.Fractal.zoom">[docs]</a>
    <span class="nd">@fs</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">zoom_options</span>
    <span class="k">def</span> <span class="nf">zoom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
             <span class="n">x</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">,</span>
             <span class="n">y</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">,</span>
             <span class="n">dx</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">8.</span><span class="p">,</span>
             <span class="n">nx</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">800</span><span class="p">,</span>
             <span class="n">xy_ratio</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">,</span>
             <span class="n">theta_deg</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">,</span>
             <span class="n">projection</span><span class="p">:</span> <span class="n">fs</span><span class="o">.</span><span class="n">projection</span><span class="o">.</span><span class="n">Projection</span><span class="o">=</span><span class="n">fs</span><span class="o">.</span><span class="n">projection</span><span class="o">.</span><span class="n">Cartesian</span><span class="p">(),</span>
             <span class="n">has_skew</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
             <span class="n">skew_00</span><span class="p">:</span><span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
             <span class="n">skew_01</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
             <span class="n">skew_10</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
             <span class="n">skew_11</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define and stores as class-attributes the zoom parameters for the next</span>
<span class="sd">        calculation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : float</span>
<span class="sd">            x-coordinate of the central point</span>
<span class="sd">        y : float </span>
<span class="sd">            y-coordinate of the central point</span>
<span class="sd">        dx : float</span>
<span class="sd">            span of the view rectangle along the x-axis</span>
<span class="sd">        nx : int</span>
<span class="sd">            number of pixels of the image along the x-axis</span>
<span class="sd">        xy_ratio: float</span>
<span class="sd">            ratio of dx / dy and nx / ny</span>
<span class="sd">        theta_deg : float</span>
<span class="sd">            Pre-rotation of the calculation domain, in degree</span>
<span class="sd">        projection : `fractalshades.projection.Projection`</span>
<span class="sd">            Kind of projection used (default to </span>
<span class="sd">            `fractalshades.projection.Cartesian`)</span>
<span class="sd">        has_skew : bool</span>
<span class="sd">            If True, unskew the view base on skew coefficients skew_ij</span>
<span class="sd">        skew_ij : float</span>
<span class="sd">            Components of the local skw matrix, ij = 00, 01, 10, 11</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Safeguard in case the GUI inputs were strings</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Float expected for x, y, dx&quot;</span><span class="p">)</span>

        <span class="c1"># Backward compatibility: also accept projection = &quot;cartesian&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">projection</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">textwrap</span><span class="o">.</span><span class="n">dedent</span><span class="p">(</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;\</span>
<span class="sd">                Use of str for projection is deprecated, and might be</span>
<span class="sd">                removed. Please use `fractalshades.projection.Projection`</span>
<span class="sd">                subclasses instead. Defaulting to</span>
<span class="sd">                `fractalshades.projection.Cartesian()`&quot;&quot;&quot;</span>
            <span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">projection</span> <span class="o">=</span> <span class="n">projection</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">projection</span><span class="o">.</span><span class="n">Cartesian</span><span class="p">()</span>

        <span class="c1"># Stores the skew matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_skew</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">has_skew</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_skew</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">((</span><span class="n">skew_00</span><span class="p">,</span> <span class="n">skew_01</span><span class="p">),</span> <span class="p">(</span><span class="n">skew_10</span><span class="p">,</span> <span class="n">skew_11</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">lin_mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lin_mat</span><span class="p">()</span>
        <span class="n">projection</span><span class="o">.</span><span class="n">adjust_to_zoom</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proj_impl</span> <span class="o">=</span> <span class="n">projection</span><span class="o">.</span><span class="n">f</span></div>



    <span class="k">def</span> <span class="nf">get_lin_mat</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Returns a numba-jitted function which apply the linear part of the</span>
<span class="sd">        transformation (rotation, skew, scale)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta_deg</span> <span class="o">/</span> <span class="mf">180.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">skew</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skew</span>

        <span class="c1"># Defines the linear matrix</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">lin_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(((</span><span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="n">s</span><span class="p">),</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">skew</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lin_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">skew</span><span class="p">,</span> <span class="n">lin_mat</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">lin_mat</span>


    <span class="k">def</span> <span class="nf">new_status</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wget</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Return a dictionnary that can hold the current progress status &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_status_wget</span> <span class="o">=</span> <span class="n">wget</span>
        <span class="n">status</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;Calc tiles&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;val&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                <span class="s2">&quot;str_val&quot;</span><span class="p">:</span> <span class="s2">&quot;- / -&quot;</span><span class="p">,</span>
                <span class="s2">&quot;last_log&quot;</span><span class="p">:</span> <span class="mf">0.</span>  <span class="c1"># time of last logged change in seconds</span>
            <span class="p">},</span>
            <span class="s2">&quot;Plot tiles&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;val&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                <span class="s2">&quot;str_val&quot;</span><span class="p">:</span> <span class="s2">&quot;- / -&quot;</span><span class="p">,</span>
                <span class="s2">&quot;last_log&quot;</span><span class="p">:</span> <span class="mf">0.</span>  <span class="c1"># time of last logged change in seconds</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">status</span>

    <span class="k">def</span> <span class="nf">set_status</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">str_val</span><span class="p">,</span> <span class="n">bool_log</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Just a simple text status &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_status_wget</span><span class="o">.</span><span class="n">update_status</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">str_val</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bool_log</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Status update </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">str_val</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">incr_tiles_status</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s2">&quot;Calc tiles&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Dealing with more complex status : </span>
<span class="sd">        Increase by 1 the number of computed tiles reported in status bar</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_status_wget</span><span class="o">.</span><span class="n">_status</span>
        <span class="n">curr_val</span> <span class="o">=</span> <span class="n">dic</span><span class="p">[</span><span class="n">which</span><span class="p">][</span><span class="s2">&quot;val&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">dic</span><span class="p">[</span><span class="n">which</span><span class="p">][</span><span class="s2">&quot;val&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_val</span>

        <span class="n">prev_event</span> <span class="o">=</span> <span class="n">dic</span><span class="p">[</span><span class="n">which</span><span class="p">][</span><span class="s2">&quot;last_log&quot;</span><span class="p">]</span>
        <span class="n">curr_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">time_diff</span> <span class="o">=</span> <span class="n">curr_time</span> <span class="o">-</span> <span class="n">prev_event</span>

        <span class="n">ntiles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunks_count</span>
        <span class="n">bool_log</span> <span class="o">=</span> <span class="p">((</span><span class="n">time_diff</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">curr_val</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">curr_val</span> <span class="o">==</span> <span class="n">ntiles</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">bool_log</span><span class="p">:</span>
            <span class="n">dic</span><span class="p">[</span><span class="n">which</span><span class="p">][</span><span class="s2">&quot;last_log&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_time</span>

        <span class="n">str_val</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">dic</span><span class="p">[</span><span class="n">which</span><span class="p">][</span><span class="s2">&quot;val&quot;</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot; / &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ntiles</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="n">which</span><span class="p">,</span> <span class="n">str_val</span><span class="p">,</span> <span class="n">bool_log</span><span class="p">)</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ny</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">xy_ratio</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">xy_ratio</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">px</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_px&quot;</span><span class="p">)):</span> <span class="c1"># is None:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_px</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nx</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_px</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">skew</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_skew&quot;</span><span class="p">)):</span> <span class="c1"># is None:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_skew</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skew</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">multiprocess_dir</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Directory used for multiprocess stdout stderr streams redirection</span>
<span class="sd">        :meta private:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">directory</span><span class="p">,</span> <span class="s2">&quot;multiproc_calc&quot;</span><span class="p">)</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">float_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">select</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">):</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">select</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">complex_type</span><span class="p">)]</span>


<div class="viewcode-block" id="Fractal.clean_up">
<a class="viewcode-back" href="../../API/core.html#fractalshades.Fractal.clean_up">[docs]</a>
    <span class="k">def</span> <span class="nf">clean_up</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calc_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deletes all saved data files associated with a given ``calc_name``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        calc_name : str | None</span>
<span class="sd">            The string identifying the calculation run for which we want to</span>
<span class="sd">            delete the files.</span>
<span class="sd">            If None, delete all calculation files</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">calc_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">calc_name</span> <span class="o">=</span> <span class="s2">&quot;*&quot;</span>

        <span class="n">patterns</span> <span class="o">=</span> <span class="p">(</span>
             <span class="n">calc_name</span> <span class="o">+</span> <span class="s2">&quot;_*.arr&quot;</span><span class="p">,</span>
             <span class="n">calc_name</span> <span class="o">+</span> <span class="s2">&quot;.report&quot;</span><span class="p">,</span>
             <span class="n">calc_name</span> <span class="o">+</span> <span class="s2">&quot;.fingerprint&quot;</span><span class="p">,</span>
             <span class="s2">&quot;*.postdb&quot;</span><span class="p">,</span> <span class="c1"># .postdb files are tagged by the output layer name</span>
             <span class="s2">&quot;ref_pt.dat&quot;</span><span class="p">,</span>
             <span class="s2">&quot;SA.dat&quot;</span>
        <span class="p">)</span>

        <span class="n">data_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">directory</span><span class="p">,</span> <span class="s2">&quot;data&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">data_dir</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">textwrap</span><span class="o">.</span><span class="n">dedent</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">                Clean-up cancelled, directory not found:</span>
<span class="s2">                  </span><span class="si">{</span><span class="n">data_dir</span><span class="si">}</span><span class="s2">&quot;&quot;&quot;</span>
            <span class="p">))</span>
            <span class="k">return</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">textwrap</span><span class="o">.</span><span class="n">dedent</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">            Cleaning data directory:</span>
<span class="s2">              </span><span class="si">{</span><span class="n">data_dir</span><span class="si">}</span><span class="s2">&quot;&quot;&quot;</span>
        <span class="p">))</span>

        <span class="k">for</span> <span class="n">pattern</span> <span class="ow">in</span> <span class="n">patterns</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">os</span><span class="o">.</span><span class="n">scandir</span><span class="p">(</span><span class="n">data_dir</span><span class="p">)</span> <span class="k">as</span> <span class="n">it</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">fnmatch</span><span class="o">.</span><span class="n">fnmatch</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">pattern</span><span class="p">)):</span>
                        <span class="n">os</span><span class="o">.</span><span class="n">unlink</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;File deleted: </span><span class="si">{</span><span class="n">entry</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Delete also the temporay attributes</span>
        <span class="n">temp_attrs</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;_FP_params&quot;</span><span class="p">,</span> <span class="s2">&quot;_Z_path&quot;</span><span class="p">,</span> <span class="s2">&quot;_SA_data&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">temp_attr</span> <span class="ow">in</span> <span class="n">temp_attrs</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">temp_attr</span><span class="p">):</span>
                <span class="nb">delattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">temp_attr</span><span class="p">)</span></div>

    
    <span class="k">def</span> <span class="nf">delete_fingerprint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Deletes the fingerprint files &quot;&quot;&quot;</span>
        <span class="n">patterns</span> <span class="o">=</span> <span class="p">(</span>
             <span class="s2">&quot;*.fingerprint&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">data_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">directory</span><span class="p">,</span> <span class="s2">&quot;data&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">data_dir</span><span class="p">):</span>
            <span class="k">return</span>
        <span class="k">for</span> <span class="n">pattern</span> <span class="ow">in</span> <span class="n">patterns</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">os</span><span class="o">.</span><span class="n">scandir</span><span class="p">(</span><span class="n">data_dir</span><span class="p">)</span> <span class="k">as</span> <span class="n">it</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">fnmatch</span><span class="o">.</span><span class="n">fnmatch</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">pattern</span><span class="p">)):</span>
                        <span class="n">os</span><span class="o">.</span><span class="n">unlink</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;File deleted: </span><span class="si">{</span><span class="n">entry</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">clean_postproc_attr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">when</span><span class="o">=</span><span class="s2">&quot;pre&quot;</span><span class="p">):</span>
        <span class="c1"># Deletes the postproc-related temporary attributes, thus forcing</span>
        <span class="c1"># a recompute of invalidated data</span>
        <span class="k">if</span> <span class="n">when</span> <span class="o">==</span> <span class="s2">&quot;pre&quot;</span><span class="p">:</span>
            <span class="n">postproc_attrs</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;_uncompressed_beg_end&quot;</span><span class="p">,)</span>
        <span class="k">elif</span> <span class="n">when</span> <span class="o">==</span> <span class="s2">&quot;post&quot;</span><span class="p">:</span>
            <span class="n">postproc_attrs</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;_subset_hook&quot;</span><span class="p">,)</span>
        <span class="k">for</span> <span class="n">temp_attr</span> <span class="ow">in</span> <span class="n">postproc_attrs</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">temp_attr</span><span class="p">):</span>
                <span class="nb">delattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">temp_attr</span><span class="p">)</span>

    <span class="c1"># The various method associated with chunk mgmt ===========================</span>
    <span class="k">def</span> <span class="nf">chunk_slices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="c1">#, chunk_size=None):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generator function</span>
<span class="sd">        Yields the chunks spans (ix, ixx, iy, iyy)</span>
<span class="sd">        with each chunk of size chunk_size x chunk_size</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># if chunk_size is None:</span>
        <span class="n">chunk_size</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">chunk_size</span>

        <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">chunk_size</span><span class="p">):</span>
            <span class="n">ixx</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">ix</span> <span class="o">+</span> <span class="n">chunk_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">iy</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">chunk_size</span><span class="p">):</span>
                <span class="n">iyy</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">iy</span> <span class="o">+</span> <span class="n">chunk_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">)</span>
                <span class="k">yield</span>  <span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">ixx</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">iyy</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">chunks_count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the total number of chunks (tiles) for the current image</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">chunk_size</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">chunk_size</span>
        <span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">chunk_size</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">r</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">cx</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="p">(</span><span class="n">cy</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">chunk_size</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">r</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">cy</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">cx</span> <span class="o">*</span> <span class="n">cy</span>

    <span class="k">def</span> <span class="nf">chunk_rank</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chunk_slice</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the generator yield index for chunk_slice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">chunk_size</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">chunk_size</span>
        <span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">chunk_slice</span>
        <span class="n">chunk_item_x</span> <span class="o">=</span> <span class="n">ix</span> <span class="o">//</span> <span class="n">chunk_size</span>
        <span class="n">chunk_item_y</span> <span class="o">=</span> <span class="n">iy</span> <span class="o">//</span> <span class="n">chunk_size</span>
        <span class="p">(</span><span class="n">cy</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">chunk_size</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">r</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">cy</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">chunk_item_x</span> <span class="o">*</span> <span class="n">cy</span> <span class="o">+</span> <span class="n">chunk_item_y</span>

    <span class="k">def</span> <span class="nf">chunk_from_rank</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rank</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the chunk_slice from the generator yield index</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">chunk_size</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">chunk_size</span>
        <span class="p">(</span><span class="n">cy</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">chunk_size</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">r</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span> <span class="n">cy</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">chunk_item_x</span><span class="p">,</span> <span class="n">chunk_item_y</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">rank</span><span class="p">,</span> <span class="n">cy</span><span class="p">)</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="n">chunk_item_x</span> <span class="o">*</span> <span class="n">chunk_size</span>
        <span class="n">iy</span> <span class="o">=</span> <span class="n">chunk_item_y</span> <span class="o">*</span> <span class="n">chunk_size</span>
        <span class="n">ixx</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">ix</span> <span class="o">+</span> <span class="n">chunk_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">)</span>
        <span class="n">iyy</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">iy</span> <span class="o">+</span> <span class="n">chunk_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">ixx</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">iyy</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">uncompressed_beg_end</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rank</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Return the span for the boolean mask index for the chunk index</span>
<span class="sd">        `rank` &quot;&quot;&quot;</span>
        <span class="c1"># Note: indep of the mask.</span>
        <span class="n">valid</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_uncompressed_beg_end&quot;</span><span class="p">):</span>
            <span class="n">arr</span><span class="p">,</span> <span class="n">in_nx</span><span class="p">,</span> <span class="n">in_ny</span><span class="p">,</span> <span class="n">in_csize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uncompressed_beg_end</span>
            <span class="n">valid</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nx</span> <span class="o">==</span> <span class="n">in_nx</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ny</span> <span class="o">==</span> <span class="n">in_ny</span><span class="p">,</span>
                <span class="n">fs</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">chunk_size</span> <span class="o">==</span> <span class="n">in_csize</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">valid</span><span class="p">:</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">recompute_uncompressed_beg_end</span><span class="p">(</span><span class="n">rank</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">arr</span><span class="p">[</span><span class="n">rank</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">rank</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">recompute_uncompressed_beg_end</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rank</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; A bit brutal but does the job</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">chunks_count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">chunk_slice</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_slices</span><span class="p">()):</span>
            <span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">ixx</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">iyy</span><span class="p">)</span> <span class="o">=</span> <span class="n">chunk_slice</span>
            <span class="n">arr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">ixx</span> <span class="o">-</span> <span class="n">ix</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">iyy</span> <span class="o">-</span> <span class="n">iy</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_uncompressed_beg_end</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">arr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">fs</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">chunk_size</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">arr</span>

    <span class="k">def</span> <span class="nf">compressed_beg_end</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calc_name</span><span class="p">,</span> <span class="n">rank</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Return the span for a stored array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Note : depend of the mask... hence the calc_name</span>
        <span class="n">mmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_report_memmap</span><span class="p">(</span><span class="n">calc_name</span><span class="p">)</span>

        <span class="n">items</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">REPORT_ITEMS</span>
        <span class="n">beg</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">[</span><span class="n">rank</span><span class="p">,</span> <span class="n">items</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;chunk1d_begin&quot;</span><span class="p">)]</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">[</span><span class="n">rank</span><span class="p">,</span> <span class="n">items</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;chunk1d_end&quot;</span><span class="p">)]</span>
        <span class="k">del</span> <span class="n">mmap</span>

        <span class="k">return</span> <span class="n">beg</span><span class="p">,</span> <span class="n">end</span>


    <span class="k">def</span> <span class="nf">pts_count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calc_name</span><span class="p">,</span> <span class="n">chunk_slice</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Return the number of compressed 1d points for the current</span>
<span class="sd">        calculation, and the chunk_slice</span>
<span class="sd">        (if chunk_slice is None: return the summ for all chunks)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_data</span><span class="p">[</span><span class="n">calc_name</span><span class="p">][</span><span class="s2">&quot;state&quot;</span><span class="p">]</span>
        <span class="n">subset</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">subset</span>

        <span class="k">if</span> <span class="n">chunk_slice</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">ixx</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">iyy</span><span class="p">)</span> <span class="o">=</span> <span class="n">chunk_slice</span>

        <span class="k">if</span> <span class="n">subset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">chunk_slice</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subset</span><span class="p">[</span><span class="kc">None</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">subset_pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">subset</span><span class="p">[</span><span class="n">chunk_slice</span><span class="p">])</span>
                <span class="k">return</span> <span class="n">subset_pts</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">chunk_slice</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nx</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ny</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">ixx</span> <span class="o">-</span> <span class="n">ix</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">iyy</span> <span class="o">-</span> <span class="n">iy</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">chunk_pixel_pos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chunk_slice</span><span class="p">,</span> <span class="n">jitter</span><span class="p">,</span> <span class="n">supersampling</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the image pixels vector distance to center in fraction of image</span>
<span class="sd">        width, as a complex</span>
<span class="sd">           pix = center + (pix_frac_x * dx,  pix_frac_x * dy)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">float_type</span>

        <span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">)</span>
        <span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">ixx</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">iyy</span><span class="p">)</span> <span class="o">=</span> <span class="n">chunk_slice</span>

        <span class="n">kx</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">/</span> <span class="p">(</span><span class="n">nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># interval width</span>
        <span class="n">ky</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">/</span> <span class="p">(</span><span class="n">ny</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># interval width</span>

        <span class="k">if</span> <span class="n">supersampling</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x_1d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
                <span class="n">kx</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">ix</span> <span class="o">-</span> <span class="n">nx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
                <span class="n">kx</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">ixx</span> <span class="o">-</span> <span class="n">nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
                <span class="n">num</span><span class="o">=</span><span class="p">(</span><span class="n">ixx</span> <span class="o">-</span> <span class="n">ix</span><span class="p">),</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">data_type</span>
            <span class="p">)</span>
            <span class="n">y_1d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
                <span class="n">ky</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">iy</span> <span class="o">-</span> <span class="n">ny</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
                <span class="n">ky</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">iyy</span> <span class="o">-</span> <span class="n">ny</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
                <span class="n">num</span><span class="o">=</span><span class="p">(</span><span class="n">iyy</span> <span class="o">-</span> <span class="n">iy</span><span class="p">),</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">data_type</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">ssg</span> <span class="o">=</span> <span class="n">supersampling</span>
            <span class="n">ssg_gap</span> <span class="o">=</span> <span class="p">(</span><span class="n">ssg</span> <span class="o">-</span> <span class="mf">1.</span><span class="p">)</span> <span class="o">/</span> <span class="n">ssg</span>
            <span class="n">x_1d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
                <span class="n">kx</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">ix</span> <span class="o">-</span> <span class="n">nx</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">ssg_gap</span><span class="p">),</span>
                <span class="n">kx</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">ixx</span> <span class="o">-</span> <span class="n">nx</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">ssg_gap</span><span class="p">),</span>
                <span class="n">num</span> <span class="o">=</span> <span class="p">(</span><span class="n">ixx</span> <span class="o">-</span> <span class="n">ix</span><span class="p">)</span> <span class="o">*</span> <span class="n">ssg</span><span class="p">,</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">data_type</span>
            <span class="p">)</span>
            <span class="n">y_1d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
                <span class="n">ky</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">iy</span> <span class="o">-</span> <span class="n">ny</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">ssg_gap</span><span class="p">),</span>
                <span class="n">ky</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">iyy</span> <span class="o">-</span> <span class="n">ny</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">ssg_gap</span><span class="p">),</span>
                <span class="n">num</span> <span class="o">=</span> <span class="p">(</span><span class="n">iyy</span> <span class="o">-</span> <span class="n">iy</span><span class="p">)</span> <span class="o">*</span> <span class="n">ssg</span><span class="p">,</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">data_type</span>
            <span class="p">)</span>

        <span class="n">dx_screen</span><span class="p">,</span> <span class="n">dy_screen</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x_1d</span><span class="p">,</span> <span class="o">-</span><span class="n">y_1d</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;xy&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">jitter</span><span class="p">:</span>
            <span class="n">rg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">rand_x</span> <span class="o">=</span> <span class="n">rg</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">dx_screen</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">data_type</span><span class="p">)</span>
            <span class="n">rand_y</span> <span class="o">=</span> <span class="n">rg</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">dy_screen</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">data_type</span><span class="p">)</span>
            <span class="n">k</span> <span class="o">=</span> <span class="mf">0.7071067811865476</span>
            <span class="n">jitter_x</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">-</span> <span class="n">rand_x</span><span class="p">)</span> <span class="o">*</span> <span class="n">k</span> <span class="o">/</span> <span class="p">(</span><span class="n">nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">jitter</span>
            <span class="n">jitter_y</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">-</span> <span class="n">rand_y</span><span class="p">)</span> <span class="o">*</span> <span class="n">k</span> <span class="o">/</span> <span class="p">(</span><span class="n">ny</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">jitter</span>
            <span class="k">if</span> <span class="n">supersampling</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">jitter_x</span> <span class="o">/=</span> <span class="n">supersampling</span>
                <span class="n">jitter_y</span> <span class="o">/=</span> <span class="n">supersampling</span>
            <span class="n">dx_screen</span> <span class="o">+=</span> <span class="n">jitter_x</span>
            <span class="n">dy_screen</span> <span class="o">+=</span> <span class="n">jitter_y</span>

        <span class="n">dy_screen</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xy_ratio</span>

        <span class="n">res</span> <span class="o">=</span> <span class="n">dx_screen</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">dy_screen</span>

        <span class="k">return</span> <span class="n">res</span>


    <span class="nd">@property</span>    
    <span class="k">def</span> <span class="nf">tag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Used to tag an output image</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tag</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;Software&quot;</span><span class="p">:</span> <span class="s2">&quot;fractalshades &quot;</span> <span class="o">+</span> <span class="n">fs</span><span class="o">.</span><span class="n">__version__</span><span class="p">,</span>
            <span class="s2">&quot;datetime&quot;</span><span class="p">:</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">today</span><span class="p">()</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1">_%H:%M:%S&#39;</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="c1"># Adding detailed data per calculation</span>
        <span class="k">for</span> <span class="n">calc_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_data</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_data</span><span class="p">[</span><span class="n">calc_name</span><span class="p">][</span><span class="s2">&quot;state&quot;</span><span class="p">]</span>
            <span class="n">tag</span><span class="p">[</span><span class="n">calc_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">fingerprint</span>
        <span class="c1"># Adding the reference zoom parameters for GUI navigation</span>
        <span class="n">tag</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zoom_kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">fs</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">dic_flatten</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">fingerprint_matching</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calc_name</span><span class="p">,</span> <span class="n">test_fingerprint</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test if the stored parameters match those of new calculation</span>
<span class="sd">        /!\ modified in subclass</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flatten_fp</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">dic_flatten</span><span class="p">(</span><span class="n">test_fingerprint</span><span class="p">)</span>

        <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_data</span><span class="p">[</span><span class="n">calc_name</span><span class="p">][</span><span class="s2">&quot;state&quot;</span><span class="p">]</span>
        <span class="n">expected_fp</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">dic_flatten</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">fingerprint</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;fingerprint_matching flatten_fp:</span><span class="se">\n</span><span class="s2"> </span><span class="si">{</span><span class="n">flatten_fp</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;fingerprint_matching expected_fp:</span><span class="se">\n</span><span class="s2"> </span><span class="si">{</span><span class="n">expected_fp</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># We currently do not have special keys to handle</span>
        <span class="c1"># (Note: The software version and calculation info are now only added</span>
        <span class="c1"># to the tagged image)</span>
        <span class="n">SPECIAL</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">expected_fp</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="ow">in</span> <span class="n">SPECIAL</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">flatten_fp</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">!=</span> <span class="n">val</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">textwrap</span><span class="o">.</span><span class="n">dedent</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">                            Parameter mismatch ; will trigger a recalculation</span>
<span class="s2">                              </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">flatten_fp</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="si">}</span><span class="s2"> --&gt; </span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s2">&quot;&quot;&quot;</span>
                        <span class="p">))</span>
                    <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">res_available</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calc_name</span><span class="p">,</span> <span class="n">chunk_slice</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;  </span>
<span class="sd">        If chunk_slice is None, check that stored calculation fingerprint</span>
<span class="sd">        matches.</span>
<span class="sd">        If chunk_slice is provided, checks that calculation results are</span>
<span class="sd">        available</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">fingerprint</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reload_fingerprint</span><span class="p">(</span><span class="n">calc_name</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">textwrap</span><span class="o">.</span><span class="n">dedent</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">                No fingerprint file found for </span><span class="si">{</span><span class="n">calc_name</span><span class="si">}</span><span class="s2">;</span>
<span class="s2">                  will trigger a recalculation&quot;&quot;&quot;</span>
                <span class="p">))</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">log</span> <span class="o">=</span> <span class="p">(</span><span class="n">chunk_slice</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">matching</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fingerprint_matching</span><span class="p">(</span><span class="n">calc_name</span><span class="p">,</span> <span class="n">fingerprint</span><span class="p">,</span> <span class="n">log</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Fingerprint match for </span><span class="si">{</span><span class="n">chunk_slice</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">matching</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">matching</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">chunk_slice</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">matching</span> <span class="c1"># should be True</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">report</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reload_report</span><span class="p">(</span><span class="n">calc_name</span><span class="p">,</span> <span class="n">chunk_slice</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="n">report</span><span class="p">[</span><span class="s2">&quot;done&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>


    <span class="k">def</span> <span class="nf">calc_hook</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calc_callable</span><span class="p">,</span> <span class="n">calc_kwargs</span><span class="p">,</span> <span class="n">return_dic</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called by a calculation wrapper (ref. utils.py)</span>
<span class="sd">        Prepares &amp; stores the data needed for future calculation of tiles</span>

<span class="sd">        /!\ If error here check that the Fractal calculation implementation</span>
<span class="sd">        returns the expected dict of functions:</span>
<span class="sd">        {</span>
<span class="sd">            &quot;set_state&quot;: set_state,</span>
<span class="sd">            &quot;initialize&quot;: initialize,</span>
<span class="sd">            &quot;iterate&quot;: iterate</span>
<span class="sd">        }</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">calc_name</span> <span class="o">=</span> <span class="n">calc_kwargs</span><span class="p">[</span><span class="s2">&quot;calc_name&quot;</span><span class="p">]</span>

        <span class="c1"># Storage for future calculation</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_calc_data&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_calc_data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="c1"># Setting internal state - needed to unwrap other data</span>
        <span class="c1"># /!\ using in also a separate namespace, thread-safe option</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">SimpleNamespace</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">calc_kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="n">set_state</span> <span class="o">=</span> <span class="n">return_dic</span><span class="p">[</span><span class="s2">&quot;set_state&quot;</span><span class="p">]()</span>
        <span class="n">set_state</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="n">set_state</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">initialize</span> <span class="o">=</span> <span class="n">return_dic</span><span class="p">[</span><span class="s2">&quot;initialize&quot;</span><span class="p">]()</span>
        <span class="n">iterate</span> <span class="o">=</span> <span class="n">return_dic</span><span class="p">[</span><span class="s2">&quot;iterate&quot;</span><span class="p">]()</span>
        <span class="n">cycle_indep_args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cycle_indep_args</span><span class="p">(</span><span class="n">initialize</span><span class="p">,</span> <span class="n">iterate</span><span class="p">)</span>
        <span class="n">saved_codes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">saved_codes</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">codes</span><span class="p">)</span>

        <span class="c1"># stores the data for later use</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calc_data</span><span class="p">[</span><span class="n">calc_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;calc_class&quot;</span><span class="p">:</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="s2">&quot;calc_callable&quot;</span><span class="p">:</span> <span class="n">calc_callable</span><span class="p">,</span>
            <span class="s2">&quot;calc_kwargs&quot;</span><span class="p">:</span> <span class="n">calc_kwargs</span><span class="p">,</span>
            <span class="s2">&quot;zoom_kwargs&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">zoom_kwargs</span><span class="p">,</span>
            <span class="s2">&quot;state&quot;</span><span class="p">:</span> <span class="n">state</span><span class="p">,</span>
            <span class="s2">&quot;cycle_indep_args&quot;</span><span class="p">:</span> <span class="n">cycle_indep_args</span><span class="p">,</span>
            <span class="s2">&quot;saved_codes&quot;</span><span class="p">:</span> <span class="n">saved_codes</span><span class="p">,</span>
            <span class="s2">&quot;init_kwargs&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_kwargs</span>
        <span class="p">}</span>

        <span class="c1"># Takes a &#39;fingerprint&#39; of the calculation parameters</span>
        <span class="n">fp_items</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;calc_class&quot;</span><span class="p">,</span> <span class="s2">&quot;calc_callable&quot;</span><span class="p">,</span> <span class="s2">&quot;calc_kwargs&quot;</span><span class="p">,</span> <span class="s2">&quot;zoom_kwargs&quot;</span><span class="p">,</span>
            <span class="s2">&quot;init_kwargs&quot;</span>
        <span class="p">)</span>
        <span class="n">state</span><span class="o">.</span><span class="n">fingerprint</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_data</span><span class="p">[</span><span class="n">calc_name</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">fp_items</span>
        <span class="p">}</span>

        <span class="c1"># Adding a subset hook for future &#39;on the fly&#39; computation</span>
        <span class="k">if</span> <span class="s2">&quot;subset&quot;</span> <span class="ow">in</span> <span class="n">calc_kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">subset</span> <span class="o">=</span> <span class="n">calc_kwargs</span><span class="p">[</span><span class="s2">&quot;subset&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">subset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_subset_hook</span><span class="p">(</span><span class="n">subset</span><span class="p">,</span> <span class="n">calc_name</span><span class="p">)</span>

        <span class="c1"># We cannot open new memaps at this early stage : because</span>
        <span class="c1"># subset may still be unknown. But, we shall track it.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">res_available</span><span class="p">(</span><span class="n">calc_name</span><span class="p">):</span>
            <span class="c1"># There *should* be mmaps available but lets double-check this</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">mmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_report_memmap</span><span class="p">(</span><span class="n">calc_name</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r+&quot;</span><span class="p">)</span>
                <span class="k">del</span> <span class="n">mmap</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">SAVE_ARRS</span><span class="p">:</span>
                    <span class="n">mmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_data_memmap</span><span class="p">(</span><span class="n">calc_name</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r+&quot;</span><span class="p">)</span>
                    <span class="k">del</span> <span class="n">mmap</span>
                <span class="k">if</span> <span class="n">subset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">mmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_data_memmap</span><span class="p">(</span><span class="n">calc_name</span><span class="p">,</span> <span class="s2">&quot;subset&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r+&quot;</span><span class="p">)</span>
                    <span class="k">del</span> <span class="n">mmap</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_calc_data</span><span class="p">[</span><span class="n">calc_name</span><span class="p">][</span><span class="s2">&quot;need_new_mmap&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Found suitable raw results files set for </span><span class="si">{</span><span class="n">calc_name</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="s2">&quot;  -&gt; only the missing tiles will be recomputed&quot;</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">FileNotFoundError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_calc_data</span><span class="p">[</span><span class="n">calc_name</span><span class="p">][</span><span class="s2">&quot;need_new_mmap&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Raw results files set for </span><span class="si">{</span><span class="n">calc_name</span><span class="si">}</span><span class="s2"> is incomplete</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;      -&gt; all tiles will be recomputed: </span><span class="se">\n</span><span class="s2">    </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Missing up-to-date result file available for </span><span class="si">{</span><span class="n">calc_name</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="s2">&quot;  -&gt; all tiles will be recomputed&quot;</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_calc_data</span><span class="p">[</span><span class="n">calc_name</span><span class="p">][</span><span class="s2">&quot;need_new_mmap&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">save_fingerprint</span><span class="p">(</span><span class="n">calc_name</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">fingerprint</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">raise_interruption</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_interrupted</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">lower_interruption</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_interrupted</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">is_interrupted</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Either programmatically &#39;interrupted&#39; (from the GUI) or by the user </span>
<span class="sd">        in batch mode through fs.settings.skip_calc &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_interrupted</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">fs</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">skip_calc</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">numba_cycle_call</span><span class="p">(</span><span class="n">cycle_dep_args</span><span class="p">,</span> <span class="n">cycle_indep_args</span><span class="p">):</span>
        <span class="c1"># Just a thin wrapper to allow customization in derived classes</span>
        <span class="n">ret_code</span> <span class="o">=</span> <span class="n">numba_cycles</span><span class="p">(</span><span class="o">*</span><span class="n">cycle_dep_args</span><span class="p">,</span> <span class="o">*</span><span class="n">cycle_indep_args</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">ret_code</span>

    <span class="k">def</span> <span class="nf">get_cycle_indep_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initialize</span><span class="p">,</span> <span class="n">iterate</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        When not a perturbation rendering:</span>
<span class="sd">        This is just a diggest of the zoom and calculation parameters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">center</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span>
        <span class="c1"># proj_dzndc_modifier = getattr(self.projection, &quot;dzndc_modifier&quot;, None)</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="n">initialize</span><span class="p">,</span> <span class="n">iterate</span><span class="p">,</span>
            <span class="n">center</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">proj_impl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lin_mat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_interrupted</span>
        <span class="p">)</span>
    

    <span class="k">def</span> <span class="nf">get_cycling_dep_args</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">calc_name</span><span class="p">,</span> <span class="n">chunk_slice</span><span class="p">,</span>
            <span class="n">final</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">jitter</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">supersampling</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The actual input / output arrays</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c_pix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">chunk_pixel_pos</span><span class="p">(</span><span class="n">chunk_slice</span><span class="p">,</span> <span class="n">jitter</span><span class="p">,</span> <span class="n">supersampling</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_data</span><span class="p">[</span><span class="n">calc_name</span><span class="p">][</span><span class="s2">&quot;state&quot;</span><span class="p">]</span>
        <span class="n">subset</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">subset</span>
        <span class="k">if</span> <span class="n">subset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">final</span><span class="p">:</span>
                <span class="c1"># Here we need a substitution - as raw arrays not stored</span>
                <span class="n">subset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subset_hook</span><span class="p">[</span><span class="n">calc_name</span><span class="p">]</span>
            <span class="n">chunk_subset</span> <span class="o">=</span> <span class="n">subset</span><span class="p">[</span><span class="n">chunk_slice</span><span class="p">]</span>
            <span class="n">c_pix</span> <span class="o">=</span> <span class="n">c_pix</span><span class="p">[</span><span class="n">chunk_subset</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">chunk_subset</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Initialise the result arrays</span>
        <span class="p">(</span><span class="n">n_pts</span><span class="p">,)</span> <span class="o">=</span> <span class="n">c_pix</span><span class="o">.</span><span class="n">shape</span>

        <span class="n">n_Z</span><span class="p">,</span> <span class="n">n_U</span><span class="p">,</span> <span class="n">n_stop</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">code</span><span class="p">)</span> <span class="k">for</span> <span class="n">code</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">codes</span><span class="p">)</span>

        <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n_Z</span><span class="p">,</span> <span class="n">n_pts</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">complex_type</span><span class="p">)</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n_U</span><span class="p">,</span> <span class="n">n_pts</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">int_type</span><span class="p">)</span>
        <span class="n">stop_reason</span> <span class="o">=</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_pts</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">termination_type</span><span class="p">)</span>
        <span class="n">stop_iter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_pts</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">int_type</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">c_pix</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">stop_reason</span><span class="p">,</span> <span class="n">stop_iter</span><span class="p">),</span> <span class="n">chunk_subset</span>

<span class="c1">#==============================================================================</span>

    <span class="k">def</span> <span class="nf">add_subset_hook</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f_array</span><span class="p">,</span> <span class="n">calc_name_to</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Create a namespace for a hook that shall be filled during</span>
<span class="sd">        on-the fly computation - used for final calculations with subset on. </span>
<span class="sd">           Hook structure:  dict </span>
<span class="sd">           hook[calcname_to] = [f_array_dat, supersampling_k, mmap]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Add Subset hook for </span><span class="si">{</span><span class="n">calc_name_to</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_subset_hook&quot;</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_subset_hook</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_subset_hook</span><span class="p">[</span><span class="n">calc_name_to</span><span class="p">]</span> <span class="o">=</span> <span class="n">_Subset_temporary_array</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">f_array</span><span class="o">.</span><span class="n">calc_name</span><span class="p">,</span> <span class="n">calc_name_to</span><span class="p">,</span>
            <span class="n">f_array</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">f_array</span><span class="o">.</span><span class="n">_func</span><span class="p">,</span> <span class="n">f_array</span><span class="o">.</span><span class="n">inv</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">init_subset_mmap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calc_name_to</span><span class="p">,</span> <span class="n">supersampling</span><span class="p">):</span> <span class="c1"># private</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Create the memory mapping</span>
<span class="sd">        Format: 1-d UNcompressed per chunk, takes into account supersampling</span>
<span class="sd">        as needed. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Opening subset mmap for: </span><span class="si">{</span><span class="n">calc_name_to</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_subset_hook</span><span class="p">[</span><span class="n">calc_name_to</span><span class="p">]</span><span class="o">.</span><span class="n">init_mmap</span><span class="p">(</span><span class="n">supersampling</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">close_subset_mmap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calc_name_to</span><span class="p">,</span> <span class="n">supersampling</span><span class="p">):</span> <span class="c1"># private</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Closed the memory mapping</span>
<span class="sd">        Format: 1-d UNcompressed per chunk, takes into account supersampling</span>
<span class="sd">        as needed. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_subset_hook</span><span class="p">[</span><span class="n">calc_name_to</span><span class="p">]</span><span class="o">.</span><span class="n">close_mmap</span><span class="p">(</span><span class="n">supersampling</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">save_subset_arrays</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">calc_name</span><span class="p">,</span> <span class="n">chunk_slice</span><span class="p">,</span> <span class="n">postproc_options</span><span class="p">,</span> <span class="n">ret</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Checks wether saving is needed&quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">calc_name_to</span><span class="p">,</span> <span class="n">sta</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subset_hook</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">sta</span><span class="o">.</span><span class="n">calc_name_from</span> <span class="o">!=</span> <span class="n">calc_name</span><span class="p">:</span>
                <span class="c1"># Calc data not needed for this fractal array</span>
                <span class="k">return</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Saving subset data chunk for on the fly plot:</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span>
                         <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">calc_name</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">sta</span><span class="o">.</span><span class="n">calc_name_to</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">sta</span><span class="o">.</span><span class="n">save_array</span><span class="p">(</span><span class="n">chunk_slice</span><span class="p">,</span> <span class="n">ret</span><span class="p">)</span>


<span class="c1">#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
    <span class="k">def</span> <span class="nf">fingerprint_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calc_name</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">directory</span><span class="p">,</span> <span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="n">calc_name</span> <span class="o">+</span> <span class="s2">&quot;.fingerprint&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">save_fingerprint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calc_name</span><span class="p">,</span> <span class="n">fingerprint</span><span class="p">):</span>
        <span class="n">save_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fingerprint_path</span><span class="p">(</span><span class="n">calc_name</span><span class="p">)</span>
        <span class="n">fs</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">mkdir_p</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">save_path</span><span class="p">))</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">save_path</span><span class="p">,</span> <span class="s1">&#39;wb+&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp_file</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">fingerprint</span><span class="p">,</span> <span class="n">fp_file</span><span class="p">,</span> <span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reload_fingerprint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calc_name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Reloading the fingerprint from the saved files &quot;&quot;&quot;</span>
        <span class="n">save_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fingerprint_path</span><span class="p">(</span><span class="n">calc_name</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">save_path</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">tmpfile</span><span class="p">:</span>
            <span class="n">fingerprint</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">tmpfile</span><span class="p">)</span>
        <span class="c1"># Here we could finalize unpickling of Fractal arrays by binding</span>
        <span class="c1"># again the Fractal object - it is however not needed (we only use</span>
        <span class="c1"># the unpickled object for equality testing)</span>
        <span class="k">return</span> <span class="n">fingerprint</span>

<span class="c1">#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
    <span class="c1"># Codes filtering</span>
    <span class="k">def</span> <span class="nf">saved_codes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">codes</span><span class="p">):</span>
        <span class="p">(</span><span class="n">complex_codes</span><span class="p">,</span> <span class="n">int_codes</span><span class="p">,</span> <span class="n">stop_codes</span><span class="p">)</span> <span class="o">=</span> <span class="n">codes</span>
        <span class="n">f_complex_codes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_stored_codes</span><span class="p">(</span><span class="n">complex_codes</span><span class="p">)</span>
        <span class="n">f_int_codes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_stored_codes</span><span class="p">(</span><span class="n">int_codes</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">f_complex_codes</span><span class="p">,</span> <span class="n">f_int_codes</span><span class="p">,</span> <span class="n">stop_codes</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">filter_stored_codes</span><span class="p">(</span><span class="n">codes</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Don&#39;t store temporary codes - i.e. those which starts with &quot;_&quot; &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="ow">not</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)),</span> <span class="n">codes</span><span class="p">))</span>

<span class="c1">#==============================================================================</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">txt_report_path</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The main report is written by the Fractal_plotter, only the name is </span>
<span class="sd">        defined here&quot;&quot;&quot;</span>
        <span class="k">return</span>  <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">directory</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;.txt&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Report path &quot;.inspect&quot; tracks the progress of the calculations</span>
    <span class="k">def</span> <span class="nf">report_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calc_name</span><span class="p">):</span> <span class="c1"># public</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">directory</span><span class="p">,</span> <span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="n">calc_name</span> <span class="o">+</span> <span class="s2">&quot;.report&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">init_report_mmap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calc_name</span><span class="p">):</span> <span class="c1"># private</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create the memory mapping for calculation reports by chunks</span>
<span class="sd">        [chunk1d_begin, chunk1d_end, chunk_pts]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">items</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">REPORT_ITEMS</span>
        <span class="n">chunks_count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunks_count</span>
        <span class="n">report_cols_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">items</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;Create new report_mmap with chunks_count: &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">chunks_count</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="n">save_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">report_path</span><span class="p">(</span><span class="n">calc_name</span><span class="p">)</span>
        <span class="n">fs</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">mkdir_p</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">save_path</span><span class="p">))</span>

        <span class="n">mmap</span> <span class="o">=</span> <span class="n">open_memmap</span><span class="p">(</span>
            <span class="n">filename</span><span class="o">=</span><span class="n">save_path</span><span class="p">,</span> 
            <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w+&#39;</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">chunks_count</span><span class="p">,</span> <span class="n">report_cols_count</span><span class="p">),</span>
            <span class="n">fortran_order</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">version</span><span class="o">=</span><span class="kc">None</span>
        <span class="p">)</span>
        <span class="n">mmap</span><span class="p">[:,</span> <span class="n">items</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;done&quot;</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># Will be set to 1 when done</span>

        <span class="c1"># Number of points per chunk</span>
        <span class="n">chunk_pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">chunks_count</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">chunk_slice</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_slices</span><span class="p">()):</span>
            <span class="n">chunk_pts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pts_count</span><span class="p">(</span><span class="n">calc_name</span><span class="p">,</span> <span class="n">chunk_slice</span><span class="p">)</span> <span class="c1"># (calc_name, chunk_slice)</span>
        <span class="n">mmap</span><span class="p">[:,</span> <span class="n">items</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;chunk_pts&quot;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">chunk_pts</span>

        <span class="c1"># full_cumsum is np.cumsum(chunk_pts) with inserted 0</span>
        <span class="n">full_cumsum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">chunks_count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">chunk_pts</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">full_cumsum</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">full_cumsum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">mmap</span><span class="p">[:,</span> <span class="n">items</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;chunk1d_begin&quot;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">full_cumsum</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">mmap</span><span class="p">[:,</span> <span class="n">items</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;chunk1d_end&quot;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">full_cumsum</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="k">del</span> <span class="n">mmap</span>


    <span class="k">def</span> <span class="nf">get_report_memmap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calc_name</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r+&#39;</span><span class="p">):</span>
        <span class="c1"># Development Note - Memory mapping </span>
        <span class="c1"># From IEEE 1003.1:</span>
        <span class="c1">#    The mmap() function shall establish a mapping between a process&#39;</span>
        <span class="c1">#    address space and a file, shared memory object, or [TYM] typed</span>
        <span class="c1">#    memory object.</span>
        <span class="c1"># 1)</span>
        <span class="c1"># Every instance of np.memmap creates its own mmap of the whole file</span>
        <span class="c1"># (even if it only creates an array from part of the</span>
        <span class="c1"># file). The implications of this are A) you can&#39;t use np.memmap&#39;s</span>
        <span class="c1"># offset parameter to get around file size limitations, and B) you</span>
        <span class="c1"># shouldn&#39;t create many numpy.memmaps of the same file. To work around</span>
        <span class="c1"># B, you should create a single memmap, and dole out views and slices.</span>
        <span class="c1"># 2)</span>
        <span class="c1"># Yes, it allocates room for the whole file in your process&#39;s LOGICAL</span>
        <span class="c1"># address space. However, it doesn&#39;t actually reserve any PHYSICAL</span>
        <span class="c1"># memory, or read in any data from the disk, until you&#39;ve actually</span>
        <span class="c1"># access the data. And then it only reads small chunks in, not the</span>
        <span class="c1"># whole file.</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">open_memmap</span><span class="p">(</span>
            <span class="n">filename</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">report_path</span><span class="p">(</span><span class="n">calc_name</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">val</span>


    <span class="k">def</span> <span class="nf">report_memmap_attr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calc_name</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;__report_mmap_&quot;</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">calc_name</span>

    <span class="k">def</span> <span class="nf">update_report_mmap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calc_name</span><span class="p">,</span> <span class="n">chunk_slice</span><span class="p">,</span> <span class="n">stop_reason</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_report_memmap</span><span class="p">(</span><span class="n">calc_name</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r+&quot;</span><span class="p">)</span>
        <span class="n">items</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">REPORT_ITEMS</span>
        <span class="n">chunk_rank</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_rank</span><span class="p">(</span><span class="n">chunk_slice</span><span class="p">)</span>
        <span class="n">mmap</span><span class="p">[</span><span class="n">chunk_rank</span><span class="p">,</span> <span class="n">items</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;done&quot;</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">del</span> <span class="n">mmap</span>

    <span class="k">def</span> <span class="nf">reload_report</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calc_name</span><span class="p">,</span> <span class="n">chunk_slice</span><span class="p">):</span> <span class="c1"># public</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Return a report extract for the given chunk, as a dict</span>
<span class="sd">             If no chunk provided, return the full report (header, report)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_report_memmap</span><span class="p">(</span><span class="n">calc_name</span><span class="p">)</span>
        <span class="n">items</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">REPORT_ITEMS</span>
        <span class="k">if</span> <span class="n">chunk_slice</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">report</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">mmap</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">mmap</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">report</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">[:,</span> <span class="p">:]</span>
            <span class="k">return</span>  <span class="bp">self</span><span class="o">.</span><span class="n">REPORT_ITEMS</span><span class="p">,</span> <span class="n">report</span>

        <span class="n">rank</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_rank</span><span class="p">(</span><span class="n">chunk_slice</span><span class="p">)</span>
        <span class="n">report</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span>
            <span class="n">items</span><span class="p">,</span>
            <span class="p">(</span><span class="n">mmap</span><span class="p">[</span><span class="n">rank</span><span class="p">,</span> <span class="n">items</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">it</span><span class="p">)]</span> <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">items</span><span class="p">)</span>
        <span class="p">))</span>
        <span class="k">del</span> <span class="n">mmap</span>
        <span class="k">return</span> <span class="n">report</span>


    <span class="k">def</span> <span class="nf">write_inspect_calc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calc_name</span><span class="p">,</span> <span class="n">final</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Outputs a report for the current calculation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">outpath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">directory</span><span class="p">,</span> <span class="n">calc_name</span> <span class="o">+</span> <span class="s2">&quot;.inspect&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">final</span><span class="p">:</span>
            <span class="n">log_txt</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Cannot write detailed output *.inspect_calc&quot;</span>
                       <span class="s2">&quot; for a final render&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">outpath</span><span class="p">):</span>
                <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">outpath</span><span class="p">)</span>
                <span class="n">log_txt</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;, deleting obsolete file </span><span class="si">{</span><span class="n">outpath</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">log_txt</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">REPORT_ITEMS</span><span class="p">,</span> <span class="n">report</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reload_report</span><span class="p">(</span><span class="n">calc_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">report_header</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;chnk_beg|chnk_end|chnk_pts|done|&quot;</span><span class="p">)</span>

        <span class="c1"># There are other interesting items to inspect</span>
        <span class="n">chunks_count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunks_count</span>

        <span class="n">stop_ITEMS</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;min_stop_iter&quot;</span><span class="p">,</span> <span class="s2">&quot;max_stop_iter&quot;</span><span class="p">,</span> <span class="s2">&quot;mean_stop_iter&quot;</span><span class="p">]</span>
        <span class="n">stop_report</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">chunks_count</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">stop_header</span> <span class="o">=</span> <span class="s2">&quot;min_stop|max_stop|mean_stp|&quot;</span>

        <span class="n">reason_ITEMS</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">reason_reports</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">reason_header</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">reason_template</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">chunks_count</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">chunk_slice</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_slices</span><span class="p">()):</span>
            <span class="n">subset</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">stop_reason</span><span class="p">,</span> <span class="n">stop_iter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reload_data</span><span class="p">(</span>
                <span class="n">chunk_slice</span><span class="p">,</span> <span class="n">calc_name</span><span class="p">)</span>
            <span class="c1"># Outputs a summary of the stop iter</span>
            <span class="n">has_item</span> <span class="o">=</span> <span class="p">(</span><span class="n">stop_iter</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">it</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">stop_ITEMS</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">it</span> <span class="o">==</span> <span class="s2">&quot;min_stop_iter&quot;</span> <span class="ow">and</span> <span class="n">has_item</span><span class="p">:</span>
                    <span class="n">stop_report</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">stop_iter</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">it</span> <span class="o">==</span> <span class="s2">&quot;max_stop_iter&quot;</span> <span class="ow">and</span> <span class="n">has_item</span><span class="p">:</span>
                    <span class="n">stop_report</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">stop_iter</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">it</span> <span class="o">==</span> <span class="s2">&quot;mean_stop_iter&quot;</span> <span class="ow">and</span> <span class="n">has_item</span><span class="p">:</span>
                    <span class="n">stop_report</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">stop_iter</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">stop_report</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

            <span class="c1"># Outputs a summary of the stop reason</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">stop_reason</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span> <span class="c1"># Nothing to report</span>
                <span class="k">continue</span>
            <span class="n">max_chunk_reason</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">stop_reason</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">reason_ITEMS</span><span class="p">),</span> <span class="n">max_chunk_reason</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">reason_ITEMS</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;reason_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="p">)]</span>
                <span class="n">reason_reports</span> <span class="o">+=</span> <span class="p">[</span><span class="n">reason_template</span><span class="o">.</span><span class="n">copy</span><span class="p">()]</span>
                <span class="n">reason_header</span> <span class="o">+=</span> <span class="p">(</span><span class="s2">&quot;reason_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;|&quot;</span><span class="p">)</span>
            <span class="n">bc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">stop_reason</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">bc_r</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bc</span><span class="p">):</span>
                <span class="n">reason_reports</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">bc_r</span>

        <span class="c1"># Stack the results</span>
        <span class="n">header</span> <span class="o">=</span> <span class="n">REPORT_ITEMS</span> <span class="o">+</span> <span class="n">stop_ITEMS</span> <span class="o">+</span> <span class="n">reason_ITEMS</span>
        <span class="n">n_header</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">header</span><span class="p">)</span>

        <span class="n">full_report</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">chunks_count</span><span class="p">,</span> <span class="n">n_header</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">l1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">REPORT_ITEMS</span><span class="p">)</span>
        <span class="n">l2</span> <span class="o">=</span> <span class="n">l1</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">stop_ITEMS</span><span class="p">)</span>
        <span class="n">full_report</span><span class="p">[:,</span> <span class="p">:</span><span class="n">l1</span><span class="p">]</span> <span class="o">=</span> <span class="n">report</span>
        <span class="n">full_report</span><span class="p">[:,</span> <span class="n">l1</span><span class="p">:</span><span class="n">l2</span><span class="p">]</span> <span class="o">=</span> <span class="n">stop_report</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">l2</span><span class="p">,</span> <span class="n">n_header</span><span class="p">):</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">l2</span>
            <span class="n">full_report</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">reason_reports</span><span class="p">[</span><span class="n">r</span><span class="p">][:,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span>
            <span class="n">outpath</span><span class="p">,</span>
            <span class="n">full_report</span><span class="p">,</span>
            <span class="n">fmt</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%8i</span><span class="s1">|</span><span class="si">%8i</span><span class="s1">|</span><span class="si">%8i</span><span class="s1">|</span><span class="si">%4i</span><span class="s1">|</span><span class="si">%8i</span><span class="s1">|</span><span class="si">%8i</span><span class="s1">|</span><span class="si">%8i</span><span class="s1">|&#39;</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="si">%8i</span><span class="s1">|&#39;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">reason_ITEMS</span><span class="p">)),</span>
            <span class="n">header</span><span class="o">=</span><span class="p">(</span><span class="n">report_header</span> <span class="o">+</span> <span class="n">stop_header</span> <span class="o">+</span> <span class="n">reason_header</span><span class="p">),</span>
            <span class="n">comments</span><span class="o">=</span><span class="s1">&#39;&#39;</span>
        <span class="p">)</span>


    <span class="k">def</span> <span class="nf">data_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calc_name</span><span class="p">):</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;subset&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">SAVE_ARRS</span> 
        <span class="k">def</span> <span class="nf">file_map</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">directory</span><span class="p">,</span> <span class="s2">&quot;data&quot;</span><span class="p">,</span>
                                <span class="n">calc_name</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">key</span> <span class="o">+</span> <span class="s2">&quot;.arr&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="nb">map</span><span class="p">(</span><span class="n">file_map</span><span class="p">,</span> <span class="n">keys</span><span class="p">)))</span>


    <span class="k">def</span> <span class="nf">init_data_mmaps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calc_name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates the memory mappings for calculated arrays</span>
<span class="sd">        [subset, Z, U, stop_reason, stop_iter]</span>
<span class="sd">        </span>
<span class="sd">        Note : subset can be initialized here</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_data</span><span class="p">[</span><span class="n">calc_name</span><span class="p">][</span><span class="s2">&quot;state&quot;</span><span class="p">]</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SAVE_ARRS</span>
        <span class="n">data_type</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;Z&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">complex_type</span><span class="p">,</span>
            <span class="s2">&quot;U&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">int_type</span><span class="p">,</span>
            <span class="s2">&quot;stop_reason&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">termination_type</span><span class="p">,</span>
            <span class="s2">&quot;stop_iter&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">int_type</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">data_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_path</span><span class="p">(</span><span class="n">calc_name</span><span class="p">)</span>

        <span class="n">pts_count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pts_count</span><span class="p">(</span><span class="n">calc_name</span><span class="p">)</span> <span class="c1"># the memmap 1st dim</span>
        <span class="p">(</span><span class="n">complex_codes</span><span class="p">,</span> <span class="n">int_codes</span><span class="p">,</span> <span class="n">stop_codes</span><span class="p">)</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">codes</span>
        <span class="c1"># keep only the one which do not sart with &quot;_&quot;</span>
        <span class="n">f_complex_codes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_stored_codes</span><span class="p">(</span><span class="n">complex_codes</span><span class="p">)</span>
        <span class="n">f_int_codes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_stored_codes</span><span class="p">(</span><span class="n">int_codes</span><span class="p">)</span>
        <span class="n">n_Z</span><span class="p">,</span> <span class="n">n_U</span><span class="p">,</span> <span class="n">n_stop</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">codes</span><span class="p">)</span> <span class="k">for</span> <span class="n">codes</span> <span class="ow">in</span> 
                            <span class="p">(</span><span class="n">f_complex_codes</span><span class="p">,</span> <span class="n">f_int_codes</span><span class="p">,</span> <span class="n">stop_codes</span><span class="p">))</span>
        <span class="c1"># Followin C row-major order --&gt; arr[x, :] shall be fast</span>
        <span class="n">data_dim</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;Z&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">n_Z</span><span class="p">,</span> <span class="n">pts_count</span><span class="p">),</span>
            <span class="s2">&quot;U&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">n_U</span><span class="p">,</span> <span class="n">pts_count</span><span class="p">),</span>
            <span class="s2">&quot;stop_reason&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">pts_count</span><span class="p">),</span>
            <span class="s2">&quot;stop_iter&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">pts_count</span><span class="p">),</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
            <span class="n">mmap</span> <span class="o">=</span> <span class="n">open_memmap</span><span class="p">(</span>
                <span class="n">filename</span><span class="o">=</span><span class="n">data_path</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> 
                <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w+&#39;</span><span class="p">,</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">data_type</span><span class="p">[</span><span class="n">key</span><span class="p">]),</span>
                <span class="n">shape</span><span class="o">=</span><span class="n">data_dim</span><span class="p">[</span><span class="n">key</span><span class="p">],</span>
                <span class="n">fortran_order</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">version</span><span class="o">=</span><span class="kc">None</span>
            <span class="p">)</span>
            <span class="k">del</span> <span class="n">mmap</span>

        <span class="c1"># Store the subset (if there is one) at this stage : it is already</span>
        <span class="c1"># known</span>
        <span class="c1"># /!\ the size of the subset is always the same, irrespective of</span>
        <span class="c1"># the number of items masked</span>
        <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_data</span><span class="p">[</span><span class="n">calc_name</span><span class="p">][</span><span class="s2">&quot;state&quot;</span><span class="p">]</span>
        <span class="n">subset</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">subset</span>

        <span class="k">if</span> <span class="n">subset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mmap</span> <span class="o">=</span> <span class="n">open_memmap</span><span class="p">(</span>
                <span class="n">filename</span><span class="o">=</span><span class="n">data_path</span><span class="p">[</span><span class="s2">&quot;subset&quot;</span><span class="p">],</span> 
                <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w+&#39;</span><span class="p">,</span>
                <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span>
                <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">,),</span> <span class="c1"># PIL xy inversion</span>
                <span class="n">fortran_order</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">version</span><span class="o">=</span><span class="kc">None</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">rank</span><span class="p">,</span> <span class="n">chunk_slice</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_slices</span><span class="p">()):</span>
                <span class="n">beg</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">uncompressed_beg_end</span><span class="p">(</span><span class="n">rank</span><span class="p">)</span> <span class="c1"># indep of calc_name</span>
                <span class="n">mmap</span><span class="p">[</span><span class="n">beg</span><span class="p">:</span><span class="n">end</span><span class="p">]</span> <span class="o">=</span> <span class="n">subset</span><span class="p">[</span><span class="n">chunk_slice</span><span class="p">]</span>

            <span class="k">del</span> <span class="n">mmap</span>


    <span class="k">def</span> <span class="nf">get_data_memmap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calc_name</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r+&#39;</span><span class="p">):</span>
        <span class="c1"># See &quot;Development Note - Memory mapping &quot;</span>
        <span class="n">data_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_path</span><span class="p">(</span><span class="n">calc_name</span><span class="p">)</span>
        <span class="n">mmap</span> <span class="o">=</span> <span class="n">open_memmap</span><span class="p">(</span>
            <span class="n">filename</span><span class="o">=</span><span class="n">data_path</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">mmap</span>


    <span class="k">def</span> <span class="nf">update_data_mmaps</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">calc_name</span><span class="p">,</span> <span class="n">chunk_slice</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">stop_reason</span><span class="p">,</span> <span class="n">stop_iter</span>
    <span class="p">):</span>
        <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_data</span><span class="p">[</span><span class="n">calc_name</span><span class="p">][</span><span class="s2">&quot;state&quot;</span><span class="p">]</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SAVE_ARRS</span>
        <span class="n">arr_map</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;Z&quot;</span><span class="p">:</span> <span class="n">Z</span><span class="p">,</span>
            <span class="s2">&quot;U&quot;</span><span class="p">:</span> <span class="n">U</span><span class="p">,</span>
            <span class="s2">&quot;stop_reason&quot;</span><span class="p">:</span> <span class="n">stop_reason</span><span class="p">,</span>
            <span class="s2">&quot;stop_iter&quot;</span><span class="p">:</span> <span class="n">stop_iter</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_rank</span><span class="p">(</span><span class="n">chunk_slice</span><span class="p">)</span>
        <span class="n">beg</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compressed_beg_end</span><span class="p">(</span><span class="n">calc_name</span><span class="p">,</span> <span class="n">rank</span><span class="p">)</span>

        <span class="c1"># codes mapping - taking into account suppressed fields</span>
        <span class="c1"># (those starting with &quot;_&quot;)</span>
        <span class="p">(</span><span class="n">complex_codes</span><span class="p">,</span> <span class="n">int_codes</span><span class="p">,</span> <span class="n">stop_codes</span><span class="p">)</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">codes</span>
        <span class="c1"># keep only the one which do not sart with &quot;_&quot;</span>
        <span class="n">f_complex_codes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_stored_codes</span><span class="p">(</span><span class="n">complex_codes</span><span class="p">)</span>
        <span class="n">f_int_codes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_stored_codes</span><span class="p">(</span><span class="n">int_codes</span><span class="p">)</span>
        <span class="n">n_Z</span><span class="p">,</span> <span class="n">n_U</span><span class="p">,</span> <span class="n">n_stop</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">codes</span><span class="p">)</span> <span class="k">for</span> <span class="n">codes</span> <span class="ow">in</span> 
                            <span class="p">(</span><span class="n">f_complex_codes</span><span class="p">,</span> <span class="n">f_int_codes</span><span class="p">,</span> <span class="n">stop_codes</span><span class="p">))</span>
        <span class="n">codes_index_map</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;Z&quot;</span><span class="p">:</span> <span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_Z</span><span class="p">),</span> <span class="nb">list</span><span class="p">(</span><span class="n">complex_codes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">f_complex_codes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> 
                                   <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_Z</span><span class="p">))),</span>
            <span class="s2">&quot;U&quot;</span><span class="p">:</span> <span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_U</span><span class="p">),</span> <span class="nb">list</span><span class="p">(</span><span class="n">int_codes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">f_int_codes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                                     <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_U</span><span class="p">))),</span>
            <span class="s2">&quot;stop_reason&quot;</span><span class="p">:</span> <span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">)),</span>
            <span class="s2">&quot;stop_iter&quot;</span><span class="p">:</span> <span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
            <span class="n">mmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_data_memmap</span><span class="p">(</span><span class="n">calc_name</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r+&quot;</span><span class="p">)</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">arr_map</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">f_field</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">codes_index_map</span><span class="p">[</span><span class="n">key</span><span class="p">]):</span>
                <span class="n">mmap</span><span class="p">[</span><span class="n">field</span><span class="p">,</span> <span class="n">beg</span><span class="p">:</span><span class="n">end</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">f_field</span><span class="p">,</span> <span class="p">:]</span>


    <span class="k">def</span> <span class="nf">reload_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chunk_slice</span><span class="p">,</span> <span class="n">calc_name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Reload all stored raw arrays for this chunk : </span>
<span class="sd">        raw_data = subset, Z, U, stop_reason, stop_iter</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SAVE_ARRS</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_rank</span><span class="p">(</span><span class="n">chunk_slice</span><span class="p">)</span>
        <span class="n">beg</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compressed_beg_end</span><span class="p">(</span><span class="n">calc_name</span><span class="p">,</span> <span class="n">rank</span><span class="p">)</span>

        <span class="n">arr</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
            <span class="n">mmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_data_memmap</span><span class="p">(</span><span class="n">calc_name</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="n">arr</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">[:,</span> <span class="n">beg</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">mmap</span>

        <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_data</span><span class="p">[</span><span class="n">calc_name</span><span class="p">][</span><span class="s2">&quot;state&quot;</span><span class="p">]</span>
        <span class="n">subset</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">subset</span>

        <span class="k">if</span> <span class="n">subset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># /!\ fixed-size irrespective of the mask</span>
            <span class="n">beg</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">uncompressed_beg_end</span><span class="p">(</span><span class="n">rank</span><span class="p">)</span> <span class="c1"># indep of calc_name</span>
            <span class="n">mmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_data_memmap</span><span class="p">(</span><span class="n">calc_name</span><span class="p">,</span> <span class="s2">&quot;subset&quot;</span><span class="p">)</span>
            <span class="n">arr</span><span class="p">[</span><span class="s2">&quot;subset&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">[</span><span class="n">beg</span><span class="p">:</span> <span class="n">end</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">mmap</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">arr</span><span class="p">[</span><span class="s2">&quot;subset&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="c1"># Reload c_pic - Note: we are in a &quot;not final&quot; (aka developement)</span>
        <span class="c1"># rendering ; jitter / supersampling are desactivated</span>
        <span class="n">c_pix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">chunk_pixel_pos</span><span class="p">(</span><span class="n">chunk_slice</span><span class="p">,</span> <span class="n">jitter</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">supersampling</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">subset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">c_pix</span> <span class="o">=</span> <span class="n">c_pix</span><span class="p">[</span><span class="n">arr</span><span class="p">[</span><span class="s2">&quot;subset&quot;</span><span class="p">]]</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="n">arr</span><span class="p">[</span><span class="s2">&quot;subset&quot;</span><span class="p">],</span> <span class="n">c_pix</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="s2">&quot;Z&quot;</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="s2">&quot;U&quot;</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="s2">&quot;stop_reason&quot;</span><span class="p">],</span>
            <span class="n">arr</span><span class="p">[</span><span class="s2">&quot;stop_iter&quot;</span><span class="p">]</span>
        <span class="p">)</span>


    <span class="nd">@Multithreading_iterator</span><span class="p">(</span>
        <span class="n">iterable_attr</span><span class="o">=</span><span class="s2">&quot;chunk_slices&quot;</span><span class="p">,</span> <span class="n">iter_kwargs</span><span class="o">=</span><span class="s2">&quot;chunk_slice&quot;</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">compute_rawdata_dev</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calc_name</span><span class="p">,</span> <span class="n">chunk_slice</span><span class="p">,</span> <span class="n">tile_validator</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; In dev mode we follow a 2-step approach : here the compute step</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tile_validator</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">tile_validator</span><span class="p">(</span><span class="n">chunk_slice</span><span class="p">)):</span>
                <span class="k">return</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_interrupted</span><span class="p">():</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;Interrupted - skipping calc for:</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">calc_name</span><span class="si">}</span><span class="s2"> ; </span><span class="si">{</span><span class="n">chunk_slice</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">res_available</span><span class="p">(</span><span class="n">calc_name</span><span class="p">,</span> <span class="n">chunk_slice</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;Result already available - skipping calc for:</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">calc_name</span><span class="si">}</span><span class="s2"> ; </span><span class="si">{</span><span class="n">chunk_slice</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">incr_tiles_status</span><span class="p">(</span><span class="n">which</span><span class="o">=</span><span class="s2">&quot;Calc tiles&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="p">(</span><span class="n">cycle_dep_args</span><span class="p">,</span> <span class="n">chunk_subset</span>
         <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cycling_dep_args</span><span class="p">(</span><span class="n">calc_name</span><span class="p">,</span> <span class="n">chunk_slice</span><span class="p">)</span>
        <span class="n">cycle_indep_args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_data</span><span class="p">[</span><span class="n">calc_name</span><span class="p">][</span><span class="s2">&quot;cycle_indep_args&quot;</span><span class="p">]</span>
        
        <span class="n">ret_code</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numba_cycle_call</span><span class="p">(</span><span class="n">cycle_dep_args</span><span class="p">,</span> <span class="n">cycle_indep_args</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ret_code</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">USER_INTERRUPTED</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Interruption signal received&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="p">(</span><span class="n">c_pix</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">stop_reason</span><span class="p">,</span> <span class="n">stop_iter</span><span class="p">)</span> <span class="o">=</span> <span class="n">cycle_dep_args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_report_mmap</span><span class="p">(</span><span class="n">calc_name</span><span class="p">,</span> <span class="n">chunk_slice</span><span class="p">,</span> <span class="n">stop_reason</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_data_mmaps</span><span class="p">(</span>
                <span class="n">calc_name</span><span class="p">,</span> <span class="n">chunk_slice</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">stop_reason</span><span class="p">,</span> <span class="n">stop_iter</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">incr_tiles_status</span><span class="p">(</span><span class="n">which</span><span class="o">=</span><span class="s2">&quot;Calc tiles&quot;</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">reload_rawdata_dev</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calc_name</span><span class="p">,</span> <span class="n">chunk_slice</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; In dev mode we follow a 2-step approach : here the reload step</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">res_available</span><span class="p">(</span><span class="n">calc_name</span><span class="p">,</span> <span class="n">chunk_slice</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">incr_tiles_status</span><span class="p">(</span><span class="n">which</span><span class="o">=</span><span class="s2">&quot;Plot tiles&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reload_data</span><span class="p">(</span><span class="n">chunk_slice</span><span class="p">,</span> <span class="n">calc_name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Interrupted calculation ?</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">res_available</span><span class="p">(</span><span class="n">calc_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Results unavailable for </span><span class="si">{</span><span class="n">calc_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">evaluate_rawdata_final</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calc_name</span><span class="p">,</span> <span class="n">chunk_slice</span><span class="p">,</span> <span class="n">postproc_options</span><span class="p">):</span>
        <span class="c1"># we ARE in final render</span>
        <span class="c1"># - take into account postproc_options</span>
        <span class="c1"># - do not save raw data arrays to avoid too much disk usage (e.g.,</span>
        <span class="c1">#   in case of supersampling...)</span>
        <span class="n">jitter</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">postproc_options</span><span class="p">[</span><span class="s2">&quot;jitter&quot;</span><span class="p">])</span> <span class="c1"># casting to float</span>
        <span class="n">supersampling</span> <span class="o">=</span> <span class="n">SUPERSAMPLING_DIC</span><span class="p">[</span><span class="n">postproc_options</span><span class="p">[</span><span class="s2">&quot;supersampling&quot;</span><span class="p">]]</span>
        <span class="p">(</span><span class="n">cycle_dep_args</span><span class="p">,</span> <span class="n">chunk_subset</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cycling_dep_args</span><span class="p">(</span>
            <span class="n">calc_name</span><span class="p">,</span> <span class="n">chunk_slice</span><span class="p">,</span>
            <span class="n">final</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">jitter</span><span class="o">=</span><span class="n">jitter</span><span class="p">,</span> <span class="n">supersampling</span><span class="o">=</span><span class="n">supersampling</span>
        <span class="p">)</span>

        <span class="n">cycle_indep_args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_data</span><span class="p">[</span><span class="n">calc_name</span><span class="p">][</span><span class="s2">&quot;cycle_indep_args&quot;</span><span class="p">]</span>
        <span class="n">ret_code</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numba_cycle_call</span><span class="p">(</span><span class="n">cycle_dep_args</span><span class="p">,</span> <span class="n">cycle_indep_args</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">incr_tiles_status</span><span class="p">(</span><span class="n">which</span><span class="o">=</span><span class="s2">&quot;Plot tiles&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ret_code</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">USER_INTERRUPTED</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Interruption signal received&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="p">(</span><span class="n">c_pix</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">stop_reason</span><span class="p">,</span> <span class="n">stop_iter</span><span class="p">)</span> <span class="o">=</span> <span class="n">cycle_dep_args</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">chunk_subset</span><span class="p">,</span> <span class="n">c_pix</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">stop_reason</span><span class="p">,</span> <span class="n">stop_iter</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">evaluate_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calc_name</span><span class="p">,</span> <span class="n">chunk_slice</span><span class="p">,</span> <span class="n">postproc_options</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Compute on the fly the raw arrays for this chunk : </span>
<span class="sd">        raw_data = subset, Z, U, stop_reason, stop_iter</span>
<span class="sd">        Note: this is normally activated only for a final redering</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">postproc_options</span><span class="p">[</span><span class="s2">&quot;final_render&quot;</span><span class="p">]:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_rawdata_final</span><span class="p">(</span>
                <span class="n">calc_name</span><span class="p">,</span> <span class="n">chunk_slice</span><span class="p">,</span> <span class="n">postproc_options</span>
            <span class="p">)</span>
            <span class="c1"># Post calc saving</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_subset_hook&quot;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">save_subset_arrays</span><span class="p">(</span>
                    <span class="n">calc_name</span><span class="p">,</span> <span class="n">chunk_slice</span><span class="p">,</span> <span class="n">postproc_options</span><span class="p">,</span> <span class="n">ret</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reload_rawdata_dev</span><span class="p">(</span><span class="n">calc_name</span><span class="p">,</span> <span class="n">chunk_slice</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">kind_from_code</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">codes</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        codes as returned by </span>
<span class="sd">        (params, codes) = self.reload_data_chunk(chunk_slice, calc_name)</span>
<span class="sd">        Used for &quot;raw&quot; post-processing</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">complex_codes</span><span class="p">,</span> <span class="n">int_codes</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">codes</span>
        <span class="k">if</span> <span class="n">code</span> <span class="ow">in</span> <span class="n">complex_codes</span><span class="p">:</span>
            <span class="n">kind</span> <span class="o">=</span> <span class="s2">&quot;complex&quot;</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="ow">in</span> <span class="n">int_codes</span><span class="p">:</span>
            <span class="n">kind</span> <span class="o">=</span> <span class="s2">&quot;int&quot;</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="s2">&quot;stop_reason&quot;</span><span class="p">:</span>
            <span class="n">kind</span> <span class="o">=</span> <span class="n">code</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="s2">&quot;stop_iter&quot;</span><span class="p">:</span>
            <span class="n">kind</span> <span class="o">=</span> <span class="n">code</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                <span class="s2">&quot;raw data code unknow: &quot;</span> <span class="o">+</span> <span class="n">code</span><span class="p">,</span> <span class="n">complex_codes</span><span class="p">,</span>
                <span class="n">int_codes</span><span class="p">,</span> <span class="s2">&quot;stop_reason&quot;</span><span class="p">,</span> <span class="s2">&quot;stop_iter&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">kind</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">reshape2d</span><span class="p">(</span><span class="n">chunk_array</span><span class="p">,</span> <span class="n">subset</span><span class="p">,</span> <span class="n">chunk_slice</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns 2d versions of the 1d stored vecs</span>
<span class="sd">               chunk_array of size (n_post, n_pts)</span>
<span class="sd">        </span>
<span class="sd">        # note : to get a 2-dimensionnal vec do:</span>
<span class="sd">                 if bool_mask is not None:</span>
<span class="sd">                 we need to inverse</span>
<span class="sd">                     subset = np.ravel(subset[chunk_size])</span>
<span class="sd">                     c = c[subset]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">ixx</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">iyy</span><span class="p">)</span> <span class="o">=</span> <span class="n">chunk_slice</span>
        <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">ixx</span> <span class="o">-</span> <span class="n">ix</span><span class="p">,</span> <span class="n">iyy</span> <span class="o">-</span> <span class="n">iy</span>
        <span class="n">n_post</span><span class="p">,</span> <span class="n">n_pts</span> <span class="o">=</span> <span class="n">chunk_array</span><span class="o">.</span><span class="n">shape</span>

        <span class="n">chunk_1d</span> <span class="o">=</span> <span class="n">Fractal</span><span class="o">.</span><span class="n">reshape1d</span><span class="p">(</span><span class="n">chunk_array</span><span class="p">,</span> <span class="n">subset</span><span class="p">,</span> <span class="n">chunk_slice</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">chunk_1d</span><span class="p">,</span> <span class="p">[</span><span class="n">n_post</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">])</span>
    
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">reshape1d</span><span class="p">(</span><span class="n">chunk_array</span><span class="p">,</span> <span class="n">subset</span><span class="p">,</span> <span class="n">chunk_slice</span><span class="p">,</span> <span class="n">supersampling</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns unmasked 1d versions of the 1d stored vecs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">ixx</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">iyy</span><span class="p">)</span> <span class="o">=</span> <span class="n">chunk_slice</span>
        <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">ixx</span> <span class="o">-</span> <span class="n">ix</span><span class="p">,</span> <span class="n">iyy</span> <span class="o">-</span> <span class="n">iy</span>
        <span class="n">n_post</span><span class="p">,</span> <span class="n">n_pts</span> <span class="o">=</span> <span class="n">chunk_array</span><span class="o">.</span><span class="n">shape</span>

        <span class="k">if</span> <span class="n">subset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">chunk_1d</span> <span class="o">=</span> <span class="n">chunk_array</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">npts</span> <span class="o">=</span> <span class="n">nx</span> <span class="o">*</span> <span class="n">ny</span>
            <span class="k">if</span> <span class="n">supersampling</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">npts</span> <span class="o">*=</span> <span class="n">supersampling</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">npts</span><span class="p">)[</span><span class="n">subset</span><span class="p">]</span>
            <span class="n">chunk_1d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">n_post</span><span class="p">,</span> <span class="n">npts</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">chunk_array</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">chunk_1d</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">chunk_1d</span><span class="p">[:,</span> <span class="n">indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">chunk_array</span>

        <span class="k">return</span> <span class="n">chunk_1d</span>
    
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">index2d</span><span class="p">(</span><span class="n">index_1d</span><span class="p">,</span> <span class="n">subset</span><span class="p">,</span> <span class="n">chunk_slice</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Return the 2d-indexing from 1d + mask </span>
<span class="sd">        subset = None | self.subset[chunk_slice]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># chunk_size = fssettings.chunk_size</span>
        <span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">ixx</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">iyy</span><span class="p">)</span> <span class="o">=</span> <span class="n">chunk_slice</span>
        <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">ixx</span> <span class="o">-</span> <span class="n">ix</span><span class="p">,</span> <span class="n">iyy</span> <span class="o">-</span> <span class="n">iy</span>
        <span class="n">ix</span><span class="p">,</span> <span class="n">iy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">indices</span><span class="p">((</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">))</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">ix</span><span class="p">)</span>
        <span class="n">iy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">iy</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">subset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ix</span> <span class="o">=</span> <span class="n">ix</span><span class="p">[</span><span class="n">subset</span><span class="p">]</span>
            <span class="n">iy</span> <span class="o">=</span> <span class="n">iy</span><span class="p">[</span><span class="n">subset</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">ix</span><span class="p">[</span><span class="n">index_1d</span><span class="p">],</span> <span class="n">iy</span><span class="p">[</span><span class="n">index_1d</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">codes_mapping</span><span class="p">(</span><span class="n">complex_codes</span><span class="p">,</span> <span class="n">int_codes</span><span class="p">,</span> <span class="n">termination_codes</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Utility function, returns the inverse mapping code -&gt; int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">complex_dic</span><span class="p">,</span> <span class="n">int_dic</span><span class="p">,</span> <span class="n">termination_dic</span> <span class="o">=</span> <span class="p">[</span><span class="nb">dict</span><span class="p">(</span>
            <span class="nb">zip</span><span class="p">(</span><span class="n">tab</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tab</span><span class="p">))))</span> <span class="k">for</span> <span class="n">tab</span> <span class="ow">in</span> <span class="p">[</span>
            <span class="n">complex_codes</span><span class="p">,</span> <span class="n">int_codes</span><span class="p">,</span> <span class="n">termination_codes</span><span class="p">]]</span>
        <span class="k">return</span> <span class="n">complex_dic</span><span class="p">,</span> <span class="n">int_dic</span><span class="p">,</span> <span class="n">termination_dic</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">subsubset</span><span class="p">(</span><span class="n">bool_set</span><span class="p">,</span> <span class="n">bool_subset_of_set</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns boolean array for a subset</span>
<span class="sd">        Parameters    </span>
<span class="sd">         - *bool_set* bool array of shape N, defines a set </span>
<span class="sd">         - *bool_subset_of_set* bool array of shape Card(set)</span>
<span class="sd">        Returns</span>
<span class="sd">         - *bool_subset* bool array of shape N</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">set_count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">bool_set</span><span class="p">)</span>
        <span class="n">Card_set</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">bool_subset_of_set</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">Card_set</span> <span class="o">!=</span> <span class="n">set_count</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expected bool_subset_of_set of shape&quot;</span>
                             <span class="s2">&quot; [Card(set)]&quot;</span><span class="p">)</span>
        <span class="n">bool_subset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">bool_set</span><span class="p">)</span>
        <span class="n">bool_subset</span><span class="p">[</span><span class="n">bool_set</span><span class="p">]</span> <span class="o">=</span> <span class="n">bool_subset_of_set</span>
        <span class="k">return</span> <span class="n">bool_subset</span>


    <span class="k">def</span> <span class="nf">calc_raw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calc_name</span><span class="p">,</span> <span class="n">tile_validator</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Here we can create the memory mappings and launch the calculation</span>
<span class="sd">        loop&quot;&quot;&quot;</span>
        <span class="c1"># Note: at this point res_available(calc_name) IS True, however</span>
        <span class="c1"># mmaps might not have been created.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_data</span><span class="p">[</span><span class="n">calc_name</span><span class="p">][</span><span class="s2">&quot;need_new_mmap&quot;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">init_report_mmap</span><span class="p">(</span><span class="n">calc_name</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">init_data_mmaps</span><span class="p">(</span><span class="n">calc_name</span><span class="p">)</span>

        <span class="c1"># Launching the calculation + mmap storing multithreading loop</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_rawdata_dev</span><span class="p">(</span>
            <span class="n">calc_name</span><span class="p">,</span> <span class="n">chunk_slice</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tile_validator</span><span class="o">=</span><span class="n">tile_validator</span>
        <span class="p">)</span>


    <span class="k">def</span> <span class="nf">postproc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">postproc_batch</span><span class="p">,</span> <span class="n">chunk_slice</span><span class="p">,</span> <span class="n">postproc_options</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Computes the output of ``postproc_batch`` for chunk_slice</span>
<span class="sd">        Return</span>
<span class="sd">          post_array of shape(nposts, chunk_n_pts)</span>
<span class="sd">          subset</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">postproc_batch</span><span class="o">.</span><span class="n">fractal</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Postproc batch from a different factal provided&quot;</span><span class="p">)</span>
        <span class="n">calc_name</span> <span class="o">=</span> <span class="n">postproc_batch</span><span class="o">.</span><span class="n">calc_name</span>

        <span class="k">if</span> <span class="n">postproc_options</span><span class="p">[</span><span class="s2">&quot;final_render&quot;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="s2">&quot;Calc tiles&quot;</span><span class="p">,</span> <span class="s2">&quot;No [final]&quot;</span><span class="p">,</span> <span class="n">bool_log</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_data</span><span class="p">(</span><span class="n">calc_name</span><span class="p">,</span> <span class="n">chunk_slice</span><span class="p">,</span> <span class="n">postproc_options</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ret</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Unexpected interruption</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="p">(</span><span class="n">subset</span><span class="p">,</span> <span class="n">c_pix</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">stop_reason</span><span class="p">,</span> <span class="n">stop_iter</span><span class="p">)</span> <span class="o">=</span> <span class="n">ret</span>
        <span class="n">codes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_data</span><span class="p">[</span><span class="n">calc_name</span><span class="p">][</span><span class="s2">&quot;saved_codes&quot;</span><span class="p">]</span>
        <span class="n">complex_dic</span><span class="p">,</span> <span class="n">int_dic</span><span class="p">,</span> <span class="n">termination_dic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">codes_mapping</span><span class="p">(</span><span class="o">*</span><span class="n">codes</span><span class="p">)</span>


        <span class="n">postproc_batch</span><span class="o">.</span><span class="n">set_chunk_data</span><span class="p">(</span><span class="n">chunk_slice</span><span class="p">,</span> <span class="n">subset</span><span class="p">,</span> <span class="n">c_pix</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span>
            <span class="n">stop_reason</span><span class="p">,</span> <span class="n">stop_iter</span><span class="p">,</span> <span class="n">complex_dic</span><span class="p">,</span> <span class="n">int_dic</span><span class="p">,</span> <span class="n">termination_dic</span><span class="p">)</span>

        <span class="c1"># Output data</span>
        <span class="n">n_pts</span> <span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># Z of shape [n_Z, n_pts]</span>
        <span class="n">post_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
            <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">postproc_batch</span><span class="o">.</span><span class="n">posts</span><span class="p">),</span> <span class="n">n_pts</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">float_postproc_type</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">postproc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">postproc_batch</span><span class="o">.</span><span class="n">posts</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="n">val</span><span class="p">,</span> <span class="n">context_update</span> <span class="o">=</span> <span class="n">postproc</span><span class="p">[</span><span class="n">chunk_slice</span><span class="p">]</span>
            <span class="n">post_array</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>  <span class="o">=</span> <span class="n">val</span>
            <span class="n">postproc_batch</span><span class="o">.</span><span class="n">update_context</span><span class="p">(</span><span class="n">chunk_slice</span><span class="p">,</span> <span class="n">context_update</span><span class="p">)</span>

        <span class="n">postproc_batch</span><span class="o">.</span><span class="n">clear_chunk_data</span><span class="p">(</span><span class="n">chunk_slice</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">post_array</span><span class="p">,</span> <span class="n">subset</span>


    <span class="k">def</span> <span class="nf">get_std_cpt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c_pix</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Return the c complex value from c_pix &quot;&quot;&quot;</span>
        <span class="n">n_pts</span><span class="p">,</span> <span class="o">=</span> <span class="n">c_pix</span><span class="o">.</span><span class="n">shape</span>  <span class="c1"># Z of shape [n_Z, n_pts]</span>
        <span class="c1"># Explicit casting to complex</span>
        <span class="n">center</span> <span class="o">=</span> <span class="nb">complex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

        <span class="n">cpt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_pts</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">c_pix</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">fill1d_c_from_pix</span><span class="p">(</span>
            <span class="n">c_pix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">proj_impl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lin_mat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">cpt</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">cpt</span>
        

<span class="c1">#==============================================================================</span>
<span class="c1"># GUI : &quot;interactive options&quot;</span>
<span class="c1">#==============================================================================</span>
    <span class="k">def</span> <span class="nf">coords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">pix</span><span class="p">,</span> <span class="n">dps</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; x, y : coordinates of the event &quot;&quot;&quot;</span>
        <span class="n">x_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">y_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">res_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">coords = </span><span class="se">{{</span>
<span class="s2">    &quot;x&quot;: &quot;</span><span class="si">{</span><span class="n">x_str</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="s2">    &quot;y&quot;: &quot;</span><span class="si">{</span><span class="n">y_str</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="se">}}</span>
<span class="s2">&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">res_str</span></div>



<span class="c1">#==============================================================================</span>

<span class="k">class</span> <span class="nc">_Subset_temporary_array</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fractal</span><span class="p">,</span> <span class="n">calc_name_from</span><span class="p">,</span> <span class="n">calc_name_to</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">inv</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Drop-in replacement for Fractal_array in case of on-the-fly </span>
<span class="sd">        computation: used when final calculation &amp; subset activated &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fractal</span> <span class="o">=</span> <span class="n">fractal</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calc_name_from</span> <span class="o">=</span> <span class="n">calc_name_from</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calc_name_to</span> <span class="o">=</span> <span class="n">calc_name_to</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_func</span> <span class="o">=</span> <span class="n">func</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inv</span> <span class="o">=</span> <span class="n">inv</span>

        <span class="c1"># Parsing the func string if needed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>
        <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">fs_parser</span><span class="o">.</span><span class="n">func_parser</span><span class="p">([</span><span class="s2">&quot;x&quot;</span><span class="p">],</span> <span class="n">func</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">path</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Memory mapping used in case of on-fly calculation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fractal</span><span class="o">.</span><span class="n">directory</span><span class="p">,</span> <span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_name_to</span> <span class="o">+</span> <span class="s2">&quot;_subset._img&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">init_mmap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">supersampling</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Create the memory mapping</span>
<span class="sd">        Format: 1-d UNcompressed per chunk, takes into account supersampling</span>
<span class="sd">        as needed. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">subset_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Opening subset mmap at: </span><span class="si">{</span><span class="n">subset_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">npts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fractal</span><span class="o">.</span><span class="n">nx</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">fractal</span><span class="o">.</span><span class="n">ny</span>
        <span class="k">if</span> <span class="n">supersampling</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">npts</span> <span class="o">*=</span> <span class="n">supersampling</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">mmap</span> <span class="o">=</span> <span class="n">open_memmap</span><span class="p">(</span>
            <span class="n">filename</span><span class="o">=</span><span class="n">subset_path</span><span class="p">,</span> 
            <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w+&#39;</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="nb">bool</span><span class="p">),</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">npts</span><span class="p">,),</span>
            <span class="n">fortran_order</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">version</span><span class="o">=</span><span class="kc">None</span>
        <span class="p">)</span>
        <span class="k">del</span> <span class="n">mmap</span>
        <span class="c1"># Storing status (/!\ not thread safe)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">supersampling</span> <span class="o">=</span> <span class="n">supersampling</span>
        <span class="c1"># del mmap</span>
        <span class="c1"># self._mmap = mmap</span>

    <span class="k">def</span> <span class="nf">close_mmap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">supersampling</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mmap</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chunk_slice</span><span class="p">,</span> <span class="n">bool_arr</span><span class="p">):</span>
        <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fractal</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">chunk_rank</span><span class="p">(</span><span class="n">chunk_slice</span><span class="p">)</span>
        <span class="n">beg</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">uncompressed_beg_end</span><span class="p">(</span><span class="n">rank</span><span class="p">)</span>
        <span class="n">ssg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">supersampling</span>
        <span class="k">if</span> <span class="n">ssg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">beg</span> <span class="o">*=</span> <span class="n">ssg</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="n">end</span> <span class="o">*=</span> <span class="n">ssg</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">_mmap</span> <span class="o">=</span> <span class="n">open_memmap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">(),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r+&#39;</span><span class="p">)</span>
        <span class="n">_mmap</span><span class="p">[</span><span class="n">beg</span><span class="p">:</span> <span class="n">end</span><span class="p">]</span> <span class="o">=</span> <span class="n">bool_arr</span>
        <span class="k">del</span> <span class="n">_mmap</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chunk_slice</span><span class="p">):</span>
        <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fractal</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">chunk_rank</span><span class="p">(</span><span class="n">chunk_slice</span><span class="p">)</span>
        <span class="n">beg</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">uncompressed_beg_end</span><span class="p">(</span><span class="n">rank</span><span class="p">)</span>
        <span class="n">ssg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">supersampling</span>
        <span class="k">if</span> <span class="n">ssg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">beg</span> <span class="o">*=</span> <span class="n">ssg</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="n">end</span> <span class="o">*=</span> <span class="n">ssg</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">_mmap</span> <span class="o">=</span> <span class="n">open_memmap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">(),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r+&#39;</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">_mmap</span><span class="p">[</span><span class="n">beg</span><span class="p">:</span> <span class="n">end</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">_mmap</span>
        <span class="k">return</span> <span class="n">ret</span>


    <span class="k">def</span> <span class="nf">save_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chunk_slice</span><span class="p">,</span> <span class="n">ret</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Compute on the fly the boolean array &amp; save it in memory mapping&quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">subset</span><span class="p">,</span> <span class="n">c_pix</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">stop_reason</span><span class="p">,</span> <span class="n">stop_iter</span><span class="p">)</span> <span class="o">=</span> <span class="n">ret</span>
        <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fractal</span>

        <span class="k">if</span> <span class="n">subset</span>  <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Chained subset &#39;on the fly&#39;, currently not implemented&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Identify the base 1d array</span>
        <span class="n">codes</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">_calc_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">calc_name_from</span><span class="p">][</span><span class="s2">&quot;saved_codes&quot;</span><span class="p">]</span>
        <span class="n">kind</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">kind_from_code</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">codes</span><span class="p">)</span>
        <span class="n">complex_dic</span><span class="p">,</span> <span class="n">int_dic</span><span class="p">,</span> <span class="n">termination_dic</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">codes_mapping</span><span class="p">(</span><span class="o">*</span><span class="n">codes</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;complex&quot;</span><span class="p">:</span>
            <span class="n">arr_base</span> <span class="o">=</span> <span class="n">Z</span><span class="p">[</span><span class="n">complex_dic</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">]]</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
            <span class="n">arr_base</span> <span class="o">=</span> <span class="n">U</span><span class="p">[</span><span class="n">int_dic</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">]]</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="ow">in</span> <span class="s2">&quot;stop_reason&quot;</span><span class="p">:</span>
            <span class="n">arr_base</span> <span class="o">=</span> <span class="n">stop_reason</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;stop_iter&quot;</span><span class="p">:</span>
            <span class="n">arr_base</span> <span class="o">=</span> <span class="n">stop_iter</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">kind</span><span class="p">)</span>

        <span class="c1"># Apply func + inv as needed</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">arr_base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">arr_base</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inv</span><span class="p">:</span>
            <span class="n">arr_base</span> <span class="o">=</span> <span class="o">~</span><span class="n">arr_base</span>

        <span class="bp">self</span><span class="p">[</span><span class="n">chunk_slice</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr_base</span>



<span class="c1">#==============================================================================</span>
<span class="c1"># Numba JIT functions</span>
<span class="c1">#==============================================================================</span>
        
<span class="n">USER_INTERRUPTED</span> <span class="o">=</span> <span class="mi">1</span>

<span class="nd">@numba</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">numba_cycles</span><span class="p">(</span>
    <span class="n">c_pix</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">stop_reason</span><span class="p">,</span> <span class="n">stop_iter</span><span class="p">,</span>
    <span class="n">initialize</span><span class="p">,</span> <span class="n">iterate</span><span class="p">,</span>
    <span class="n">center</span><span class="p">,</span> <span class="n">proj_impl</span><span class="p">,</span> <span class="n">lin_mat</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span>
    <span class="n">_interrupted</span>
<span class="p">):</span>
    <span class="c1"># Full iteration for a set of points - calls numba_cycle</span>
    <span class="n">npts</span> <span class="o">=</span> <span class="n">c_pix</span><span class="o">.</span><span class="n">size</span>

    <span class="k">for</span> <span class="n">ipt</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npts</span><span class="p">):</span>
        <span class="n">Zpt</span> <span class="o">=</span> <span class="n">Z</span><span class="p">[:,</span> <span class="n">ipt</span><span class="p">]</span>
        <span class="n">Upt</span> <span class="o">=</span> <span class="n">U</span><span class="p">[:,</span> <span class="n">ipt</span><span class="p">]</span>
        <span class="n">cpt</span> <span class="o">=</span> <span class="n">c_from_pix</span><span class="p">(</span>
            <span class="n">c_pix</span><span class="p">[</span><span class="n">ipt</span><span class="p">],</span> <span class="n">proj_impl</span><span class="p">,</span> <span class="n">lin_mat</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">center</span>
        <span class="p">)</span>
        <span class="n">stop_pt</span> <span class="o">=</span> <span class="n">stop_reason</span><span class="p">[:,</span> <span class="n">ipt</span><span class="p">]</span>

        <span class="n">initialize</span><span class="p">(</span><span class="n">Zpt</span><span class="p">,</span> <span class="n">Upt</span><span class="p">,</span> <span class="n">cpt</span><span class="p">)</span>
        <span class="n">n_iter</span> <span class="o">=</span> <span class="n">iterate</span><span class="p">(</span>
            <span class="n">cpt</span><span class="p">,</span> <span class="n">Zpt</span><span class="p">,</span> <span class="n">Upt</span><span class="p">,</span> <span class="n">stop_pt</span>
        <span class="p">)</span>
        <span class="n">stop_iter</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">ipt</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_iter</span>
        <span class="n">stop_reason</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">ipt</span><span class="p">]</span> <span class="o">=</span> <span class="n">stop_pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">_interrupted</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">USER_INTERRUPTED</span>

    <span class="k">return</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">numba_iterate</span><span class="p">(</span>
    <span class="n">calc_orbit</span><span class="p">,</span> <span class="n">i_znorbit</span><span class="p">,</span> <span class="n">backshift</span><span class="p">,</span> <span class="n">zn</span><span class="p">,</span> <span class="n">iterate_once</span><span class="p">,</span> <span class="n">zn_iterate</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Numba implementation - recompiled if options change &quot;&quot;&quot;</span>
    <span class="nd">@numba</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">numba_impl</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">stop</span><span class="p">):</span>
        <span class="n">n_iter</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">calc_orbit</span><span class="p">:</span>
            <span class="n">div_shift</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">orbit_zn1</span> <span class="o">=</span> <span class="n">Z</span><span class="p">[</span><span class="n">zn</span><span class="p">]</span>
            <span class="n">orbit_zn2</span> <span class="o">=</span> <span class="n">Z</span><span class="p">[</span><span class="n">zn</span><span class="p">]</span>
            <span class="n">orbit_i1</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">orbit_i2</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">n_iter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">iterate_once</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">n_iter</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">calc_orbit</span><span class="p">:</span>
                <span class="n">div</span> <span class="o">=</span> <span class="n">n_iter</span> <span class="o">//</span> <span class="n">backshift</span>
                <span class="k">if</span> <span class="n">div</span> <span class="o">&gt;</span> <span class="n">div_shift</span><span class="p">:</span>
                    <span class="n">div_shift</span> <span class="o">=</span> <span class="n">div</span>
                    <span class="n">orbit_i2</span> <span class="o">=</span> <span class="n">orbit_i1</span>
                    <span class="n">orbit_zn2</span> <span class="o">=</span> <span class="n">orbit_zn1</span>
                    <span class="n">orbit_i1</span> <span class="o">=</span> <span class="n">n_iter</span>
                    <span class="n">orbit_zn1</span> <span class="o">=</span> <span class="n">Z</span><span class="p">[</span><span class="n">zn</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="n">calc_orbit</span><span class="p">:</span>
            <span class="n">zn_orbit</span> <span class="o">=</span> <span class="n">orbit_zn2</span>
            <span class="k">while</span> <span class="n">orbit_i2</span> <span class="o">&lt;</span> <span class="n">n_iter</span> <span class="o">-</span> <span class="n">backshift</span><span class="p">:</span>
                <span class="n">zn_orbit</span> <span class="o">=</span> <span class="n">zn_iterate</span><span class="p">(</span><span class="n">zn_orbit</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
                <span class="n">orbit_i2</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">Z</span><span class="p">[</span><span class="n">i_znorbit</span><span class="p">]</span> <span class="o">=</span> <span class="n">zn_orbit</span>

        <span class="k">return</span> <span class="n">n_iter</span>
    <span class="k">return</span> <span class="n">numba_impl</span>


<span class="k">def</span> <span class="nf">numba_iterate_BS</span><span class="p">(</span>
    <span class="n">calc_orbit</span><span class="p">,</span> <span class="n">i_xnorbit</span><span class="p">,</span> <span class="n">i_ynorbit</span><span class="p">,</span> <span class="n">backshift</span><span class="p">,</span> <span class="n">xn</span><span class="p">,</span> <span class="n">yn</span><span class="p">,</span>
    <span class="n">iterate_once</span><span class="p">,</span> <span class="n">xnyn_iterate</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Numba implementation - recompiled if options change &quot;&quot;&quot;</span>
    <span class="nd">@numba</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">numba_impl</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">stop</span><span class="p">):</span>
        <span class="n">n_iter</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">calc_orbit</span><span class="p">:</span>
            <span class="n">div_shift</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">orbit_xn1</span> <span class="o">=</span> <span class="n">Z</span><span class="p">[</span><span class="n">xn</span><span class="p">]</span>
            <span class="n">orbit_xn2</span> <span class="o">=</span> <span class="n">Z</span><span class="p">[</span><span class="n">xn</span><span class="p">]</span>
            <span class="n">orbit_yn1</span> <span class="o">=</span> <span class="n">Z</span><span class="p">[</span><span class="n">yn</span><span class="p">]</span>
            <span class="n">orbit_yn2</span> <span class="o">=</span> <span class="n">Z</span><span class="p">[</span><span class="n">yn</span><span class="p">]</span>
            <span class="n">orbit_i1</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">orbit_i2</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="n">a</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">real</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">imag</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">n_iter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">iterate_once</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">n_iter</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">calc_orbit</span><span class="p">:</span>
                <span class="n">div</span> <span class="o">=</span> <span class="n">n_iter</span> <span class="o">//</span> <span class="n">backshift</span>
                <span class="k">if</span> <span class="n">div</span> <span class="o">&gt;</span> <span class="n">div_shift</span><span class="p">:</span>
                    <span class="n">div_shift</span> <span class="o">=</span> <span class="n">div</span>
                    <span class="n">orbit_i2</span> <span class="o">=</span> <span class="n">orbit_i1</span>
                    <span class="n">orbit_xn2</span> <span class="o">=</span> <span class="n">orbit_xn1</span>
                    <span class="n">orbit_yn2</span> <span class="o">=</span> <span class="n">orbit_yn1</span>
                    <span class="n">orbit_i1</span> <span class="o">=</span> <span class="n">n_iter</span>
                    <span class="n">orbit_xn1</span> <span class="o">=</span> <span class="n">Z</span><span class="p">[</span><span class="n">xn</span><span class="p">]</span>
                    <span class="n">orbit_yn1</span> <span class="o">=</span> <span class="n">Z</span><span class="p">[</span><span class="n">yn</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="n">calc_orbit</span><span class="p">:</span>
            <span class="n">xn_orbit</span> <span class="o">=</span> <span class="n">orbit_xn2</span>
            <span class="n">yn_orbit</span> <span class="o">=</span> <span class="n">orbit_yn2</span>
            <span class="k">while</span> <span class="n">orbit_i2</span> <span class="o">&lt;</span> <span class="n">n_iter</span> <span class="o">-</span> <span class="n">backshift</span><span class="p">:</span>
                <span class="n">xn_orbit</span><span class="p">,</span> <span class="n">yn_orbit</span> <span class="o">=</span> <span class="n">xnyn_iterate</span><span class="p">(</span><span class="n">xn_orbit</span><span class="p">,</span> <span class="n">yn_orbit</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
                <span class="n">orbit_i2</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">Z</span><span class="p">[</span><span class="n">i_xnorbit</span><span class="p">]</span> <span class="o">=</span> <span class="n">xn_orbit</span>
            <span class="n">Z</span><span class="p">[</span><span class="n">i_ynorbit</span><span class="p">]</span> <span class="o">=</span> <span class="n">yn_orbit</span>

        <span class="k">return</span> <span class="n">n_iter</span>
    <span class="k">return</span> <span class="n">numba_impl</span>


<span class="k">def</span> <span class="nf">numba_Newton</span><span class="p">(</span>   
    <span class="n">known_orders</span><span class="p">,</span> <span class="n">max_order</span><span class="p">,</span> <span class="n">max_newton</span><span class="p">,</span> <span class="n">eps_newton_cv</span><span class="p">,</span>
    <span class="n">reason_max_order</span><span class="p">,</span> <span class="n">reason_order_confirmed</span><span class="p">,</span>
    <span class="n">izr</span><span class="p">,</span> <span class="n">idzrdz</span><span class="p">,</span> <span class="n">idzrdc</span><span class="p">,</span> <span class="n">id2zrdzdc</span><span class="p">,</span> <span class="n">i_partial</span><span class="p">,</span>  <span class="n">i_zn</span><span class="p">,</span> <span class="n">iorder</span><span class="p">,</span>
    <span class="n">zn_iterate</span><span class="p">,</span> <span class="n">iterate_newton_search</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Numba implementation </span>
<span class="sd">    Run Newton search to find z0 so that f^n(z0) == z0 (n being the order)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@numba</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">numba_impl</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">stop</span><span class="p">):</span>
        
        <span class="n">n_iter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">n_iter</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">n_iter</span> <span class="o">&gt;</span> <span class="n">max_order</span><span class="p">:</span>
                <span class="n">stop</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">reason_max_order</span>
                <span class="k">break</span>

            <span class="c1"># If n is not a &#39;partial&#39; for this point it cannot be the </span>
            <span class="c1"># cycle order : early exit</span>
            <span class="n">Z</span><span class="p">[</span><span class="n">i_zn</span><span class="p">]</span> <span class="o">=</span> <span class="n">zn_iterate</span><span class="p">(</span><span class="n">Z</span><span class="p">[</span><span class="n">i_zn</span><span class="p">],</span> <span class="n">c</span><span class="p">)</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Z</span><span class="p">[</span><span class="n">i_zn</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="n">Z</span><span class="p">[</span><span class="n">i_partial</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="p">:</span>
                <span class="c1"># This is a new partial, might be an attracting cycle</span>
                <span class="n">Z</span><span class="p">[</span><span class="n">i_partial</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span> <span class="c1"># Cannot assign to the real part </span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Early exit if n it is not a multiple of one of the</span>
            <span class="c1"># known_orders (provided by the user)</span>
            <span class="k">if</span> <span class="n">known_orders</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">valid</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">order</span> <span class="ow">in</span> <span class="n">known_orders</span><span class="p">:</span>
                    <span class="k">if</span>  <span class="n">n_iter</span> <span class="o">%</span> <span class="n">order</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">valid</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">valid</span><span class="p">:</span>
                    <span class="k">continue</span>

            <span class="n">z0_loop</span> <span class="o">=</span> <span class="nb">complex</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span> <span class="c1"># Z[0]</span>
            <span class="n">dz0dc_loop</span> <span class="o">=</span> <span class="nb">complex</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span>  <span class="c1"># Z[2]</span>

            <span class="k">for</span> <span class="n">i_newton</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_newton</span><span class="p">):</span>
                <span class="n">zr</span> <span class="o">=</span> <span class="n">z0_loop</span>
                <span class="n">dzrdc</span> <span class="o">=</span> <span class="n">dz0dc_loop</span>
                <span class="n">dzrdz</span> <span class="o">=</span> <span class="nb">complex</span><span class="p">(</span><span class="mf">1.</span><span class="p">)</span>
                <span class="n">d2zrdzdc</span> <span class="o">=</span> <span class="nb">complex</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_iter</span><span class="p">):</span>
                    <span class="c1"># It seems it is not possible to split and compute the</span>
                    <span class="c1"># derivatives in postprocssing when convergence is reached</span>
                    <span class="c1"># --&gt; we do it during the Newton iterations</span>
                    <span class="n">d2zrdzdc</span><span class="p">,</span> <span class="n">dzrdc</span><span class="p">,</span> <span class="n">dzrdz</span><span class="p">,</span> <span class="n">zr</span> <span class="o">=</span> <span class="n">iterate_newton_search</span><span class="p">(</span>
                            <span class="n">d2zrdzdc</span><span class="p">,</span> <span class="n">dzrdc</span><span class="p">,</span> <span class="n">dzrdz</span><span class="p">,</span> <span class="n">zr</span><span class="p">,</span> <span class="n">c</span>
                    <span class="p">)</span>

                <span class="n">delta</span> <span class="o">=</span> <span class="p">(</span><span class="n">zr</span> <span class="o">-</span> <span class="n">z0_loop</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">dzrdz</span> <span class="o">-</span> <span class="mf">1.</span><span class="p">)</span>
                <span class="n">newton_cv</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">eps_newton_cv</span><span class="p">)</span>
                <span class="n">zz</span> <span class="o">=</span> <span class="n">z0_loop</span> <span class="o">-</span> <span class="n">delta</span>
                <span class="n">dz0dc_loop</span> <span class="o">=</span> <span class="n">dz0dc_loop</span> <span class="o">-</span> <span class="p">(</span>
                    <span class="p">(</span><span class="n">dzrdc</span> <span class="o">-</span> <span class="n">dz0dc_loop</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">dzrdz</span> <span class="o">-</span> <span class="mf">1.</span><span class="p">)</span>
                    <span class="o">-</span> <span class="p">(</span><span class="n">zr</span> <span class="o">-</span> <span class="n">z0_loop</span><span class="p">)</span> <span class="o">*</span> <span class="n">d2zrdzdc</span> <span class="o">/</span> <span class="p">(</span><span class="n">dzrdz</span> <span class="o">-</span> <span class="mf">1.</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
                <span class="p">)</span>
                <span class="n">z0_loop</span> <span class="o">=</span> <span class="n">zz</span>
                <span class="k">if</span> <span class="n">newton_cv</span><span class="p">:</span>
                    <span class="k">break</span>

            <span class="c1"># We have a candidate but is it the good one ?</span>
            <span class="n">is_confirmed</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dzrdz</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">1.</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">newton_cv</span>
            <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">is_confirmed</span><span class="p">):</span> <span class="c1"># not found, try next</span>
                <span class="k">continue</span>

            <span class="n">Z</span><span class="p">[</span><span class="n">izr</span><span class="p">]</span> <span class="o">=</span> <span class="n">zr</span>
            <span class="n">Z</span><span class="p">[</span><span class="n">idzrdz</span><span class="p">]</span> <span class="o">=</span> <span class="n">dzrdz</span> <span class="c1"># attr (cycle attractivity)</span>
            <span class="n">Z</span><span class="p">[</span><span class="n">idzrdc</span><span class="p">]</span> <span class="o">=</span> <span class="n">dzrdc</span>
            <span class="n">Z</span><span class="p">[</span><span class="n">id2zrdzdc</span><span class="p">]</span> <span class="o">=</span> <span class="n">d2zrdzdc</span> <span class="c1"># dattrdc</span>
            <span class="n">U</span><span class="p">[</span><span class="n">iorder</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_iter</span>
            <span class="n">stop</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">reason_order_confirmed</span>
            <span class="k">break</span>

        <span class="c1"># End of while loop</span>
        <span class="k">return</span> <span class="n">n_iter</span>

    <span class="k">return</span> <span class="n">numba_impl</span>


<span class="nd">@numba</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">apply_unskew_1d</span><span class="p">(</span><span class="n">skew</span><span class="p">,</span> <span class="n">arrx</span><span class="p">,</span> <span class="n">arry</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Unskews the view for contravariant coordinates e.g. normal vec</span>
<span class="sd">    Used in postproc.py to keep the right orientation for the shadings </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">arrx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="n">arrx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">ny</span> <span class="o">=</span> <span class="n">arry</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="c1"># Note: this is a product by the transposed matrix</span>
        <span class="c1"># *Contravariant* indexing</span>
        <span class="n">arrx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">skew</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">nx</span> <span class="o">+</span> <span class="n">skew</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">ny</span>
        <span class="n">arry</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">skew</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">nx</span> <span class="o">+</span> <span class="n">skew</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">ny</span>


<span class="nd">@numba</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># (numba.complex128(numba.complex128))</span>
<span class="k">def</span> <span class="nf">lin_proj_impl</span><span class="p">(</span><span class="n">lin_mat</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">real</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">imag</span>
    <span class="n">x1</span> <span class="o">=</span> <span class="n">lin_mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">lin_mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">y</span>
    <span class="n">y1</span> <span class="o">=</span> <span class="n">lin_mat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">lin_mat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">y</span>

    <span class="k">return</span>  <span class="n">dx</span> <span class="o">*</span> <span class="nb">complex</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">)</span>

<span class="nd">@numba</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">c_from_pix</span><span class="p">(</span><span class="n">pix</span><span class="p">,</span> <span class="n">proj_impl</span><span class="p">,</span> <span class="n">lin_mat</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">center</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the true c from the pixel coords</span>
<span class="sd">    Note: to be re-implemented for pertubation theory, as C = cref + dc</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pix :  complex</span>
<span class="sd">        pixel location in fraction of dx</span>
<span class="sd">    center : coordinates of the image center</span>
<span class="sd">    proj_impl : numba func </span>
<span class="sd">        Non-linear part of the projection (for a &quot;cartesian projection&quot; this</span>
<span class="sd">        is simply a pass-through)</span>
<span class="sd">    proj_impl : numba func </span>
<span class="sd">        Non-linear part of the projection. Includes the following effects:</span>
<span class="sd">            - scaling (with dx)</span>
<span class="sd">            - rotation (with theta)</span>
<span class="sd">            - skew</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    c : c value as complex</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">center</span> <span class="o">+</span> <span class="n">lin_proj_impl</span><span class="p">(</span><span class="n">lin_mat</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">proj_impl</span><span class="p">(</span><span class="n">pix</span><span class="p">))</span>


<span class="nd">@numba</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">fill1d_c_from_pix</span><span class="p">(</span><span class="n">c_pix</span><span class="p">,</span> <span class="n">proj_impl</span><span class="p">,</span> <span class="n">lin_mat</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">c_out</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Same as c_from_pix but fills in-place a 1d vec &quot;&quot;&quot;</span>
    <span class="n">nx</span> <span class="o">=</span> <span class="n">c_pix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nx</span><span class="p">):</span>
        <span class="n">c_out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_from_pix</span><span class="p">(</span>
            <span class="n">c_pix</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">proj_impl</span><span class="p">,</span> <span class="n">lin_mat</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">center</span>
        <span class="p">)</span>
</pre></div>

           </div>
          </div>
<div class="ribbon">
  <a href="https://github.com/GBillotey/Fractalshades">Fork me on GitHub</a>
</div>

          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Fractalshades development team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 
<style>
  .wy-nav-content { max-width: 1250px !important; }
</style>


</body>
</html>